<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title></title></head><body><hr />
<p>title: The C Programming Language
author:</p>
<ul>
<li>Brian W. Kernighan</li>
<li>Dennis M. Ritchie
edition: Second Edition
date: April 1988</li>
</ul>
<hr />
<h1>Preface {-}</h1>
<p>This is not official. This is a copy of the official book, written in Pandoc
Markdown and <code>pandoc-crossref</code>. There are two motives behind this copy:</p>
<ol>
<li>Having a plain-text readable format of this book (diagrams have been
replaced by ASCII diagrams);</li>
<li>Enabling “patches” to be created, updating/fixing this book.</li>
</ol>
<p>The edition and date has not been changed since this is, essentially, the same
as the second edition; it still contains all the known errors, and it does not
include anything on the newer standards.</p>
<p>anon</p>
<p>P.S. The appendix is incomplete.</p>
<h1>Original Preface to the Second Edition {-}</h1>
<p>The computing world has undergone a revolution since the publication of <em>The C
Programming Language</em> in 1978. Big computers are much bigger, and personal
computers have capabilities that rival the mainframes of a decade ago. During
this time, C has changed too, although only modestly, and it has spread far
beyond its origins as the language of the UNIX operating system.</p>
<p>The growing popularity of C, the changes in the language over the years, and
the creation of compilers by groups not involved in its design, combined to
demonstrate a need for a more precise and more contemporary definition of the
language than the first edition of this book provided. In 1983, the American
National Standards Institute (ANSI) established a committee whose goal was to
produce “an unambiguous and machine-independent definition of the language C,”
while still retaining its spirit. The result is the ANSI standard for C.</p>
<p>The standard formalizes constructions that were hinted at but not described in
the first edition, particularly structure assignment and enumerations.  It
provides a new form of function declaration that permits cross-checking of
definition with use. It specifies a standard library, with an extensive set of
functions for performing input and output, memory management, string
manipulation, and similar tasks. It makes precise the behavior of features that
were not spelled out in the original definition, and at the same time states
explicitly which aspects of the language remain machine-dependent.</p>
<p>This second edition of <em>The C Programming Language</em> describes C as defined by
the ANSI standard. Although we have noted the places where the language has
evolved, we have chosen to write exclusively in the new form. For the most
part, this makes no significant difference; the most visible change is the new
form of function declaration and definition. Modern compilers already support
most features of the standard.</p>
<p>We have tried to retain the brevity of the first edition. C is not a big
language, and it is not well served by a big book. We have improved the
exposition of critical features, such as pointers, that are central to C
programming. We have refined the original examples, and have added new examples
in several chapters. For instance, the treatment of complicated declarations is
augmented by programs that convert declarations into words and vice versa. As
before, all examples have been tested directly from the text, which is in
machine-readable form.</p>
<p>[Appendix @sec:ref-man], the reference manual, is not the standard, but our
attempt to convey the essentials of the standard in a smaller space. It is
meant for easy comprehension by programmers, but not as a definition for
compiler writers—that role properly belongs to the standard itself. [Appendix
@sec:std-lib] is a summary of the facilities of the standard library. It too is
meant for reference by programmers, not implementers. [Appendix @sec:changes]
is a concise summary of the changes from the original version.</p>
<p>As we said in the preface to the first edition, C “wears well as one’s
experience with it grows.” With a decade more experience, we still feel that
way. We hope that this book will help you to learn C and to use it well.</p>
<p>We are deeply indebted to friends who helped us to produce this second edition.
Jon Bentley, Doug Gwyn, Doug McIlroy, Peter Nelson, and Rob Pike gave us
perceptive comments on almost every page of draft manuscripts. We are grateful
for careful reading by Al Aho, Dennis Allison, Joe Campbell, G. R. Emlin, Karen
Fortgang, Allen Holub, Andrew Hume, Dave Kristol, John Linderman, Dave Prosser,
Gene Spafford, and Chris Van Wyk. We also received helpful suggestions from
Bill Cheswick, Mark Kernighan, Andy Koenig, Robin Lake, Tom London, Jim Reeds,
Clovis Tondo, and Peter Weinberger. Dave Prosser answered many detailed
questions about the ANSI standard. We used Bjarne Stroustrup’s C++ translator
extensively for local testing of our programs, and Pave Kristol provided us
with an ANSI C compiler for final testing. Rich Drechsler helped greatly with
typesetting.</p>
<p>Our sincere thanks to all.</p>
<p>Brian W. Kernighan</p>
<p>Dennis M. Ritchie</p>
<h1>Preface to the First Edition {-}</h1>
<p>C is a general-purpose programming language which features economy of
expression, modern control flow and data structures, and a rich set of
operators. C is not a “very high level” language, nor a “big” one, and is not
specialized to any particular area of application. But its absence of
restrictions and its generality make it more convenient and effective for many
tasks than supposedly more powerful languages.</p>
<p>C was originally designed for and implemented on the UNIX operating system on
the DEC PDP-11, by Dennis Ritchie. The operating system, the C compiler, and
essentially all UNIX applications programs (including all of the software used
to prepare this book) are written in C. Production compilers also exist for
several other machines, including the IBM System/370, the Honeywell 6000, and
the Interdata 8/32. C is not tied to any particular hardware or system,
however, and it is easy to write programs that will run without change on any
machine that supports C.</p>
<p>This book is meant to help the reader learn how to program in C. It contains a
tutorial introduction to get new users started as soon as possible, separate
chapters on each major feature, and a reference manual. Most of the treatment
is based on reading, writing and revising examples, rather than on mere
statements of rules. For the most part, the examples are complete, real
programs, rather than isolated fragments. All examples have been tested
directly from the text, which is in machine-readable form. Besides showing how
to make effective use of the language, we have also tried where possible to
illustrate useful algorithms and principles of good style and sound design.</p>
<p>The book is not an introductory programming manual; it assumes some familiarity
with basic programming concepts like variables, assignment statements,loops,
and functions. Nonetheless, a novice programmer should be able to read along
and pick up the language, although access to a more knowledgeable colleague
will help.</p>
<p>In our experience, C has proven to be a pleasant, expressive, and versatile
language for a wide variety of programs. It is easy to learn, and it wears well
as one’s experience with it grows. We hope that this book will help you to use
it well.</p>
<p>The thoughtful criticisms and suggestions of many friends and colleagues have
added greatly to this book and to our pleasure in writing it. In particular,
Mike Bianchi, Jim Blue, Stu Feldman, Doug McIlroy, Bill Roome, Bob Rosin, and
Larry Rosier all read multiple versions with care. We are also indebted to Al
Aho, Steve Bourne, Dan Dvorak, Chuck Haley, Debbie Haley, Marion Harris, Rick
Holt, Steve Johnson, John Mashey, Bob Mitze, Ralph Muha, Peter Nelson, Elliot
Pinson, Bill Plauger, Jerry Spivack, Ken Thompson, and Peter Weinberger for
helpful comments at various stages, and to Mike Lesk and Joe Ossanna for
invaluable assistance with typesetting.</p>
<p>Brian W. Kernighan</p>
<p>Dennis M. Ritchie</p>
<h1>Introduction {-}</h1>
<p>C is a general-purpose programming language. It has been closely associated
with the UNIX system where it was developed, since both the system and most of
the programs that run on it are written in C. The language, however, is not
tied to any one operating system or machine; and although it has been called a
“system programming language” because it is useful for writing compilers and
operating systems, it has been used equally well to write major programs in
many different domains.</p>
<p>Many of the important ideas of C stem from the language BCPL, developed by
Martin Richards. The influence of BCPL on C proceeded indirectly through the
language B, which was written by Ken Thompson in 1970 for the first UNIX system
on the DEC PDP-7.</p>
<p>BCPL and B are “typeless” languages. By contrast, C provides a variety of data
types. The fundamental types are characters, and integers and floating-point
numbers of several sizes. In addition, there is a hierarchy of derived data
types created with pointers, arrays, structures, and unions. Expressions are
formed from operators and operands; any expression, including an assignment or
a function call, can be a statement. Pointers provide for machine-independent
address arithmetic.</p>
<p>C provides the fundamental control-flow constructions required for
well-structured programs: statement grouping, decision making (<code>if</code>-<code>else</code>),
selecting one of a set of possible cases (<code>switch</code>), looping with the
termination test at the top (<code>while</code>, <code>for</code>) or at the bottom (<code>do</code>), and early
loop exit (<code>break</code>).</p>
<p>Functions may return values of basic types, structures, unions, or pointers.Any
function may be called recursively. Local variables are typically “automatic,”
or created anew with each invocation. Function definitions may not be nested
but variables may be declared in a block-structured fashion. The functions of a
C program may exist in separate source files that are compiled separately.
Variables may be internal to a function, external but known only within a
single source file, or visible to the entire program.</p>
<p>A preprocessing step performs macro substitution on program text, inclusion of
other source files, and conditional compilation.</p>
<p>C is a relatively “low level” language. This characterization is not
pejorative; it simply means that C deals with the same sort of objects that
most computers do, namely characters, numbers, and addresses. These may be
combined and moved about with the arithmetic and logical operators implemented
by real machines.</p>
<p>C provides no operations to deal directly with composite objects such as
character strings, sets, lists, or arrays. There are no operations that
manipulate an entire array or string, although structures may be copied as a
unit. The language does not define any storage allocation facility other than
static definition and the stack discipline provided by the local variables of
functions; there is no heap or garbage collection. Finally, C itself provides
no input/output facilities; there are no READ or WRITE statements, and no
built-in file access methods. All of these higher-level mechanisms must be
provided by explicitly-called functions. Most C implementations have included a
reasonably standard collection of such functions.</p>
<p>Similarly, C offers only straightforward, single-thread control flow: tests,
loops, grouping, and subprograms, but not multiprogramming, parallel
operations, synchronization, or coroutines.</p>
<p>Although the absence of some of these features may seem like a grave deficiency
(“You mean I have to call a function to compare two character strings?”),
keeping the language down to modest size has real benefits. Since C is
relatively small, it can be described in a small space, and learned quickly. A
programmer can reasonably expect to know and understand and indeed regularly
use the entire language.</p>
<p>For many years, the definition of C was the reference manual in the first
edition of <em>The C Programming Language</em>. In 1983, the American National
Standards Institute (ANSI) established a committee to provide a modern,
comprehensive definition of C. The resulting definition, the ANSI standard, or
“ANSI C,” was completed late in 1988. Most of the features of the standard are
already supported by modern compilers.</p>
<p>The standard is based on the original reference manual. The language is
relatively little changed; one of the goals of the standard was to make sure
that most existing programs would remain valid, or, failing that, that
compilers could produce warnings of new behavior.</p>
<p>For most programmers, the most important change is a new syntax for declaring
and defining functions. A function declaration can now include a description of
the arguments of the function; the definition syntax changes to match. This
extra information makes it much easier for compilers to detect errors caused by
mismatched arguments; in our experience, it is a very useful addition to the
language.</p>
<p>There are other small-scale language changes. Structure assignment and
enumerations, which had been widely available, are now officially part of the
language. Floating-point computations may now be done in single precision. The
properties of arithmetic, especially for unsigned types, are clarified. The
preprocessor is more elaborate. Most of these changes will have only minor
effects on most programmers.</p>
<p>A second significant contribution of the standard is the definition of a
library to accompany C. It specifies functions for accessing the operating
system (for instance, to read and write files), formatted input and output,
memory allocation, string manipulation, and the like. A collection of standard
headers provides uniform access to declarations of functions and data types.
Programs that use this library to interact with a host system are assured of
compatible behavior. Most of the library is closely modeled on the “standard
I/O library” of the UNIX system. This library was described in the first
edition, and has been widely used on other systems as well. Again, most
programmers will not see much Change.</p>
<p>Because the data types and control structures provided by C are supported
directly by most computers, the run-time library required to implement
self-contained programs is tiny. The standard library functions are only called
explicitly, so they can be avoided if they are not needed. Most can be written
in C, and except for the operating system details they conceal, are themselves
portable.</p>
<p>Although C matches the capabilities of many computers, it is independent of any
particular machine architecture. With a little care it is easy to write
portable programs, that is, programs that can be run without change on a
variety of hardware. The standard makes portability issues explicit, and
prescribes a set of constants that characterize the machine on which the
program is run.</p>
<p>C is not a strongly-typed language, but as it has evolved, its type-checking
has been strengthened. The original definition of C frowned on, but permitted,
the interchange of pointers and integers; this has long since been eliminated,
and the standard now requires the proper declarations and explicit conversions
that had already been enforced by good compilers. The new function declarations
are another step in this direction. Compilers will warn of most type errors,
and there is no automatic conversion of incompatible data types. Nevertheless,
C retains the basic philosophy that programmers know what they are doing; it
only requires that they state their intentions explicitly.</p>
<p>C, like any other language, has its blemishes. Some of the operators have the
wrong precedence; some parts of the syntax could be better. Nonetheless, C has
proven to be an extremely effective and expressive language for a wide variety
of programming applications.</p>
<p>The book is organized as follows. [Chapter @sec:introduction] is a tutorial on
the central part of C. The purpose is to get the reader started as quickly as
possible, since we believe strongly that the way to learn a new language is to
write programs in it. The tutorial does assume a working knowledge of the basic
elements of programming; there is no explanation of computers, of compilation,
nor of the meaning of an expression like <code>n=n+1</code>. Although we have tried where
possible to show useful programming techniques, the book is not intended to be
a reference work on data structures and algorithms; when forced to make a
choice, we have concentrated on the language.</p>
<p>[Chapters @sec:types-ops-expressions] through [-@sec:structures] discuss
various aspects of C in more detail, and rather more formally, than does
[Chapter @sec:introduction], although the emphasis is still on examples of
complete programs, rather than isolated fragments. [Chapter
@sec:types-ops-expressions] deals with the basic data types, operators and
expressions. [Chapter @sec:control-flow] treats control flow: <code>if</code>-<code>else</code>,
<code>switch</code>, <code>while</code>, <code>for</code>, etc. [Chapter @sec:functions] covers functions and
program structure—external variables, scope rules, multiple source files, and
so on—and also touches on the preprocessor. [Chapter @sec:pointers] discusses
pointers and address arithmetic. [Chapter @sec:structures] covers structures
and unions.</p>
<p>[Chapter @sec:IO] describes the standard library, which provides a common
interface to the operating system. This library is defined by the ANSI standard
and is meant to be supported on all machines that support C, so programs that
use it for input, output, and other operating system access can be moved from
one system to another without change.</p>
<p>[Chapter @sec:UNIX] describes an interface between C programs and the UNIX
operating system, concentrating on input/output, the file system, and storage
allocation.  Although some of this chapter is specific to UNIX systems,
programmers who use other systems should still find useful material here,
including some insight into how one version of the standard library is
implemented, and suggestions on portability.</p>
<p>[Appendix @sec:ref-man] contains a language reference manual. The official
statement of the syntax and semantics of C is the ANSI standard itself. That
document, however, is intended foremost for compiler writers. The reference
manual here conveys the definition of the language more concisely and without
the same legalistic style.  [Appendix @sec:std-lib] is a summary of the
standard library, again for users rather than implementers. [Appendix
@sec:changes] is a short summary of changes from the original language. In
cases of doubt, however, the standard and one’s own compiler remain the final
authorities on the language.</p>
<h1>A Tutorial Introduction {#sec:introduction}</h1>
<p>Let us begin with a quick introduction to C. Our aim is to show the essential
elements of the language in real programs, but without getting bogged down in
details, rules, and exceptions. At this point, we are not trying to be complete
or even precise (save that the examples are meant to be correct). We want to
get you as quickly as possible to the point where you can write useful
programs, and to do that we have to concentrate on the basics: variables and
constants, arithmetic, control flow, functions, and the rudiments of input and
output. We are intentionally leaving out of this chapter features of C that are
important for writing bigger programs. These include pointers, structures, most
of C’s rich set of operators, several control-flow statements, and the standard
library.</p>
<p>This approach has its drawbacks. Most notable is that the complete story on any
particular language feature is not found here, and the tutorial, by being
brief, may also be misleading. And because the examples do not use the full
power of C, they are not as concise and elegant as they might be. We have tried
to minimize these effects, but be warned. Another drawback is that later
chapters will necessarily repeat some of this chapter. We hope that the
repetition will help you more than it annoys.</p>
<p>In any case, experienced programmers should be able to extrapolate from the
material in this chapter to their own programming needs. Beginners should
supplement it by writing small, similar programs of their own. Both groups can
use it as a framework on which to hang the more detailed descriptions that
begin in [Chapter @sec:types-ops-expressions].</p>
<h2>Getting Started</h2>
<p>The only way to learn a new programming language is by writing programs in it.
The first program to write is the same for all languages:</p>
<pre><code>Print the words
     hello, world
</code></pre>
<p>This is the big hurdle; to leap over it you have to be able to create the
program text somewhere, compile it successfully, load it, run it, and find out
where your output went. With these mechanical details mastered, everything else
is comparatively easy.</p>
<p>In C, the program to print “hello, world” is</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

main()
{
    printf(&quot;hello, world\n&quot;);
}
</code></pre>
<p>Just how to run this program depends on the system you are using. As a specific
example, on the UNIX operating system you must create the program in a file
whose name ends in “<code>.c</code>”, such as <code>hello.c</code>, then compile it with the command</p>
<pre><code class="language-sh">cc hello.c
</code></pre>
<p>If you haven’t botched anything, such as omitting a character or misspelling
something, the compilation will proceed silently, and make an executable file
called <code>a.out</code>. If you run <code>a.out</code> by typing the command</p>
<pre><code class="language-sh">a.out
</code></pre>
<p>it will print</p>
<pre><code>hello, world
</code></pre>
<p>On other systems, the rules will be different; check with a local expert.</p>
<p>Now for some explanations about the program itself. A C program, whatever its
size, consists of <em>functions</em> and <em>variables</em>. A function contains <em>statements</em>
that specify the computing operations to be done, and variables store values
used during the computation. C functions are like the subroutines and functions
of Fortran or the procedures and functions of Pascal. Our example is a function
named, <code>main</code>. Normally you are at liberty to give functions whatever names you
like, but “<code>main</code>” is special?your program begins executing at the beginning of
main. This means that every program must have a <code>main</code> somewhere.</p>
<p><code>main</code> will usually call other functions to help perform its job, some that you
wrote, and others from libraries that are provided for you. The first line of
the program,</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
</code></pre>
<p>tells the compiler to include information about the standard input/output
library; this line appears at the beginning of many C source files.  The
standard library is described in [Chapter @sec:IO] and [Appendix @sec:std-lib].</p>
<p>One method of communicating data between functions is for the calling function
to provide a list of values, called <em>arguments</em>, to the function it calls. The
parentheses after the function name surround the argument list. In this
example, <code>main</code> is defined to be a function that expects no arguments, which is
indicated by the empty list <code>()</code>.</p>
<p>The statements of a function are enclosed in braces <code>{}</code>. The function <code>main</code>
contains only one statement,</p>
<pre><code class="language-c">printf(&quot;hello, world\n&quot;);
</code></pre>
<p>A function is called by naming it, followed by a parenthesized list of
arguments, so this calls the function <code>printf</code> with the argument <code>&quot;hello, world\n&quot;</code>. <code>printf</code> is a library function hat prints output, in this case the
string of characters between the quotes.</p>
<p>A sequence of characters in double quotes, like <code>&quot;hello, world\n&quot;</code>, is called a
<em>character string</em> or <em>string constant</em>. For the moment our only use of
character strings will be as arguments for <code>printf</code> and other functions.</p>
<p>The sequence <code>\n</code> in the string is C notation for the <em>newline character</em>,
which when printed advances the output to the left margin on the next line. If
you leave out the <code>\n</code> (a worthwhile experiment), you will find that there is
no line advance after the output is printed. You muse use <code>\n</code> to include a new
line character in the <code>printf</code> argument; if you try something like</p>
<pre><code class="language-c">printf(&quot;hello, world
&quot;);
</code></pre>
<p>the C compiler will produce an error message.</p>
<p><code>printf</code> never supplies a newline automatically, so several calls may be used
to build up an output line in stages. Our first program could just as well have
been written</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

main()
{
    printf(&quot;hello, &quot;);
    printf(&quot;world&quot;);
    printf(&quot;\n&quot;);
}
</code></pre>
<p>to produce identical output.</p>
<p>Notice that <code>\n</code> represents only a single character. An <code>escape sequence</code> like
<code>\n</code> provides a general and extensible mechanism for representing hard-to-type
or invisible characters. Among the others that C provides are <code>\t</code> for tab,
<code>\b</code> for backspace , <code>\&quot;</code> for double quote, and <code>\\</code> for the backslash itself.
There is a complete list in [Section @sec:constants].</p>
<p><strong>Exercise 1-1.</strong> Run the <code>&quot;hello, world&quot;</code> program on your system. Experiment
with leaving our parts of the program, to see what error messages you get.</p>
<p><strong>Exercise 1-2.</strong> Experiment to find out what happens when <code>printf</code>’s argument
string contains <code>\c</code> where <em>c</em> is some character not listed above.</p>
<h2>Variables and Arithmetic Expressions {#sec:vars-arith-expressions}</h2>
<p>The next program uses the formula <em><strong>°C = (5/9)(°F-32)</strong></em> to print the
following table of Fahrenheit temperatures and their centigrade or Celsius
equivalents:</p>
<pre><code>0   -17
20  -6
40  4
60  15
80  26
100 37
120 48
140 60
160 71
180 82
200 93
220 104
240 115
260 126
280 137
300 148
</code></pre>
<p>The program itself still consists of the definition of a single function named
<code>main</code>. It is longer than the one that printed <code>&quot;hello, world&quot;</code>, but not
complicated. It introduces several new ideas, including comments, declarations,
variables, arithmetic expressions, loops, and formatted output.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

/* print Fahrenheit-Celsius table
    for fahr = 0, 2, ..., 300 */
main()
{
    int fahr, celsius;
    int lower, upper, step;

    lower = 0;      /* lower limit of temperature table */
    upper = 300;    /* upper limit */
    step = 20;      /* step size */

    fahr = lower;
    while (fahr &lt;= upper) {
        celsius = 5 * (fahr-32) / 9;
        printf(&quot;%d\t%d\n&quot;, fahr, celsius);
        fahr = fahr + step;
    }
}
</code></pre>
<p>The two lines</p>
<pre><code class="language-c">/* print Fahrenheit-Celsius table
    for fahr = 0, 2, ..., 300 */
</code></pre>
<p>are a <em>comment</em>, which in this case explains briefly what the program does. Any
characters between <code>/*</code> and <code>*/</code> are ignored by the compiler; they may be used
freely to make a program easier to understand. Comments may appear anywhere a
blank or tab or newline can.</p>
<p>In C, all variables must be declared before they are used, usually at the
beginning of the function before any executable statements. A <em>declaration</em>
announces the properties of variables; it consists of a type name and a list of
variables, such as</p>
<pre><code class="language-c">int fahr, celsius;
int lower, upper, step;
</code></pre>
<p>The type <code>int</code> means that the variables listed are integers, by contrast with
<code>float</code>, which means floating point, i.e., numbers that may have a fractional
part. The range of both <code>int</code> and <code>float</code> depends on the machine you are using;
16-bit <code>int</code>s, which lie between <code>-32768</code> and <code>+32767</code>, are common, as are
32-bit <code>int</code>s. A <code>float</code> number is typically a 32-bit quantity, with at least
six significant digits and magnitude generally between about $10^{-38}$ and
$10^{+38}$.</p>
<p>C provides several other basic data types besides <code>int</code> and <code>float</code>, including:</p>
<pre><code>char    character---a single byte
short   short integer
long    long integer
double  double-precision floating point
</code></pre>
<p>The sizes of these objects are also machine-dependent. There are also <em>arrays</em>,
<em>structures</em> and <em>unions</em> of these basic types, <em>pointers</em> to them, and
<em>functions</em> that return them, all of which we will meet in due course.</p>
<p>Computation in the temperature conversion program begins with the <em>assignment</em>
statements</p>
<pre><code class="language-c">lower = 0;
upper = 300;
step = 20;
fahr = lower;
</code></pre>
<p>which set the variables to their initial values. Individual statements are
terminated by semicolons.</p>
<p>Each line of the table is computed the same way, so we use a loop that repeats
once per output line this is the purpose of the <code>while</code> loop</p>
<pre><code class="language-c">while (fahr &lt;= upper) {
    ...
}
</code></pre>
<p>The <code>while</code> loop operates as follows: The condition in parentheses is tested.
If it is true (<code>fahr</code> is less than or equal to <code>upper</code>), the body of the loop
(the three statements enclosed in braces) is executed. Then the condition is
re-tested, and if true, the body is executed again. When the test becomes false
(<code>fahr</code> exceeds <code>upper</code>) the loop ends, and execution continues at the
statement that follows the loop. There are no further statements in this
program, so it terminates.</p>
<p>The body of a <code>while</code> can be one or more statements enclosed in braces, as in
the temperature converter, or a single statement without braces, as in</p>
<pre><code class="language-c">while (i &lt; j)
    i = 2 * i;
</code></pre>
<p>In either case, we will always indent the statements controlled by the <code>while</code>
by one tab stop (which we have shown as four spaces) so you can see at a glance
which statements are inside the loop. The indentation emphasizes the logical
structure of the program. Although C compilers do not care about how a program
looks, proper indentation and spacing are critical in making programs easy for
people to read. We recommend writing only one statement per line, and using
blanks around operators to clarify grouping. The position of braces is less
important, although people hold passionate beliefs. We have chosen one of
several popular styles. Pick a style that suits you, then use it consistently.</p>
<p>Most of the work gets done in the body of the loop. The Celsius temperature is
computed and assigned to the variables <code>celsius</code> by the statement</p>
<pre><code class="language-c">celsius = 5 * (fahr-32) / 9;
</code></pre>
<p>The reason for multiplying by 5 and then dividing by 9 instead of just
multiplying by <code>5/9</code> is that in C, as in many other languages, integer division
<em>truncates</em>: any fractional part is discarded. Since 5 and 9 are integers,
<code>5/9</code> would be truncated to zero and so all the Celsius temperatures would be
reported as zero.</p>
<p>This example also shows a bit more of how <code>printf</code> works. <code>printf</code> is a
general-purpose output formatting function, which we will describe in detail in
[Chapter @sec:IO]. Its first argument is a string of characters to be printed,
with each <code>%</code> indicating where one of the other (second, third, …) arguments
is to be substituted, and in what form it is to be printed. For instance, <code>%d</code>
specifies an integer argument, so the statement <code>c printf(&quot;%d\t%d\n&quot;, fahr, celsius); </code> causes the values of the two integers <code>fahr</code> and <code>celsius</code> to be
printed, with a tab (<code>\t</code>) between them.</p>
<p>Each <code>%</code> construction in the first argument of <code>printf</code> is paired with the
corresponding second argument, third argument, etc.; they must match up
properly by number and type, or you’ll get wrong answers.</p>
<p>By the way, <code>printf</code> is not part of the C language; there is no input or output
defined in C itself. <code>printf</code> is just a useful function from the standard
library of functions that are normally accessible to C programs. The behaviour
of <code>printf</code> is defined in the ANSI standard, however, so its properties should
be the same with any compiler and library that conforms to the standard.</p>
<p>In order to concentrate on C itself, we won’t talk much about input and output
until [Chapter @sec:IO]. In particular, we will defer formatted input until
then.  If you have to input numbers, read the discussion of the function
<code>scanf</code> in [Section @sec:scanf]. <code>scanf</code> is like <code>printf</code>, except that it reads
input instead of writing output.</p>
<p>There are a couple of problems with the temperature conversion program. The
simpler one is that the output isn’t very pretty because the numbers are not
right-justified. That’s easy to fix; if we augment each <code>%d</code> in the <code>printf</code>
statement with a width, the numbers printed will be right-justified in their
fields. For instance, we might say</p>
<pre><code class="language-c">printf(&quot;%3d %6d\n&quot;, fahr, celsius);
</code></pre>
<p>to print the first number of each line in a field three digits wide, and the
second in a field six digits wide, like this:</p>
<pre><code>  0    -17
 20     -6
 40      4
 60     15
 80     26
100     37
...
</code></pre>
<p>The more serious problem is that because we have used integer arithmetic, the
Celsius temperatures are not very accurate; for instance, 0°F is actually about
-17.8°C, not -17. To get more accurate answers, we should use floating-point
arithmetic instead of integer. This requires some changes in the program. Here
is a second version:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

/* print Fahrenheit-Celsius table
    for fahr = 0, 20, ..., 300; floating-point version */
main()
{
    float fahr, celsius;
    int lower, upper, step;

    lower = 0;      /* lower limit of temperature table */
    upper = 300;    /* upper limit */
    step = 20;      /* step size */

    fahr = lower;
    while (fahr &lt;= upper) {
        celsius = (5.0/9.0) * (fahr-32.0);
        printf(&quot;%3.0f %6.1f\n&quot;, fahr, celsius);
        fahr = fahr + step;
    }
}
</code></pre>
<p>This is much the same as before, except that <code>fahr</code> and <code>celsius</code> are declared
to be <code>float</code>, and the formula for conversion is written in a more natural way.
We were unable to use <code>5/9</code> in the previous version because integer division
would truncate to zero. A decimal point in a constant indicates that it is
floating point, however, so <code>5.0/9.0</code> is not truncated because it is the ratio
of two floating-point values.</p>
<p>If an arithmetic operator has integer operands, an integer operation is
performed. If an arithmetic operator has one floating-point operand and one
integer operand, however, the integer will be converted to floating point
before the operation is done. If we had written <code>fahr-32</code>, the <code>32</code> would be
automatically converted to floating point. Nevertheless, writing floating-point
constants with explicit decimal points even when they have integral values
emphasizes their floating-point nature for human readers.
nametemplate=%s.html
The detailed rules for when integers are converted to floating point are in
[Chapter @sec:types-ops-expressions]. For now, notice that the assignment</p>
<pre><code class="language-c">fahr = lower;
</code></pre>
<p>and the test</p>
<pre><code class="language-c">while (fahr &lt;= upper)
</code></pre>
<p>also work in the natural way—the <code>int</code> is converted to <code>float</code> before the
operation is done.</p>
<p>The <code>printf</code> conversion specification <code>%3.0f</code> says that a floating-point number
(here <code>fahr</code>) is to be printed at least three characters wide, with no decimal
point and no fraction digits. <code>%6.af</code> describes another number (<code>celsisus</code>)
that is to be printed at least six characters wide, with 1 digit after the
decimal point. The output looks like this:</p>
<pre><code>  0  -17.8
 20   -6.7
 40    4.4
...
</code></pre>
<p>Width and precious may be omitted from a specification :<code>%6f</code> says that the
number is to be at least six characters wide; <code>%.2f</code> specifies two characters
after the decimal point, but the width is not constrained; and <code>%f</code> merely says
to print the number as floating point.</p>
<pre><code>%d      print as decimal integer
%6d     print as decimal integer, at least 6 characters wide
%f      print as floating point
%6f     print as floating point, at least 6 characters wide
%.2f    print as floating point, 2 characters after decimal point
%6.2f   print as floating point, at least 6 wide and 2 after decimal point
</code></pre>
<p>Among others, <code>printf</code> also recognizes <code>%o</code> for octal, <code>%x</code> for hexadecimal,
<code>%c</code> for characters, <code>%s</code> for character string, and <code>%%</code> for <code>%</code> it self.</p>
<p><strong>Exercise 1-3.</strong> Modify the temperature conversion program to print a heading
above the table.</p>
<p><strong>Exercise 1-4.</strong> Write a program to print the corresponding Celsius to
Fahrenheit table.</p>
<h2>The For Statement</h2>
<p>There are plenty of different ways to write a program for a particular task.
Let’s try a variation on the temperature converter.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

/* print Fahrenheit-Celsius table */
main()
{
    int fahr;

    for (fahr = 0; fahr &lt;= 300; fahr = fahr + 20)
        printf(&quot;%3d %6.1f\n&quot;, fahr, (5.0/9.0)*(fahr-32));
}
</code></pre>
<p>This produces the same answers, but it certainly looks different. One major
change is the elimination of most of the variables; only <code>fahr</code> remains, and we
have made it an <code>int</code>. The lower and upper limits and the step size appear only
as constants in the <code>for</code> statement, itself a new construction, and the
expression that computes the Celsius temperature now appears as the third
argument of <code>printf</code> instead of as a separate assignment statement.</p>
<p>This last change is an instance of a general rule—in any context where it is
permissible to use the value of a variable of some type, you can use a more
complicated expression of that type. Since the third argument of <code>printf</code> must
be a floating-point value to match the <code>%6.1f</code>, any floating-point expression
can occur there.</p>
<p>The <code>for</code> statement is a loop, a generalization of the <code>while</code>. If you compare
it to the earlier <code>while</code>, its operation should be clear. Within the
parentheses, there are three parts, separated by semicolons. The first part,
the initialization</p>
<pre><code class="language-c">fahr = 0
</code></pre>
<p>is done once, before the loop proper is entered. The second part is the test or
condition that controls the loop:</p>
<pre><code class="language-c">fahr &lt;= 300
</code></pre>
<p>This condition is evaluated; if it is true, the body of the loop (here a single
<code>printf</code>) is executed. Then the increment step</p>
<pre><code class="language-c">fahr = fahr + 20
</code></pre>
<p>is executed, and the condition re-evaluated. The loop terminates if the
condition has become false. As with the <code>while</code>, the body of the loop can be a
single statement, or a group of statements enclosed in braces. The
initialization, condition, and increment can be any expressions.</p>
<p>The choice between <code>while</code> and <code>for</code> is arbitrary, based on which seems
clearer. The <code>for</code> is usually appropriate for loops in which the initialization
and increment are single statements and logically related, since it is more
compact than <code>while</code> and it keeps the loop control statements together in one
place.</p>
<p><strong>Exercise 1-5.</strong> Modify the temperature conversion program to print the table
in reverse order, that is, from 300 degrees to 0.</p>
<h2>Symbolic Constants</h2>
<p>A final observation before we leave temperature conversion forever, It’s bad
practice to bury “magic numbers” like 300 and 20 in a program; they convey
little information to someone who might have to read the program later, and
they are hard to change in a systemic way. One way to deal with magic numbers
is to give them meaningful names. A <code>#define</code> line defines a <em>symbolic name</em> or
<em>symbolic constant</em> to be a particular string of characters:</p>
<pre><code class="language-c">#define name replacmenet text
</code></pre>
<p>Thereafter, any occurrences of <em>name</em> (not in quotes and not part of another
name) will be replaced by the corresponding <em>replacement text</em>. The <em>name</em> has
the same form as a variable name: a sequence of letters and digits that begins
with a letter. The <em>replacement text</em> can be any sequence of characters; it is
not limited to numbers.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define   LOWER   0      /* lower limit of table */
#define   UPPER   300    /* upper limit */
#define   STEP    20     /* step size */

/* print Fahrenheit-Celsius table */
main()
{
    int fahr;

    for (fahr = LOWER; fahr &lt;= UPPER; fahr = fahr + STEP)
        printf(&quot;%3d %6.1f\n&quot;, fahr, (5.0/9.0)*(fahr-32));
}
</code></pre>
<p>The quantities <code>LOWER</code>, <code>UPPER</code> and <code>STEP</code> are symbolic constants, not
variables, so they do not appear in declarations. Symbolic constant names are
conventionally written in upper case so they can be readily distinguished from
lower case variable names. Notice that there is no semicolon at the end of a
<code>#define</code> line.</p>
<h2>Character Input and Output</h2>
<p>We are not going to consider a family of related programs for processing
character data. You will find that many programs are just expanded versions of
the prototypes that we discuss here.</p>
<p>The model of input and output supported by the standard library is very simple.
Text input or output regardless of where it originates or where it goes to, is
dealt with as streams of characters. A <em>text stream</em> is a sequence of
characters divided into lines; each line consists of zero of more characters
followed by a newline character. It is the responsibility of the library to
make each input or output stream conform to this model; the C programmer using
the library need not worry about how lines are represented outside the program.</p>
<p>The standard library provides several functions for reading or writing one
character at a time, of which <code>getchar</code> and <code>putchar</code> are the simplest. Each
time it is called, <code>getchar</code> reads the <em>next input character</em> from a text
stream and returns that as its value. That is, after</p>
<pre><code class="language-c">c = getchar()
</code></pre>
<p>the variable <code>c</code> contains the next character of input. The characters normally
come from the keyboard; input from files is discussed in [Chapter @sec:IO].</p>
<p>The function <code>putchar</code> prints a character each time it is called:</p>
<pre><code class="language-c">putchar(c)
</code></pre>
<p>prints the contents of the integer variable <code>c</code> as a character, usually on the
screen. Calls to <code>putchar</code> and <code>printf</code> may be interleaved; the output will
appear in the order in which the calls are made.</p>
<h3>File copying</h3>
<p>Given <code>getchat</code> and <code>putchar</code>, you can write a surprising amount of useful code
without knowing anything more about input and output. The simplest example is a
program that copies its input to its output one character at a time:</p>
<pre><code>read a character
while (character is not end-of-file indicator)
    output the character just read
    read a character
</code></pre>
<p>Converting this into C gives</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

/* copy input to output; 1st version */
main()
{
    int c;

    c = getchar();
    while (c != EOF) {
        putchar(c);
        c = getchar();
    }
}
</code></pre>
<p>The relational operator <code>!=</code> means “not equal to.”</p>
<p>What appears to be a character on the keyboard or screen is of course, like
everything else, stored internally just as a bit pattern. The type <code>char</code> is
specifically meant for storing such character data, but any integer type can be
used. We used <code>int</code> for a subtle but important reason.</p>
<p>The problem is distinguishing the end of the input from valid data. The
solution is that <code>getchar</code> returns a distinctive value when there is no more
input, a value that cannot be confused with any real character. This value is
called <code>EOF</code>, for “end of file.” We must declare <code>c</code> to be a type big enough to
hold any value that <code>getchar</code> returns. We can’t use <code>char</code> since <code>c</code> must be
big enough to hold <code>EOF</code> in addition to any possible <code>char</code>. Therefore we use
<code>int</code>.</p>
<p><code>EOF</code> is an integer defined in <code>&lt;stdio.h&gt;</code>, but the specific numeric value
doesn’t matter as long as it is not the same as any <code>char</code> value. By using the
symbolic constant, we are assured that nothing in the program depends on the
specific numeric value.</p>
<p>The program for copying would be written more concisely by experienced C
programmers. In c, any assignment, such as</p>
<pre><code class="language-c">c = getchar()
</code></pre>
<p>is an expression and has a value, which is the value of the left hand side
after the assignment, This means that an assignment can appear as part of a
larger expression. If the assignment of a character to <code>c</code> is put inside the
test part of a <code>while</code> loop, the copy program can be written this way:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

/* copy input to output; 2nd version */
main()
{
    int c;

    while ((c = getchar()) != EOF)
        putchar(c);
}
</code></pre>
<p>The <code>while</code> gets a character, assigns it to <code>c</code>, and then tests whether the
character was the end-of-file signal. If it was not, the body of the <code>while</code> is
executed, printing the character. The <code>while</code> then repeats. When the end of the
input is finally reached, the <code>while</code> terminates and so does <code>main</code>.</p>
<p>This version centralizes the input—there is now only one reference to
<code>getchar</code>—and shrinks the program. The resulting program is more compact,
and, once the idiom is mastered, easier to read. You’ll see this style often.
(It’s possible to get carried away and create impenetrable code, however, a
tendency that we will try to curb.)</p>
<p>The parenthesis around the assignment within the condition are necessary. The
<em>precedence</em> of <code>!=</code> is higher than that of <code>=</code>, which means that in the
absence of parentheses the relational test <code>!=</code> would be done before the
assignment <code>-</code>. So the statement</p>
<pre><code class="language-c">c = getchar() != EOF
</code></pre>
<p>is equivalent to</p>
<pre><code class="language-c">c = (getchar() != EOF)
</code></pre>
<p>This has the undesired effect of setting <code>c</code> to 0 or 1, depending on whether or
not the call of <code>getchar</code> encountered end of file. (More on this in [Chapter
@sec:types-ops-expressions}.)</p>
<p><strong>Exercise 1-6.</strong> Verify that the expression <code>getchar() != EOF</code> is 0 or 1.</p>
<p><strong>Exercise 1-7.</strong> Write a program to print the value of <code>EOF</code>.</p>
<h3>Character Counting</h3>
<p>The next program counts characters; it is similar to the copy program.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

/* count characters in input; 1st version */
main()
{
    long nc;

    nc = 0;
    while (getchar() != EOF)
        +nc;
    printf(&quot;%ld\n&quot;, nc);
}
</code></pre>
<p>The statement</p>
<pre><code class="language-c">++nc;
</code></pre>
<p>presents a new operator, <code>++</code>, which means <em>increment by one</em>. You could
instead write <code>nc = nc+1</code> but <code>++nc</code> is more concise and often more efficient.
There is a corresponding operator <code>--</code> to decrement by 1. The operators <code>++</code>
and <code>--</code> can be either prefix operators (<code>++nc</code>) or postfix (<code>nc++</code>); these two
forms have different values in expressions, as will be shown in [Chapter
@sec:types-ops-expressions], but <code>++nc</code> and <code>nc++</code> both increment <code>nc</code>. For the
moment we will stick to the prefix form.</p>
<p>The character counting program accumulates its count in a <code>long</code> variable
instead of an <code>int</code>. <code>long</code> integers are at least 32 bits. Although on some
machines, <code>int</code> and <code>long</code> are the same size, on others an <code>int</code> is 16 bits,
with a maximum value of 32767, and it would take relatively little input to
overflow an <code>int</code> counter. The conversion specification <code>%ld</code> tells <code>printf</code>
that the corresponding argument is a <code>long</code> integer.</p>
<p>It may be possible to cope with even bigger numbers by using a <code>double</code> (double
precision <code>float</code>). We will also use a <code>for</code> statement instead of a <code>while</code>, to
illustrate another way to write the loop.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

/* count characters in input; 2nd version */
main ()
{
    double nc;

    for (nc = 0; getchar() != EOF; ++nc)
        ;
    printf(&quot;%.0f\n&quot;, nc);
}
</code></pre>
<p><code>printf</code> uses <code>%f</code> for both <code>float</code> and <code>double</code>; <code>%.0f</code> suppresses printing of
the decimal point and the fraction part, which is zero.</p>
<p>The body of this <code>for</code> loop is empty, because all of the work is done in the
test and increment parts. But the grammatical rules of C require that a <code>for</code>
statement have a body. The isolated semicolon, called a <em>null statement</em>, is
there to satisfy that requirement. We put it on a separate line to make it
visible.</p>
<p>Before we leave the character counting program, observer that if the input
contains no characters, the <code>while</code> or <code>for</code> test fails on the very first call
to <code>getchar</code>, and the program produces zero, the right answer. This is
important. One of the nice things about <code>while</code> and <code>for</code> is that they test at
the top of the loop, before proceeding with the body. If there is nothing to d,
nothing is done, even if that means never going through the loop body. Programs
should act intelligently when given zero-length input. The <code>while</code> and <code>for</code>
statements help ensure that programs do reasonable things with boundary
conditions.</p>
<h3>Line Counting</h3>
<p>The next program counts input lines. As we mentioned above, the standard
library ensures that an input text stream appears as a sequence of lines, each
terminated by a newline. Hence, counting lines is just counting newlines:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

/* count lines in input */
main()
{
    int c, nl;

    nl = 0;
    while ((c = getchar()) != EOF)
        if (c == '\n')
            ++nl;
    printf(&quot;%d\n&quot;, nl);
}
</code></pre>
<p>The body of the <code>while</code> now consists of an <code>if</code>, which in turn controls the
increment <code>++nl</code>. The <code>if</code> statement tests the parenthesized condition, and if
the condition is true, executes the statement (or group of statements in
braces) that follows. We have again indented to show what is controlled by
what.</p>
<p>The double equals sign <code>==</code> is the C notation for “is equal to” (like Pascal’s
single <code>=</code> or Fortran’s <code>.EQ.</code>). This symbol is used to distinguish the
equality test from the single <code>=</code> that C uses for assignment. A word of
caution: newcomers to C occasionally write <code>=</code> when they mean <code>==</code>. As we will
see in [Chapter @sec:types-ops-expressions], the result is usually a legal
expression, so you will get no warning.</p>
<p>A character written between single quotes represents an integer value equal to
the numerical value of the character in the machine’s character set. This is
called a <em>character constant</em>, although it is just another way to write a small
integer. So, for example <code>'A'</code> is a character constant; in the ASCII character
set its value is 65, the internal representation of a character <code>A</code>. Of course
<code>'A'</code> is to be preferred over 65: its meaning is obvious, and it is independent
of a particular character set.</p>
<p>The escape sequences used in string constants are also legal in character
constants, so <code>'\n'</code> stands for the value of the newline character, which is 10
in ASCII. You should note carefully that <code>'\n'</code> is a single character, and in
expressions is just an integer; on the other hand, <code>&quot;\n&quot;</code> is a string constant
that happens to contain only one character. The topic of strings versus
characters is discussed further in [Chapter @sec:types-ops-expressions].</p>
<p><strong>Exercise 1-8.</strong> Write a program to count blanks, tabs and newlines.</p>
<p><strong>Exercise 1-9.</strong> Write a program to copy its input to its output, replacing
each string of one or more blanks by a single blank.</p>
<p><strong>Exercise 1-10.</strong> Write a program to copy its input to its output, replacing
each tab by <code>\t</code>, each backspace by <code>\b</code>, and each backslash by <code>\\</code>. This
makes tabs and backspaces visible in an unambiguous way.</p>
<h3>Word Counting</h3>
<p>The fourth in our series of useful programs counts lines, words, and
characters, with the loose definition that a word is any sequence of characters
that does not contain a blank, tab or newline. This is a bare-bones version of
the UNIX program <code>wc</code>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define IN  1    /* inside a word */
#define OUT 0    /* outside a word */

/* count lines, words, and characters in input */
main()
{
    int c, nl, nw, nc, state;

    state = OUT;
    nl = nw = nc = 0;
    while ((c = getchar()) != EOF) {
        ++nc;
        if (c == '\n')
            ++nl;
        if (c == ' ' || c == '\n' || c == '\t')
            state = OUT;
        else if (state == OUT) {
            state = IN;
            ++nw;
        }
    }
    printf(&quot;%d %d %d\n&quot;, nl, nw, nc);
}
</code></pre>
<p>Every time the program encounters the first character of a word, it counts one
more word. The variable state records whether the program is currently in a
word or not; initially it is “not in a word,” which is assigned the value of
<code>OUT</code>. We prefer the symbolic constants <code>IN</code> and <code>OUT</code> to the literal values 1
and 0 because they make the program more readable. In a program as tiny as
this, it makes little difference, but in larger programs, the increase in
clarity is well worth the modest extra effect to write it in this way from the
beginning. You’ll also find that it’s easier to make extensive changes in
programs where magic numbers appear only as symbolic constants.</p>
<p>The line</p>
<pre><code class="language-c">nl = nw = nc = 0;
</code></pre>
<p>sets all three variables to zero. This is not a special case, but a consequence
of the fact than an assignment is an expression with a value and assignments
associate from right to left. It’s as if we had written</p>
<pre><code class="language-c">nl = (nw = (nc = 0));
</code></pre>
<p>The operator <code>||</code> means OR, so the line</p>
<pre><code class="language-c">if (c == ' ' || c == '\n' || c == '\t')
</code></pre>
<p>says “if <code>c</code> is a blank <em>or</em> <code>c</code> is a newline <em>or</em> <code>c</code> is a tab”. (Recall that
the escape sequence <code>\t</code> is a visible representation of the tab character.)
There is a corresponding operator <code>&amp;&amp;</code> for AND; its precedence is just higher
than <code>||</code>. Expressions connected by <code>&amp;&amp;</code> or <code>||</code> are evaluated left to right,
and it is guaranteed that evaluation will stop as soon as the truth or
falsehood is known. If <code>c</code> is a blank, there is no need to test whether it is a
newline or tab, so these tests are not made. This isn’t particularly important
here, but is significant in more complicated situations, as we will soon see.</p>
<p>The example also shows an <code>else</code>, which specifies an alternative action if the
condition part of an <code>if</code> statement is false. The general form is</p>
<pre><code class="language-c">if (expression)
    statement1
else
    statement2
</code></pre>
<p>One and only one of the two statements associated with an <code>if</code>-<code>else</code> is
performed. If the <em>expression</em> is true, <em>statement1</em> is executed; if not,
<em>statement2</em> is executed. Each <em>statement</em> can be a single statement or several
in braces. In the word count program, the one after the <code>else</code> is an <code>if</code> that
controls two statements in braces.</p>
<p><strong>Exercise 1-11.</strong> How would you test the word count program? What kinds of
input are most likely to uncover bugs if there are any?</p>
<p><strong>Exercise 1-12.</strong> Write a program that prints its input one word per line.</p>
<h2>Arrays</h2>
<p>Let us write a program to count the number of occurrences of each digit, of
white space characters (blank, tab, newline), and of all other characters. This
is artificial, but it permits us to illustrate several aspects of C in one
program.</p>
<p>There are twelve categories of input, so it is convenient to use an array to
hold the number of occurrences of each digit, rather than ten individual
variables. Here is one version of the program:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

/* count digits, white space, others */
main()
{
    int c, i, nwhite, nother;
    int ndigit[10];

    nwhite = nother = 0;
    for (i = 0; i &lt; 10; ++i)
        ndigit[i] = 0;

    while ((c = getchar()) != EOF)
        if (c &gt;= '0' &amp;&amp; c &lt;= '9')
            ++ndigit[c-'0'];
        else if (c == ' ' || c == '\n' || c == '\t')
            ++nwhite;
        else
            ++nother;

    printf(&quot;digits = &quot;);
    for (i = 0; i &lt; 10; ++i)
        printf(&quot; %d&quot;, ndigit[i]);
    printf(&quot;, white space = %d, other = %d\n&quot;,
        nwhite, nother);
}
</code></pre>
<p>The output of the program on itself is</p>
<pre><code>digits =  9 3 0 0 0 0 0 0 0 1, white space = 123, other = 345
</code></pre>
<p>The declaration</p>
<pre><code class="language-c">int ndigit[10];
</code></pre>
<p>declares <code>ndigit</code> to be an array of 10 integers. Array subscripts always start
at zero in C, so the elements are <code>ndigit[0]</code>, <code>ndigit[1]</code>, …, <code>ndigit[9]</code>.
This is reflected in the <code>for</code> loops that initialize and print the array.</p>
<p>A subscript can be any integer expression, which includes integer variables
like <code>i</code> and integer constants.</p>
<p>This particular program relies on the properties of the character
representation of the digits. For example, the test</p>
<pre><code class="language-c">if (c &gt;= '0' &amp;&amp; c &lt;= '9') ...
</code></pre>
<p>determines whether the character in <code>c</code> is a digit. If it is, the numeric value
of that digit is</p>
<pre><code class="language-c">c - '0'
</code></pre>
<p>This works only if <code>'0'</code>, <code>'1'</code>, …, <code>'9'</code> have consecutive increasing values.
Fortunately, this is true for all character sets.</p>
<p>By definition, <code>chars</code> are just small integers, so <code>char</code> variables and
constants are identical to <code>ints</code> in arithmetic expressions. This is natural
and convenient; for example, <code>c-'0'</code> is an integer expression with a value
between 0 and 9 corresponding to the character <code>'0'</code> to <code>'9'</code> stored in <code>c</code>,
and is thus a valid subscript for the array <code>ndigit</code>.</p>
<p>The decision as to whether a character is a digit, white space, or something
else is made with the sequence</p>
<pre><code class="language-c">if (c &gt;= '0' &amp;&amp; c &lt;= '9')
    ++ndigit[c-'0'];
else if (c == ' ' || c == '\n' || c == '\t')
    ++nwhite;
else
    ++nother;
</code></pre>
<p>The pattern</p>
<pre><code class="language-c">if (condition1)
    statement1
else if (condition2)
    statement2
...
    ...
else
    statement
</code></pre>
<p>occurs frequency in programs as a way to express a multi-way decision. The
<em>conditions</em> are evaluated in order from the top until some <em>condition</em> is
satisfied; at that point the corresponding <em>statement</em> part is executed, and
the entire construction is finished. (Any <em>statement</em> can be several statements
enclosed in braces.) If none of the conditions is satisfied, the <em>statement</em>
after the final <code>else</code> is executed if it is present. If the final <code>else</code> and
<code>stataement</code> are omitted, as in the word count program, no action takes place.
There can be any number of</p>
<pre><code class="language-c">else if (condition)
    statement
</code></pre>
<p>groups between the initial <code>if</code> and the final <code>else</code>.</p>
<p>As a matter of style, it is advisable to format this construction as we have
shown; if each <code>if</code> were indented past the previous <code>else</code>, a long sequence of
decisions would march off the right side of the page.</p>
<p>The <code>switch</code> statement, to be discussed in [Chapter @sec:control-flow],
provides another way to write a multi-way branch that is particularly suitable
when the condition is whether some integer or character expression matches one
of a set of constants.  For contrast, we will present a <code>switch</code> version of
this program in [Section @sec:switch],</p>
<p><strong>Exercise 1-13.</strong> Write a program to print a histogram of the lengths of words
in its input. It is easy to draw the histogram with the bars horizontal; a
vertical orientation is more challenging.</p>
<p><strong>Exercise 1-14.</strong> Write a program to print a histogram of the frequencies of
different characters in its input.</p>
<h2>Functions</h2>
<p>In C, a function is equivalent to a subroutine or function in Fortran, or a
procedure or function in Pascal. A function provides a convenient way to
encapsulate some computation, which can then be used without worrying about its
implementation. With properly designed functions, it is possible to ignore
<em>how</em> a job is done; knowing <em>what</em> is done is sufficient. C makes the use of
functions easy, convenient and efficient; you will often see a short function
defined and called only once, just because it clarifies some piece of code.</p>
<p>So far we have used only functions like <code>printf</code>, <code>getchar</code>, and <code>putchar</code> that
have been provided for us; now it’s time to write a few of our own. Since C has
no exponentiation operator like the <code>**</code> of Fortran, let us illustrate the
mechanics of function definition by writing a function <code>power(m,n)</code> to raise an
integer <code>m</code> to a position integer power <code>n</code>. That is, the value of <code>power(2,5)</code>
is 32. This function is not a practical exponentiation routine, since it
handles only positive powers of small integers, but it’s good enough for
illustration. (The standard library contains a function <code>pow(x,y)</code> that
computes $x^y$.)</p>
<p>Here is the function <code>power</code> and a <code>main</code> program to exercise it, so you can
see the whole structure at once.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int power(int m, int n);

/* test power function */
main()
{
    int i;

    for (i = 0; i &lt; 10; ++i)
        printf(&quot;%d %d %d\n&quot;, i, power(2,i), power(-3,i));
    return 0;
}

/* power: raise base to n-th power; n &gt;= 0 */
int power(int base, int n)
{
    int i, p;

    p = 1;
    for (i = 1; i &lt;= n; ++i)
        p = p* base;
    return p;
}
</code></pre>
<p>A function definition has this form:</p>
<pre><code>return-type function-name(parameter declarations, if any)
{
    declarations
    statements
}
</code></pre>
<p>Function definitions can appear in any order, and in once source file or
several, although no functions can be split between files. If the source
program appears in several files, you may have to say more to compile and load
it than if it all appears in one, but that is an operating system matter, not a
language attribute. For the moment, we will assume that both functions are in
the same file, so whatever you have learned about running C programs will still
work.</p>
<p>The function <code>power</code> is called twice by <code>main</code>, in the line</p>
<pre><code class="language-c">printf(&quot;%d %d %d\n&quot;, i, power(2,i), power(-3,i));
</code></pre>
<p>Each calls passes two arguments to <code>power</code>, which each time returns an integer
to be formatted and printed. In an expression, <code>power(2,i)</code> is an integer jut
as 2 and <code>i</code> are. (Not all functions produce an integer value; we will take
this up in [Chapter @sec:functions].)</p>
<p>The first line of <code>power</code> itself,</p>
<pre><code class="language-c">int power(int base, int n)
</code></pre>
<p>declares the parameter types and names, and the type of the result that the
function returns. The names used by <code>power</code> for its parameters are local to
<code>power</code>, and are not visible to any other function: other routines can use the
same names without conflict. This is also true of the variables <code>i</code> and <code>p</code>:
the <code>i</code> in <code>power</code> is unrelated to the <code>i</code> in <code>main</code>.</p>
<p>We will generally use <em>parameter</em> for a variable named in the parenthesized
list in a function definition, and <em>argument</em> for the value used in a call of
the function. The terms <em>formal argument</em> and <em>actual argument</em> are sometimes
used for the same distinction.</p>
<p>The value that <code>power</code> computes is returned to <code>main</code> by the <code>return</code>
statement. Any expression may follow <code>return</code>:</p>
<pre><code class="language-c">return expression;
</code></pre>
<p>A function need not return a value; a <code>return</code> statement with no expression
causes control, but no useful value, to be returned to the caller, as does
“falling off the end” of a function by reaching the terminating right brace.
And the calling function can ignore a value return by a function.</p>
<p>You may have noticed that there is a <code>return</code> statement at the end of <code>main</code>.
Since <code>main</code> is a function like any other, it may return a value to its caller,
which is in effect the environment in which the program was executed.
Typically, a return value of zero implies normal termination; non-zero values
signal unusual or erroneous termination conditions. In the interests of
simplicity, we have omitted <code>return</code> statements from out <code>main</code> functions up to
this point, but we will include them hereafter, as a reminder that programs
should return status to their environment.</p>
<p>The declaration</p>
<pre><code class="language-c">int power(int m, int n);
</code></pre>
<p>just before <code>main</code> says that <code>power</code> is a function that expects two <code>int</code>
arguments and returns an <code>int</code>. This declaration, which is called a <em>function
prototype</em>, has to agree with the definition and use of <code>power</code>. It is an error
if the definition of a function or any use of it do not agree with its
prototype.</p>
<p>Parameter names need not agree. Indeed, parameters names are optional in a
function prototype, so for the prototype we could have written</p>
<pre><code class="language-c">int power(int, int);
</code></pre>
<p>Well-chosen names are good documentation, however, so we will often use them.</p>
<p>A note of history: The biggest change between ANSI C and earlier versions is
how functions are declared and defined. In the original definition of C, the
<code>power</code> function would have been written like this:</p>
<pre><code class="language-c">/* power:   raise base to n-th power; n &gt;= 0 */
/*          (old-style version) */
power(base, n)
int base, n;
{
    int i, p;

    p = 1;
    for (i = 1; i &lt;= n; ++i)
        p = p * base;
    return p;
}
</code></pre>
<p>The parameters are named between the parentheses, and their types are declared
before the opening left brace; undeclared parameters are taken as <code>int</code>. (The
body of the function is the same as before.)</p>
<p>The declaration of <code>power</code> at the beginning of the program would have looked
like this:</p>
<pre><code class="language-c">int power();
</code></pre>
<p>No parameter list was permitted, so the compiler could not readily check that
<code>power</code> was being called correctly. Indeed, since by default <code>power</code> would have
been assumed to return an <code>int</code>, the entire declaration might well have been
omitted.</p>
<p>The new syntax of function prototypes makes it much easier for a compiler to
detect errors in a number of arguments or their types. The old style of
declaration and definition still works in ANSI C, at least for a transition
period, but we strongly recommend that you use the new form when you have a
compiler that supports it.</p>
<p><strong>Exercise 1-15.</strong> Rewrite the temperature conversion program of [Section
@sec:vars-arith-expressions] to use a function for conversion.</p>
<h2>Arguments—Call by Value</h2>
<p>One aspect of C functions may be unfamiliar to programmers who are used to some
other languages, particularly Fortran. In C, all function arguments are passed
“by value.” This means that the called function is given the values of its
arguments in temporary variables rather than the originals. This leads to some
different properties than are seen with “call by reference” languages like
Fortran or with <code>var</code> parameters in Pascal, in which the called routine has
access to the original argument, not a local copy.</p>
<p>The main distinction is that in C the called function cannot directly alter a
variable in the calling function; it can only alter its private, temporary
copy.</p>
<p>Call by value is an asset, however, not a liability. It usually leads to more
compact programs with fewer extraneous variables, because parameters can be
treated as conveniently initialized local variables in the called routine. For
example, here is a version of <code>power</code> that makes use of this property.</p>
<pre><code class="language-c">/* power: raise base to n-th power; n&gt;=0; version 2 */
int power(int base, int n)
{
    int p;

    for (p = 1; n &gt; 0; --n)
        p = p * base;
    return p;
}
</code></pre>
<p>The parameter <code>n</code> is used as a temporary variable, and is counted down (a <code>for</code>
loop that runs backwards) until it becomes zero; there is no longer a need for
the variable <code>i</code>. Whatever is done to <code>n</code> inside <code>power</code> has no effect on the
argument that <code>power</code> was originally called with.</p>
<p>When necessary, it is possible to arrange for functions to modify a variable in
a calling routine. The caller must provide the <em>address</em> of the variable to be
set (technically a <em>pointer</em> to the variable), and the called function must
declare the parameter to be a pointer and access the variable indirectly
through it. We will cover pointers in [Chapter @sec:pointers].</p>
<p>The story is different for array. When the name of an array is used as an
argument, the value passed to the function is the location or address of the
beginning of the array—there is no copying of array elements. By subscripting
this value, the function can access and alter any element of the array. This is
the topic of the next section.</p>
<h2>Character Arrays {#sec:char-arr}</h2>
<p>The most common type of array in C is the array of characters. To illustrate
the use of character arrays and functions to manipulate them, let’s write a
program that reads a set of text lines and prints the longest. The outline is
simple enough:</p>
<pre><code>while (there's another line)
    if (it's longer than the previous longest)
        save it
        save its length
print longest line
</code></pre>
<p>This outline makes it clear that the program divides naturally into pieces. One
piece gets a new line, another tests it, another saves it, and the rest
controls the process.</p>
<p>Since things divide so nicely, it would be well to write them that way too.
Accordingly, let us first write a separate function <code>getline</code> to fetch the next
line of input. We will try to make the function useful on other contexts. At
the minimum, <code>getline</code> has to return a signal about possible end of file; a
more useful design would be to return the length of the line, or zero if the
end of file is encountered. Zero is an acceptable end-of-file return because it
is never a valid line length. Every text line has at least one character; even
a line containing only a newline has length 1.</p>
<p>When we find a line that is longer than the previous longest line, it must be
saved somewhere. This suggests a second function, <code>copy</code>, to copy the new line
to a safe place.</p>
<p>Finally, we need a main program to control <code>getline</code> and <code>copy</code>. Here is the
result.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#define MAXLINE 1000    /* maximum input line size */

int getline(char line[], int maxline);
void copy(char to[], char from[]);

/* print longest input line */
main()
{
    int len;            /* current line length */
    int max;            /* maximum length seen so far */
    char line[MAXLINE];     /* current input line */
    char longest[MAXLINE];  /* longest line saved here */

    max = 0;
    while ((len = getline(line, MAXLINE)) &gt; 0)
        if (len &gt; max) {
            max = len;
            copy(longest, line);
        }
    if (max &gt; 0)    /* there was a line */
        printf(&quot;%s&quot;, longest);
    return 0;
}

/* getline:  read a line into s, return length */
int getline(char s[], int lim)
{
    int c, i;

    for (i=0; i&lt;lim-1 &amp;&amp; (c=getchar())!=EOF &amp;&amp; c!='\n'; ++i)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}

/* copy:  copy 'from' into 'to'; assume to is big enough */
void copy(char to[], char from[])
{
    int i;

    i = 0;
    while ((to[i] = from[i]) != '\0')
        ++i;
}
</code></pre>
<p>The functions <code>getline</code> and <code>copy</code> are declared at the beginning of the
program, which we assume is contained in one file.</p>
<p><code>main</code> and <code>getline</code> communicate through a pair of arguments and a returned
value. In <code>getline</code>, the arguments are declared by the line</p>
<pre><code class="language-c">int getline(char s[], int lim)
</code></pre>
<p>which specifies that the first argument, <code>s</code>, is an array, and the second,
<code>lim</code> is an integer. The purpose of supplying the size of an array in a
declaration is to set aside storage. The length of the array <code>s</code> is not
necessary in <code>getline</code> since its size is set in <code>main</code>. <code>getline</code> uses <code>return</code>
to send a value back to the caller, just as the function <code>power</code> did. This line
also declares that <code>getline</code> returns an <code>int</code>; since <code>int</code> is the default
return type, it could be omitted.</p>
<p>Some functions return a useful value; others, like <code>copy</code>, are used only for
their effect and return no value. The return type of <code>copy</code> is <code>void</code>, which
states explicitly that no value is returned.</p>
<p><code>getline</code> puts the character<code>'\0'</code> (the <em>null character</em>, whose value is zero)
at the end of the array it is creating, to mark the end of the string of
characters. This convention is also used by the C language: when a string
constant like</p>
<pre><code class="language-c">&quot;hello\n&quot;
</code></pre>
<p>appears in a program, it is stored as an array of characters containing the
characters of the string and terminated with a <code>'\0'</code> to mark the end.</p>
<pre><code class="language-c">{ 'h', 'e', 'l', 'l', 'o', '\n', '\0' }
</code></pre>
<p>The <code>%s</code> format specification in <code>printf</code> expects the corresponding argument to
be a string represented in this form. <code>copy</code> also relies on the fact that its
input argument is terminated by <code>'\0'</code>, and it copies this character into the
output argument. (All of this implies that <code>'\0'</code> is not a part of normal
text.)</p>
<p>It is worth mentioning in passing that even a program as small as this one
presents some sticky design problems. For example, what should <code>main</code> do if it
encounters a line which is bigger than its limit? <code>getline</code> works safely, in
that it stops collecting when the array is full, even if no newline has been
seen. By testing the length and the last character returned, <code>main</code> can
determine whether the line was too long and then cope as it wishes. In the
interests of brevity, we have ignored the issue.</p>
<p>There is no way for a user of <code>getline</code> to know in advance how long an input
line might be, so <code>getline</code> checks for overflow. On the other hand, the user of
<code>copy</code> already knows (or can find out) how big the strings are, so we have
chosen not to add error checking to it.</p>
<p><strong>Exercise 1-16.</strong> Revise the main routine of the longest-line program so it
will correctly print the length of arbitrary long input lines, and as much as
possible of the text.</p>
<p><strong>Exercise 1-17.</strong> Write a program to print all input lines that are longer
than 80 characters.</p>
<p><strong>Exercise 1-18.</strong> Write a program to remove trailing blanks and tabs from each
line of input, and to delete entirely blank lines.</p>
<p><strong>Exercise 1-19.</strong> Write a function <code>reverser(s)</code> that reverses the character
string <code>s</code>. Use it to write a program that reverses its input a line at a time.</p>
<h2>External Variables and Scope</h2>
<p>The variables in <code>main</code>, such as <code>line</code>, <code>longest</code>, etc., are private or local
to <code>main</code>. Because they are declared within <code>main</code>, no other function can have
direct access to them. The same is true of the variables in other functions;
for example, the variable <code>i</code> in <code>getline</code> is unrelated to the <code>i</code> in <code>copy</code>.
Each local variable in a function comes into existence only when the function
is called, and disappears when the function is exited. This is why such
variables are usually known as <em>automatic</em> variables, following terminology in
other languages. We will use the term automatic henceforth to refer to these
local variables. ([Chapter @sec:functions] discusses the <code>static</code> storage
class, in which local variables do retain their values between calls.)</p>
<p>Because automatic variables come and go with function invocation, they do not
retain their values from one call to the next, and must be explicitly set upon
each entry. If they are not set, they will contain garbage.</p>
<p>As an alternative to automatic variables, it is possible to define variables
that are <em>external</em> to all functions, that is, variables that can be accessed
by name by any function. (This mechanism is rather like Fortran COMMON or
Pascal variables declared in the outermost block.) Because external variables
are globally accessible, they can be used instead of arguments lists to
communicate data between functions. Furthermore, because external variables
remain in existence permanently, rather than appearing and disappearing as
functions are called and exited, they retain their values even after the
functions that set them have returned.</p>
<p>An external variables must be <em>defined</em>, exactly once, outside of any function;
this sets aside storage for it. The variable must also be <em>declared</em> in each
function that wants to access it; this states the type of the variable. The
declaration may be an explicit <code>extern</code> statement or may be implicit from
context. To make the discussion concrete, let us rewrite the longest-line
program with <code>line</code>, <code>longest</code>, and <code>max</code> as external variables. This requires
changing the calls, declarations, and bodies of all three functions.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define MAXLINE 1000    /* maximum input line size */

int max;                /* maximum length seen so far */
char line[MAXLINE];     /* current input line */
chat longest[MAXLINE];  /* longest line saved here */

int getline (void);
void copy(void);



/* print longest input line; specialized version */
main()
{
    int len;
    extern int max;
    extern char longest[];

    max = 0;
    while ((len = getline()) &gt; 0)
        if (len &gt; max) {
            max = len;
            copy();
        }
    if (max &gt; 0)    /* there was a line */
        printf(&quot;%s&quot;, longest);
    return 0;
}



/* getline:  specialized version */
int getline(void)
{
    int c, i;
    extern char line[];

    for (i = 0; i &lt; MAXLINE-1
        &amp;&amp; (c=getchar()) != EOF &amp;&amp; c != '\n'; ++i)
            line [i] = c;
    if (c == '\n') {
        line[i] = c;
        ++i;
    }
    line[i] = '\0';
    return i;
}



/* copy:  specialized version */
void copy(void)
{
    int i;
    extern char line[], longest[];

    i = 0;
    while ((longest[i] = line[i]) != '\0')
        ++i;
}
</code></pre>
<p>The external variables in <code>main</code>, <code>getline</code>, and <code>copy</code> are defined by the
first lines of the example above, which state their type and cause storage to
be allocated for them. Syntactically, external definitions are just like
definitions of local variables, but since they occur outside of functions, the
variables are external. Before a function can use an external variable, the
name of the variable must be made known to be the function. One way to do this
is to write an <code>extern</code> declaration in the function; the declaration is the
same as before except for the added keyword <code>extern</code>.</p>
<p>In certain circumstances, the <code>extern</code> declaration can be omitted. If the
definition of an external variables occurs in the source file before its use in
a particular function, then there is no need for an <code>extern</code> declaration in the
function. The <code>extern</code> declarations in <code>main</code>, <code>getlin</code> and <code>copy</code> are thus
redundant. In fact, common practice is to place definitions of all external
variables at the beginning of the source file, and the omit all <code>extern</code>
declarations.</p>
<p>If the program is in several source files, and a variable is defined in <em>file1</em>
and used in <em>file2</em> and <em>file3</em>, then <code>extern</code> declarations are needed in
<em>file2</em> and <em>file3</em> to connect the occurrences of the variable. The usual
practice is to collect <code>extern</code> declarations of variables and functions in a
separate file, historically called a <em>header</em>, that is included by <code>#include</code>
at the front of each source file. The suffix <code>.h</code> is conventional for header
names. The functions of the standard library, for example, are declared in
headers like <code>&lt;stdio.h&gt;</code>. This topic is discussed at length in [Chapter
@sec:functions], and the library itself in [Chapter @sec:IO] and [Appendix
@sec:std-lib].</p>
<p>Since the specialized versions of <code>getline</code> and <code>copy</code> have no arguments, logic
would suggest that their prototypes at the beginning of the file should be
<code>getline()</code> and <code>copy()</code>. But for compatibility with older C programs the
standard takes an empty list as an old-style declaration, and turns off all
argument list checking; the word <code>void</code> must be used for an explicitly empty
list. We will discuss this further in [Chapter @sec:functions].</p>
<p>You should note that we are using the words <em>definition</em> and <em>declaration</em>
carefully when we refer to external variables in this section. “Definition”
refers to the place where the variable is created or assigned storage;
“declaration” refers to places where the nature of the variable is stated but
no storage is allocated.</p>
<p>By the way, there is a tendency to make everything in sight an <code>extern</code>
variable because it appears to simplify communications—argument lists are
short and variables are always there when you want them. But external variables
are always there even when you don’t want them. Relying too heavily on external
variables is fraught with peril since it leads to programs whose data
connections are not at all obvious—variables can be changed in unexpected and
even inadvertent ways, and the program is hard to modify. The second version of
the longest-line program is inferior to the first, partly for these reasons,
and partly because it destroys the generality of two useful functions by wiring
into them the names of variables they manipulate.</p>
<p>At this point we have covered what might be called conventional core of C. With
this handful of building blocks, it’s possible to write useful programs of
considerable size, and it would probably be a good idea if you paused long
enough to do so. These exercises suggest programs of somewhat greater
complexity than the ones earlier in this chapter.</p>
<p><strong>Exercise 1-20.</strong> Write a program <code>detab</code> that replaces tabs in the input with
the proper number of blanks to space to the next tab stop. Assume a fixed set
of tab stops, say every <em>n</em> columns, Should <em>n</em> be a variable or a symbolic
parameter?</p>
<p><strong>Exercise 1-21.</strong> Write a program <code>entab</code> that replaces strings of blanks by
the minimum number of tabs and blanks to achieve the same spacing. Use the same
tab stops as for <code>detab</code>. When either a tab or a single blank would suffice to
reach a tab stop, which should be given preference?</p>
<p><strong>Exercise 1-22.</strong> Write a program to “fold” long input lines into two or more
sorter lines after the last non-blank character that occurs before the <em>n</em>-th
column of input. Make sure your program does something intelligent with very
long lines, and if there are no blanks or tabs before the specified column.</p>
<p><strong>Exercise 1-23.</strong> Write a program to remove all comments from a C program.
Don’t forget to handle quoted strings and character constants properly. C
comments do not nest.</p>
<p><strong>Exercise 1-24.</strong> Write a program to check a C program for rudimentary syntax
errors like unbalanced parentheses, brackets and braces. Don’t forget about
quotes, both single and double, escape sequences, and comments. (This program
is hard if you do it in full generality.)</p>
<h1>Types, Operators, and Expressions {#sec:types-ops-expressions}</h1>
<p>Variables and constants are the basic data objects manipulated in a program.
Declarations list the variables to be used, and state what type they have and
perhaps what their initial values are. Operators specify what is to be done to
them. Expressions combine variables and constants to produce new values. The
type of an object determines the st of values it can have and what operations
can be performed on it. These building blocks are the topics of this chapter.</p>
<p>The ANSI standard has made many small changes and additions to basic types and
expressions. There are now <code>signed</code> and <code>unsigned</code> forms of all integer types,
and notations for unsigned constants and hexadecimal character constants.
Floating-point operations may be done in single precision; there is also a
<code>long double</code> type for extended precision. String constants may be concatenated
at compile time. Enumerations have become part of the language, formalizing a
feature of long standing. Objects may be declared <code>const</code>, which prevents them
from being changed. The rules for automatic coercions among arithmetic types
have been augmented to handle the richer set of types.</p>
<h2>Variables Names</h2>
<p>Although we didn’t say so in [Chapter @sec:introduction], there are some
restrictions on the names of variables and symbolic constants. Names are made
up of letters and digits; the first character must be a letter. The underscore
“_” counts as a letter; it is sometimes useful for improving the readability of
long variable names. Don’t begin variable names with underscore, however, since
library routines often use such name. Upper case and lower case letter are
distinct, so <code>x</code> and <code>X</code> are two different names. Traditional C practice is to
use lower case for variable names, and all upper case for symbolic constants.</p>
<p>At least the first 31 characters of an internal name are significant. For
function names and external variables, the number may be less than 31, because
external names may be used by assemblers and loaders over which the language
has no control. For external names, the standard guarantees uniqueness only for
6 characters and a single case. Keyword like <code>if</code>, <code>else</code>, <code>int</code>, <code>float</code>,
etc., are reserved: you can’t use them as variable names. They must be in lower
case.</p>
<p>It’s wise to choose variable names that are related to the purpose of the
variable, and that are unlikely to get mixed up typographically. We tend to use
short names for local variables, especially loop indices, and longer names for
external variables.</p>
<h2>Data Types and Sizes</h2>
<p>There are only a few basic data types in C:</p>
<pre><code>char    a single byte, capable of holding one character
        in the local character set.
int     an integer, typically reflecting the natural size
        of integers on the host machine.
float   single-precision floating point.
double  double-precision floating point.
</code></pre>
<p>In addition, there are a number of qualifiers that can be applied to these
basic types. <code>short</code> and <code>long</code> apply to integers:</p>
<pre><code class="language-c">short int sh;
long int counter;
</code></pre>
<p>The word <code>int</code> can be omitted in such declarations, and typically is.</p>
<p>The intent is that <code>short</code> and <code>long</code> should provide different lengths of
integers where practical; <code>int</code> will normally be the natural size for a
particular machine. <code>short</code> is often 16 bits, <code>long</code> 32 bits, and <code>int</code> either
16 or 32 bits. Each compiler is free to choose appropriate sizes for its own
hardware, subject only to the restriction that <code>short</code>s and <code>int</code>s are at least
16 bits, <code>long</code>s are at least 32 bit, and <code>short</code> is no longer than <code>int</code>,
which is no longer than <code>long</code>.</p>
<p>The qualifier <code>signed</code> or <code>unsigned</code> may be applied to <code>char</code> or any integer.
<code>unsigned</code> numbers are always positive or zero, and obey the laws of arithmetic
module $2^n$, where <em>n</em> is the number of bits in the type. So, for instance, if
<code>char</code>s are 8 bits, <code>unsigned char</code> variables have values between 0 and 255,
while <code>signed chars</code> have values between -128 and 127 (in a two’s complement
machine). Whether plain <code>chars</code> are <code>signed</code> or <code>unsigned</code> is
machine-dependent, but printable characters are always positive.</p>
<p>The type <code>long double</code> specified extended-precision floating point. As with
integers, the sizes of floating-point objects are implementation-defined;
<code>float</code>, <code>double</code> and <code>long double</code> could represent one, two or three distinct
sizes.</p>
<p>The standard headers <code>&lt;limits.h&gt;</code> and <code>&lt;float.h&gt;</code> contain symbolic constants
for all of these sizes, along with other properties of the machine and
compiler. These are discussed in [Appendix @sec:std-lib].</p>
<p><strong>Exercise 2-1.</strong> Write a program to determine the range of <code>char</code>, <code>short</code>,
<code>int</code>, and <code>long</code> variables, both <code>signed</code> and <code>unsigned</code>, by printing
appropriate values from standard headers and by direct computation. Harder if
you compute them: determine the ranges of the various floating-point types.</p>
<h2>Constants {#sec:constants}</h2>
<p>An integer constant like <code>1234</code> is an <code>int</code>. A <code>long</code> constant is written with
a terminal <code>l</code> (ell) or <code>L</code>, as in <code>123456789L</code>; an integer too big to fit into
an <code>int</code> will also be taken as a long. Unsigned constants are written with a
terminal <code>u</code> or <code>U</code>, and the suffix <code>ul</code> or <code>UL</code> indicates <code>unsigned long</code>.</p>
<p>Floating-point constants contain a decimal point (<code>123.4</code>) or an exponent
(<code>1e-2</code>) or both; their type is <code>double</code>, unless suffixed. The suffixes <code>f</code> or
<code>F</code> indicate a <code>float</code> constant; <code>l</code> or <code>L</code> indicate a <code>long double</code>.</p>
<p>The value of an integer can be specified in octal or hexadecimal instead of
decimal. A leading <code>0</code> (zero) on an integer constant means octal; a leading
<code>0x</code> or <code>0X</code> means hexadecimal. For example, decimal <code>31</code> can bet written as
<code>037</code> in octal and <code>0x1f</code> or <code>0X1F</code> in hex. Octal and hexadecimal constants may
also be followed by <code>L</code> to make them <code>long</code> and <code>U</code> to make them <code>unsigned</code>:
<code>0XFUL</code> is an <code>unsigned long</code> constant with value <code>15</code> decimal.</p>
<p>A <em>character constant</em> is an integer, written as one character within single
quotes, such as <code>'x'</code>. The value of a character constant is the numeric value
of the character in the machine’s character set. For example, in the ASCII
character set the character constant <code>'0'</code> has the value 48, which is unrelated
to the numeric value 0. If we write <code>'0'</code> instead of a numeric value like 48
that depends on character set, the program is independent of the particular
value and easier to read. Character constants participate in numeric operations
just as any other integers, although they are most often used in comparisons
with other characters.</p>
<p>Certain characters can be represented in character and string constants by
escape sequences like <code>\n</code> (newline); these sequences look like two characters,
but represent only one. In addition, an arbitrary byte-sized bit pattern can be
specified by</p>
<pre><code class="language-c">'/ooo'
</code></pre>
<p>where <em>ooo</em> is one to three octal digits (0..7) or by</p>
<pre><code class="language-c">'/xhh'
</code></pre>
<p>where <em>hh</em> is one ore more hexadecimal digits (0..9, a..f, A..F). So we might
write</p>
<pre><code class="language-c">#define VTAB '/013'     /* ASCII vertical tab */
#define BELL '/007'     /* ASCII bell character */
</code></pre>
<p>or, in hexadecimal,</p>
<pre><code class="language-c">#define VTAB '\xb'      /* ASCII vertical tab */
#define BELL '\x7'      /* ASCII bell character */
</code></pre>
<p>The complete set of escape sequences is</p>
<pre><code>\a      alert (bell) character          \\      backslash
\b      backspace                       \?      question mark
\f      formfeed                        \'      single quote
\b      newline                         \&quot;      double quote
\r      carriage return                 \000    octal number
\t      horizontal tab                  \xhh    hexadecimal number
\b      vertical tab
</code></pre>
<p>The character constants <code>'\0'</code> represents the character with value zero, the
null character. <code>'\0'</code> is often written instead of <code>0</code> to emphasize the
character nature of some expression, but the numeric value is just 0.</p>
<p>A <em>constant expression</em> is an expression that involves only constants. Such
expressions may be evaluated during compilation rather than run-time, ans
accordingly may be used in any place that a constant can occur, as in</p>
<pre><code class="language-c">#define MAXLINE 1000
char line[MAXLINE+1];
</code></pre>
<p>or</p>
<pre><code class="language-c">#define LEAP 1   /* in leap years */
int days[31+28+LEAP+31+30+31+30+31+31+30+31+30+31];
</code></pre>
<p>A <em>string constant</em>, or <em>string literal</em>, is a sequence of zero or more
characters surrounded by double quotes, as in</p>
<pre><code class="language-c">&quot;I am a string&quot;
</code></pre>
<p>or</p>
<pre><code class="language-c">&quot;&quot;  /* the empty string */
</code></pre>
<p>The quotes are not part of the string, but serve only to delimit it. The same
escape sequences used in character constants apply in string; <code>\&quot;</code> represents
the double-quote character. String constants can be concatenated at compile
time:</p>
<pre><code class="language-c">&quot;hello,&quot; &quot; world&quot;
</code></pre>
<p>is equivalent to</p>
<pre><code class="language-c">&quot;hello, world&quot;
</code></pre>
<p>This is useful for splitting long strings across several source lines.</p>
<p>Technically, a string constant is an array of characters. The internal
representation of a string has a null character <code>'\0'</code> at the end, so they
physical storage required is more than the number of characters written between
the quotes. This representation means that there is no limit to how long a
string can be, but programs must scan a string completely to determine its
length. The standard library function <code>strlen(s)</code> returns the length of its
character string argument <code>s</code>, excluding the terminal <code>'\0'</code>. Here is our
version:</p>
<pre><code class="language-c">/* strlen:  return length of s */
int strlen(char s[])
{
    int i;

    i = 0;
    while (s[i] != '\0')
        ++i;
    return i;
}
</code></pre>
<p><code>strlen</code> and other string functions are declared in the standard header
<code>&lt;string.h&gt;</code>.</p>
<p>Be careful to distinguish between a character constant and a string that
contains a single character: <code>'x'</code> is not the same as <code>&quot;x&quot;</code>. The former is an
integer, used to produce the numeric value of the letter <em>x</em> in the machine’s
character set. The latter is an array of characters that contains one character
(the letter <em>x</em>) and a <code>'\0'</code>.</p>
<p>There is one other kind of constant, the <em>enumeration constant</em>. An enumeration
is a list of constant integer values, as in</p>
<pre><code class="language-c">enum boolean { NO, YES };
</code></pre>
<p>The first name in an <code>enum</code> has value <code>0</code>, the next <code>1</code>, and so on, unless
explicit values are specified. If not all values are specified, unspecified
values continue the progression from the last specified value, as in the second
of these examples:</p>
<pre><code class="language-c">enum escapes { BELL = '\a', BACKSPACE = '\b', TAB = '\t',
               NEWLINE = '\n', VTAB = '\v', RETURN = '\r' };

enum months { JAN = 1, FEB, MAR, APR, MAY, JUN,
              JUL, AUG, SEP, OCT, NOV, DEV };
</code></pre>
<p>Names in different enumerations must be distinct. Values need not be distinct
in the same enumeration.</p>
<p>Enumerations provide a convenient way to associate constant values with names,
an alternative to <code>#define</code> with the advantage that the values can be generated
for you. Although variables of <code>enum</code> types may be declared, compilers need not
check that what you store in such a variable is a valid value for the
enumeration. Nevertheless, enumeration variables offer the chance of checking
and so are often better than <code>#define</code>s. In addition, a debugger may be able to
print values of enumeration variables in their symbolic form.</p>
<h2>Declarations</h2>
<p>All variables must be declared before use, although certain declarations can be
made implicitly by context. A declaration specifies a type, and contains a list
of one ore more variables of that type, as in</p>
<pre><code class="language-c">int  lower, upper, step;
char c, line[1000];
</code></pre>
<p>Variables can be distributed among declarations in any fashion; the lists above
could equally well be written as</p>
<pre><code class="language-c">int  lower;
int  upper;
int  step;
char c;
char line[1000];
</code></pre>
<p>This latter form takes more space, but is convenient for adding a comment to
each declaration or for subsequent modifications.</p>
<p>A variable may also be initialized in its declaration. If the name is followed
by an equals sign and an expression, the expression serves as an initializer,
as in</p>
<pre><code class="language-c">char  esc = '\\';
int   i = 0;
int   limit = MAXLINE+1;
float eps = 1.0e-5;
</code></pre>
<p>If the variable in question is not automatic, the initialization is done once
only, conceptually before the program starts executing, and the initializer
must be a constant expression. An explicitly initialized automatic variable is
initialized each time the function or block it is in is entered; the
initializer may be any expression. External and static variables are
initialized to zero by default. Automatic variables for which there is no
explicit initializer have undefined (i.e., garbage) values.</p>
<p>The qualifier <code>const</code> can be applied to the declaration of any variable to
specify that its value will not be changed. For an array, the <code>const</code> qualifier
says that the elements will not be altered.</p>
<pre><code class="language-c">const double e = 2.71828182845905;
const char msg[] = &quot;warning: &quot;;
</code></pre>
<p>The <code>const</code> declaration can also be used with array arguments, to indicate that
the function does not change that array:</p>
<pre><code class="language-c">int strlen(const char[]);
</code></pre>
<p>The result is implementation-defined if an attempt is made to change a <code>const</code>.</p>
<h2>Arithmetic Operators</h2>
<p>The binary arithmetic operators are <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and the modulus
operator <code>%</code>. Integer division truncates any fractional part. The expression</p>
<pre><code class="language-c">x % y
</code></pre>
<p>produces the remainder when <code>x</code> is divided by <code>y</code>, and thus is zero when <code>y</code>
divides <code>x</code> exactly. For example, a year is a leap year if it is divisible by 4
but not by 100, except that years divisible by 400 <em>are</em> leap years. Therefore</p>
<pre><code class="language-c">if ((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0)
    printf(&quot;%d is a leap year\n&quot;, year);
else
    printf(&quot;%d is not a leap year\n&quot;, year);
</code></pre>
<p>The <code>%</code> operator cannot be applied to <code>float</code> or <code>double</code>. The direction of
truncation for <code>/</code> and the sign of the result for for <code>%</code> are machine-dependent
for negative operands, as is the action taken on overflow or underflow.</p>
<p>The binary <code>+</code> and <code>-</code> operators have the same precedence, which is lower than
the precedence of <code>*</code>, <code>/</code>, and <code>%</code>, which is in turn lower than unary <code>+</code> and
<code>-</code>. Arithmetic operators associate left to right.</p>
<p>[Table @tbl:associativity] at the end of this chapter summarizes precedence and
associativity for all operators.</p>
<h2>Relational and Logical Operators</h2>
<p>The relational operators are</p>
<pre><code>&gt;   &gt;=   &lt;   &lt;=
</code></pre>
<p>They all have the same precedence. Just below them in precedence are the
equality operators:</p>
<pre><code>==   !=
</code></pre>
<p>Relational operators have lower precedence than arithmetic operators, so an
expression like <code>i &lt; lim-1</code> is taken as <code>i &lt; (lim-1)</code>, as would be expected.</p>
<p>More interesting are the logical operators <code>&amp;&amp;</code> and <code>||</code>. Expressions connected
by <code>&amp;&amp;</code> or <code>||</code> are evaluated left to right, and evaluation stops as soon as
the truth or falsehood of the result is known. Most C programs rely on these
properties. For example, here is a loop from the input function <code>getline</code> that
we wrote in [Chapter @sec:introduction]:</p>
<pre><code class="language-c">for (i=0; i&lt;lim-1 &amp;&amp; (c=getchar()) != '\n' &amp;&amp; c != EOF; ++i)
    s[i] = c;
</code></pre>
<p>Before reading a new character it is necessary to check that there is room to
store it in the array <code>s</code>, so the test <code>i &lt; lim-1</code> <em>must</em> be made first.
Moreover, if this test fails, we must not go on and read another character.</p>
<p>Similarly, it would be unfortunate if <code>c</code> were tested against <code>EOF</code> before
<code>getchar</code> is called; therefore the call and assignment must occur before the
character <code>c</code> is tested</p>
<p>The precedence of <code>&amp;&amp;</code> is higher than that of <code>||</code>, and both are lower than
relational and equality operators, so expression like</p>
<pre><code class="language-c">i&lt;lim-1 &amp;&amp; (c = getchar()) != '\n' &amp;&amp; c != EOF
</code></pre>
<p>need no extra parentheses. But since the precedence of <code>!=</code> is higher than
assignment, parentheses are needed in</p>
<pre><code class="language-c">(c = getchar()) != '\n'
</code></pre>
<p>to achieve the desired result of assignment to <code>c</code> and then comparison with
<code>'\n'</code>.</p>
<p>By definition, the numeric value of a relational or logical expression is 1 if
the relation is true, and 0 if the relation is false.</p>
<p>The unary negation operator <code>!</code> converts a non-zero operand into 0, and a zero
operand into 1. A common use of <code>!</code> is in constructions like</p>
<pre><code class="language-c">if (!valid)
</code></pre>
<p>rather than</p>
<pre><code class="language-c">if (valid == 0)
</code></pre>
<p>It’s hard to generalize about which form is better. Constructions like <code>!valid</code>
read nicely (“if not valid”), but more complicated ones can be hard to
understand.</p>
<p><strong>Exercise 2-2.</strong> Write a loop equivalent to the <code>for</code> loop above without using
<code>&amp;&amp;</code> or <code>||</code>.</p>
<h2>Type Conversions {#sec:type-conversions}</h2>
<p>When an operator has operands of different types, they are converted to a
common type according to a small number of riles. In general, the only
automatic conversions are those that convert a “narrower” operand into a
“wider” one without losing information, such as converting an integer to
floating point in an expression like <code>f + i</code>. Expressions that don’t make
sense, like using a <code>float</code> as a subscript, are disallowed. Expressions that
might lose information, like assigning a longer integer type to a shorter, or a
floating-point type to an integer, may draw a warning, but they are not
illegal.</p>
<p>A <code>char</code> is just a small integer, so <code>chars</code> may be freely used in arithmetic
expressions. This permits considerable flexibility in certain kinds of
character transformations. One is exemplified by this naive implementation of
the function <code>atoi</code>, which converts a string of digits into its numeric
equivalent.</p>
<pre><code class="language-c">/* atoi:   convert s to integer */
int atoi(chat s[])
{
    int i, n;

    n = 0;
    for (i = 0; s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9'; ++i)
        n = 10 * n + (s[i] - '0');
    return n;
}
</code></pre>
<p>As we discussed in [Chapter @sec:introduction], the expression</p>
<pre><code class="language-c">s[i] - '0'
</code></pre>
<p>gives the numeric value of the character stored in <code>s[i]</code>, because the values
of <code>'0'</code>, <code>'1'</code>, etc., form a contiguous increasing sequence.</p>
<p>Another example of <code>chat</code> to <code>int</code> conversion is the function <code>lower</code>, which
maps a single character to lower case <em>for the ASCII character set.</em> If the
character is not an upper case letter, <code>lower</code> returns it unchanged.</p>
<pre><code class="language-c">/* lower:   convert c to lower case; ASCII only */
int lower(int c)
{
    if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')
        return c + 'a' - 'A';
    else
        return c;
}
</code></pre>
<p>This works for ASCII because corresponding upper case and lower case letters
are a fixed distance apart as numeric values and each alphabet is
contiguous—there is nothing but letters between A and Z. This latter
observation is not true of the EBCDIC character set, however, so this code
would convert more than just letters in EBCDIC.</p>
<p>The standard header <code>&lt;ctype.h&gt;</code>, described in [Appendix @sec:std-lib], defines
a family of functions that provide tests and conversions that are independent
of character set. For example, the function <code>tolower</code> is a portable replacement
for the function <code>lower</code> shown above. Similarly, the test</p>
<pre><code class="language-c">c &gt;= '0' &amp;&amp; c &lt;= '9'
</code></pre>
<p>can be replaced by</p>
<pre><code class="language-c">isdigit(c)
</code></pre>
<p>We will use the <code>ctype.h&gt;</code> functions from now on.</p>
<p>There is one subtle point about the conversion of characters to integers. The
language does not specify whether variables of type <code>char</code> are signed or
unsigned quantities. When a <code>char</code> is converted to an <code>int</code>, can it ever
produce a negative integer? The answer varies from machine to machine,
reflecting differences in architecture. On some machines a <code>chat</code> whose
leftmost bit is a <code>will be converted to a negative integer (&quot;sign extension&quot;). On others, a</code>chat<code>is promoted to an</code>int` by adding zeros at the left end,
and thus is always positive.</p>
<p>The definition of C guarentees that any character in the machine’s standard
printing character set will never be negative, so these characters will always
be positive quantities in expressions. But arbitrary bit patterns stored in
character variables may appear to be negative on some machines, yet positive on
others. For portability, specify <code>signed</code> or <code>unsigned</code> if non-character data
is to be stored in <code>char</code> variables.</p>
<p>Relational expressions like <code>i &gt; j</code> and logical expressions connected by <code>&amp;&amp;</code>
and <code>||</code> are defined to have a value ` if true, and 0 if false. Thus the
assignment</p>
<pre><code class="language-c">d = c &gt;= '0' &amp;&amp; c &lt;= '9'
</code></pre>
<p>sets <code>d</code> to 1 if <code>c</code> is a digit, and 0 if not. However, functions like
<code>isdigit</code> may return any non-zero value for true. In the test part of <code>if</code>,
<code>while</code>, <code>for</code>, etc., “true” just means “non-zero”, so this makes no
difference.</p>
<p>Implicit arithmetic conversions work much as expected. In general, if an
operator like <code>+</code> or <code>*</code> that take two operands (a binary operator) has
operands of different types, the “lower’ type is <em>promoted</em> to the “higher”
type before the operation proceeds. The result is of the higher type. [Section
@sec:conversions] states the conversion rules precisely. If there are no
<code>unsigned</code> operands, however, the following informal set of rules will suffice:</p>
<p>If either operand is <code>long double</code>, convert the other to <code>long double</code>.</p>
<p>Otherwise, if either operand is <code>double</code>, convert the other to <code>double</code>.</p>
<p>Otherwise, if either operand is <code>float</code>, convert the other to <code>float</code>.</p>
<p>Otherwise, convert <code>char</code> and <code>short</code> to int.</p>
<p>Then, if either operand is <code>long</code>, convert the other to <code>long</code>.</p>
<p>Notice that <code>floats</code> in an expression are not automatically converted to
<code>double</code>; this is a change from the original definition. In general,
mathematical functions like those in <code>&lt;math.h&gt;</code> will use double precision. The
main reason for using <code>float</code> is to save storage in large arrays, or, less
often, to save time on machines where double-precision arithmetic is
particularly expensive.</p>
<p>Conversion rules are more complicated when <code>unsigned</code> operands are involved.
The problem is that comparisons between signed and unsigned values are
machine-dependent, because they depend on the sizes of various integer types.
For example, suppose that an <code>int</code> is 16 bits and <code>long</code> is 32 bits. Then <code>-1L &lt; 1U</code>, because <code>1U</code>, which is an int, is promoted to a <code>signed long</code>. But `-1L</p>
<blockquote>
<p>1UL<code>, because </code>-1L<code>is promoted to</code>unsigned long` and thus appears to be a
large positive number.</p>
</blockquote>
<p>Conversions take place across assignments; the value of the right side is
converted to the type of the left, which is the type of the result.</p>
<p>A character is converted to an integer, either by sign extension or not, as
described above.</p>
<p>Longer integers are converted to shorter ones or to <code>chars</code> by dropping the
excess high-order bits. Thus in</p>
<pre><code class="language-c">int  i;
char c;

i = c;
c = i;
</code></pre>
<p>the value of <code>c</code> is unchanged. This is true whether or not sign extension is
involved. Reversing the order of assignments might lost informations, however.</p>
<p>If <code>x</code> is <code>float</code> and <code>i</code> is <code>int</code>, then <code>x = i</code> and <code>i = x</code> both cause
conversions; <code>float</code> to <code>int</code> causes truncation of any fractional part. When
<code>double</code> is converted to <code>float</code>, whether the value is rounded or truncated is
implementation-dependent.</p>
<p>Since an argument of a function call is an expression, type conversions also
take place when arguments are passed to functions. In the absence of a function
prototype, <code>char</code> and <code>short</code> become <code>int</code>, and <code>float</code> becomes <code>double</code>. This
is why we have declared function arguments to be <code>int</code> and <code>double</code> even when
the function is called with <code>char</code> and <code>float</code>.</p>
<p>Finally, explicit type conversions can be forced (“coerced”) in any expression,
with a unary operator called a <em>cat</em>. In the construction</p>
<pre><code>(type-name) expression
</code></pre>
<p>the <em>expression</em> is converted to the named type by the conversion rules above.
The precise meaning of a case is as if the <em>expression</em> were assigned to a
variable of the specified type, which is then used in place of the whole
construction. For example, the library routine <code>sqrt</code> expects a <code>double</code>
argument, and will produce nonsense if inadvertently handed something else.
(<code>sqrt</code> is declared in <code>&lt;math.h&gt;</code>.) So if <code>n</code> is an integer, we can use</p>
<pre><code class="language-c">sqrt((double) n)
</code></pre>
<p>to convert the value of <code>n</code> to <code>double</code> before passing it to <code>sqrt</code>. Note that
the cast produces the <em>value</em> of <code>n</code> in the proper type; <code>n</code> itself is not
altered. The cast operator has the same high precedence as other unary
operators, as summarized in the able at the end of this chapter.</p>
<p>If arguments are declared by a function prototype, as they normally should be,
the declaration causes automatic coercion of any arguments when the function is
called. Thus, given a function prototype for <code>sqrt</code>:</p>
<pre><code class="language-c">double sqrt(double);
</code></pre>
<p>the call</p>
<pre><code class="language-c">root2 = sqrt(2);
</code></pre>
<p>coerces the integer <code>2</code> into the <code>double</code> value <code>2.0</code> without any need for a
cast.</p>
<p>The standard library includes a portable implementation of a pseudo-random
number generator and a function for initializing the seed; the former
illustrates a case:</p>
<pre><code class="language-c">unsigned long int next = 1;

/* rand:   return pseudo-random integers on 0..32767 */
int rand(void)
{
    next = next * 1103515245 + 12345;
    return (unsigned int)(next/65536) % 32769;
}

/* srand:   set seed for rand() */
void stand(unsigned int seed)
{
    next = seed;
}
</code></pre>
<p><strong>Exercise 2-3.</strong> Write the function <code>htoi(s)</code>, which converts a string of
hexadecimal digits (including an optional 0x or 0X) into its equivalent integer
value. The allowable digits are <code>0</code> through <code>9</code>, <code>a</code> through <code>f</code>, and <code>A</code>
through <code>F</code>.</p>
<h2>Increment and Decrement operators</h2>
<p>C provides two unusual operators for incrementing and decrementing variables.
The increment operator <code>++</code> adds 1 to its operand, while the decrement operator
<code>--</code> subtracts 1. We have frequently used <code>++</code> to increment variables, as in</p>
<pre><code class="language-c">if (c == '\n')
    ++nl;
</code></pre>
<p>The unusual aspect is that <code>++</code> and <code>--</code> may be used either as prefix operators
(before the variable, as in <code>++n</code>), or postfix (after the variable: <code>n++</code>). In
both cases, the effect is to increment <code>n</code>. But the expression <code>++n</code> increments
<code>n</code> <em>before</em> its value is used, while <code>n++</code> increments <code>n</code> <em>after</em> its value
has been used. This means that in a context where the value is being used, not
just the effect, <code>++n</code> and <code>n++</code> are different. If <code>n</code> is 5, then</p>
<pre><code class="language-c">x = n++;
</code></pre>
<p>sets <code>x</code> to 5, but</p>
<pre><code class="language-c">x = ++n;
</code></pre>
<p>sets <code>x</code> to 6. In both cases, <code>n</code> becomes 6. The increment and decrement
operators can only be applied to variables; an expression like <code>(i+j)++</code> is
illegal.</p>
<p>In a context where no value is wanted, just the incrementing effect, as in</p>
<pre><code class="language-c">if (c == '\n')
    nl++;
</code></pre>
<p>prefix and postfix are the same. But there are situations where one or the
other is specifically called for. For instance, consider the function
<code>squeeze(s,c)</code>, which removes all occurrences of the character <code>c</code> from the
string <code>s</code>.</p>
<pre><code class="language-c">/* squeeze:  delete all c from s */
void squeeze(char s[], int c)
{
    int i, j;

    for (i = j = 0; s[i] != '\0'; i++)
        if (s[i] != c)
            s[j++] = s[i];
    s[j] = '\0';
}
</code></pre>
<p>Each time a non-<code>c</code> occurs, it is copied into the current <code>j</code> position, and
only then is <code>j</code> incremented to be ready for the next character. This is
exactly equivalent to</p>
<pre><code class="language-c">if (s[i] != c) {
    s[j] = s[i];
    j++;
}
</code></pre>
<p>Another example of a similar construction comes from the <code>getline</code> function
that we wrote in [Chapter @sec:introduction], where we can replace</p>
<pre><code class="language-c">if (c == '\n') {
    s[i] = c;
    ++i;
}
</code></pre>
<p>by the more compact</p>
<pre><code class="language-c">if (c == '\n')
    s[i++] = c;
</code></pre>
<p>As a third example, consider the standard function <code>strcat(s,t)</code>, which
concatenates the string <code>t</code> to the end of the string <code>s</code>. <code>strcat</code> assumes that
there is enough space in <code>s</code> to hold the combination. As we have written it,
<code>strcat</code> return no value; the standard library version return a pointer to the
resulting string.</p>
<pre><code class="language-c">/* strcat:  concatenate t to end of s; s must be big enough */
void strcat(char s[], char t[])
{
    int i, j;

    i = j = 0;
    while (s[i] != '\0')    /* find end of s */
        i++;
    while ((s[i++] = t[j++]) != '\0')   /* copy t */
        ;
}
</code></pre>
<p>As each character is copied from <code>t</code> to <code>s</code>, the postfix <code>++</code> is applied to
both <code>i</code> and <code>j</code> to make sure that they are in position for the next pass
through the loop.</p>
<p><strong>Exercise 2-4.</strong> Write an alternative version of <code>squeeze(s1,s2)</code> that deletes
each character in <code>s1</code> that matches any character in the <em>string</em> <code>s2</code>.</p>
<p><strong>Exercise 2-5.</strong> Write the function <code>any(s1,s2)</code>, which returns the first
location in the string <code>s1</code> where any character from the string <code>s2</code> occurs, or
<code>-1</code> if <code>s1</code> contains no characters from <code>s2</code>. (The standard library function
<code>strpbrk</code> does the same job but returns a pointer to the location.)</p>
<h2>Bitwise Operators</h2>
<p>C provides six operators for bit manipulation; these may only be applied to
integral operand, that is, <code>char</code>, <code>short</code>, <code>int</code>, and <code>long</code>, whether signed
or unsigned.</p>
<pre><code>&amp;     bitwise AND
|     bitwise inclusive OR
^     bitwise exclusive OR
&lt;&lt;    left shift
&gt;&gt;    right shift
~     one's complement (unary)
</code></pre>
<p>The bitwise <code>AND</code> operator <code>&amp;</code> is often used to mask off some set of bits; for
example,</p>
<pre><code class="language-c">n = n &amp; 0177;
</code></pre>
<p>sets to zero all but the low-order 7 bits of <code>n</code>.</p>
<p>The bitwise <code>OR</code> operator <code>|</code> is used to turn bits on:</p>
<pre><code class="language-c">x = x | SET_ON;
</code></pre>
<p>sets to one in <code>x</code> the bits that are set to one in <code>SET_ON</code>.</p>
<p>The bitwise exclusive <code>OR</code> operator <code>^</code> sets a one in each bit position where
its operands have different bits, and zero where they are the same.</p>
<p>One must distinguish the bitwise operators <code>&amp;</code> and <code>|</code> from the logical
operators <code>&amp;&amp;</code> and <code>||</code>, which imply left-to-right evaluation of a truth value.
For example, if <code>x</code> is 1 and <code>y</code> is 2, then <code>x &amp; y</code> is zero while <code>x &amp;&amp; y</code> is
one.</p>
<p>The shift operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code> perform left and right shifts of their left
operand by the number of bit position given by the right operand, which must be
positive. Thus <code>x &lt;&lt; 2</code> shifts the value of <code>x</code> left by two position, filling
vacated bits with zero; this is equivalent to multiplication by 4. Right
shifting an <code>unsighned</code> quantity always fills vacated bits with zero. Right
shifting a <code>signed</code> quantity will fill with sign bits (“arithmetic shift”) on
some machines and with 0-bits (“logical shift”) on others.</p>
<p>The unary operator <code>~</code> yields the one’s complement of an integer; that is, it
converts each 1-bit into a 0-bit and vice versa. For example,</p>
<pre><code class="language-c">x = x &amp; ~077
</code></pre>
<p>sets the last six bits of <code>x</code> to zero. Note that <code>x &amp; ~077</code> is independent of
word length, and is thus preferable to, for example, <code>x &amp; 0177700</code>, which
assumes that <code>x</code> is a 16-bit quantity. The portable form involves no extra
cost, since <code>~077</code> is a constant expression that can be evaluated at compile
time.</p>
<p>As an illustration of some of the bit operators, consider the function
<code>getbits(x,p,n)</code> that returns the (right adjusted) <code>n</code>-bit field of <code>x</code> that
begins at position <code>p</code>. We assume that bit position 0 is at the right end and
that <code>n</code> and <code>p</code> are sensible positive values. For example, <code>getbits(x,4,3)</code>
returns the three bits in bit positions 4, 3 and 2, right adjusted.</p>
<pre><code class="language-c">/* get bits:  get n bits from position p */
unsigned getbits(unsigned x, int p, int n)
{
    return (x &gt;&gt; (p+1-n)) &amp; ~(~0 &lt;&lt; n);
}
</code></pre>
<p>The expression <code>x &gt;&gt; (p+1-n)</code> moves the desired field to the right end of the
word. <code>~0</code> is all 1-bits; shifting it left <code>n</code> bit positions with <code>~0&lt;&lt;n</code>
places zeros in the rightmost <code>n</code> bits; complementing that with <code>~</code> makes a
mask with ones in the rightmost <code>n</code> bits.</p>
<p><strong>Exercise 2-6.</strong> Write a function <code>setbits(x,p,n,y)</code> that returns <code>x</code> with the
<code>n</code> bits that begin at position <code>p</code> set to the rightmost <code>n</code> bits of <code>y</code>,
leaving the other bits unchanged.</p>
<p><strong>Exercise 2-7.</strong> Write a function <code>invert(x,p,n)</code> that returns <code>x</code> with the
<code>n</code> bits that begin at position <code>p</code> inverted (i.e., 1 changed into 0 and vice
versa), leaving the other unchanged.</p>
<p><strong>Exercise 2-8.</strong> Write a function <code>rightrot(x,n)</code> that returns the value of
the integer <code>x</code> rotated to the right by <code>n</code> position.</p>
<h2>Assignment Operators and Expressions</h2>
<p>Expressions such as</p>
<pre><code class="language-c">i = i + 2
</code></pre>
<p>in which the variable on the left hand side is repeated immediately on the
right, can be written in the compressed form</p>
<pre><code class="language-c">i += 2
</code></pre>
<p>The operator <code>+=</code> is called an <em>assignment operator</em>.</p>
<p>Most binary operators (operators like <code>+</code> that have a left and right operand)
have a corresponding assignment operator <em>op</em>=, where <em>op</em> is one of</p>
<pre><code>+   -   *   /   %   &lt;&lt;   &gt;&gt;   &amp;   ^   |
</code></pre>
<p>If <em>expr1</em> and <em>expr2</em> are expressions, then</p>
<pre><code>expr1 op= expr2
</code></pre>
<p>is equivalent to</p>
<pre><code>expr1 = (expr1) op (expr2)
</code></pre>
<p>except that <em>expr1</em> is computer only once. Notice the parentheses around
<em>expr2</em>:</p>
<pre><code class="language-c">x *= y + 1
</code></pre>
<p>means</p>
<pre><code class="language-c">x = x * (y + 1)
</code></pre>
<p>rather than</p>
<pre><code class="language-c">x = x * y + 1
</code></pre>
<p>As an example, the function <code>biitcount</code> counts the number of 1-bits in its
integer argument.</p>
<pre><code class="language-c">/* bitcount:  count 1 bits in x */
int bitcount(unsigned x)
{
    int b;

    for (b = 0; x != 0; x &gt;&gt;= 1)
        if (x &amp; 01)
            b++;
    return b;
}
</code></pre>
<p>Declaring the argument <code>x</code> to be <code>unsigned</code> ensured that when it is
right-shifted, vacated bits will be filled with zeros, not sign bits,
regardless of the machine the program is run on.</p>
<p>Quite apart from the conciseness, assignment operators have the advantage that
they correspond better to the way people think. We say “add 2 to <code>i</code>” or
“increment <code>i</code> by 2,” not “take <code>i</code>, add 2, then put the result back in <code>i</code>.”
Thus the expression <code>i += 2</code> is preferable to <code>i = i+2</code>. In addition, for
complicated expressions like</p>
<pre><code class="language-c">yyval[yypv[p3+p4] + yypv[p1+p2]] += 2
</code></pre>
<p>the assignment operator makes the code easier to understand, since the reader
doesn’t have to check painstakingly that two long expressions are indeed the
same, or to wonder why they’re not. And an assignment operator may even help a
compiler to produce efficient code.</p>
<p>We have already seen that the assignment statement has a value and can occur in
expressions; the most common example is</p>
<pre><code class="language-c">while ((c = getchar()) != EOF)
    ...
</code></pre>
<p>The other assignment operators (<code>+=</code>, <code>-=</code>, etc.) can also occur in
expressions, although this is less frequent.</p>
<p>In all such expressions, the type of an assignment expression is the type of
its left operand,, and the value is the value after the assignment.</p>
<p><strong>Exercise 2-9.</strong> In a two’s complement number system, <code>x &amp;= (x-1)</code> deletes the
rightmost 1-bit in <code>x</code>. Explain why. Use this observation to write a faster
version of <code>bitcount</code>.</p>
<h2>Conditional Expressions</h2>
<p>The statements</p>
<pre><code class="language-c">if (a &gt; b)
    z = a;
else
    z = b;
</code></pre>
<p>compute in <code>z</code> the maximum of <code>a</code> and <code>b</code>. The <em>conditional expression</em>,
written with the ternary operator “<code>?:</code>”, provides an alternate way to write
this and similar constructions. In the expression</p>
<pre><code>expr1 ? expr2 : expr3
</code></pre>
<p>the expression <em>expr1</em> is evaluated first. If it is non-zero (true), then the
expression <em>expr2</em> is evaluated, and that is the value of the conditional
expression. Otherwise <em>expr3</em> is evaluated, and that is the value. Only one of
<em>expr2</em> and <em>expr3</em> is evaluated. Thus to set <code>z</code> to the maximum of <code>a</code> and
<code>b</code>,</p>
<pre><code class="language-c">z = (a &gt; b) ? a : b;    /* z = max(a, b) */
</code></pre>
<p>It should  be noted that the conditional expression is indeed an expression,
and it can be used wherever any other expression can be. If <em>expr2</em> and <em>expr3</em>
are of different types, the type of the result is determined by the conversion
rules discussed earlier in this chapter. For example, if <code>f</code> is a <code>float</code> and
<code>n</code> is an <code>int</code>, then the expression</p>
<pre><code class="language-c">(n &gt; 0) ? f : n
</code></pre>
<p>is of type <code>float</code> regardless of whether <code>n</code> is positive.</p>
<p>Parenthesis are not necessary around the first expression of a conditional
expression, since the precedence of <code>?:</code> is very low, just above assignment.
They are advisable anyway, however, since they make the condition part of the
expression easier to see.</p>
<p>The conditional expression often leads to succinct code. For example, this loop
prints <code>n</code> elements of an array, 10 per line, with each column separated by one
blank, and with each line (including the last) terminated by a newline.</p>
<pre><code class="language-c">for (i = 0; i &lt; n; i++)
    printf(&quot;%6d%c&quot;, a[i], (i%10==9 || i==n-1) ? '\n' : ' ');
</code></pre>
<p>A newline is printed after every tenth element, and after the <code>n</code>-th. All other
elements are followed by one blank. This might look tricky, but it’s more
compact than the equivalent <code>if</code>-<code>else</code>. Another good example is</p>
<pre><code class="language-c">printf(&quot;You have %d item%s.\n&quot;, n, n==1 ? &quot;&quot; : &quot;s&quot;);
</code></pre>
<p><strong>Exercise 2-10.</strong> Rewrite the function <code>lower</code>, which converts upper case
letters to lower case, with a conditional expression instead of <code>if</code>-<code>else</code>.</p>
<h2>Precedence and Order of Evaluation</h2>
<p>[Table @tbl:associativity] summarizes the rules for precedence and
associativity of all operators, including those that we have not yet discussed.
Operators on the same line have the same precedence; rows are in order of
decreasing precedence, so, for example, <code>*</code>, <code>/</code>, and <code>%</code> all have the same
precedence, which is higher than that of binary <code>+</code> and <code>-</code>. The “operator”
<code>()</code> refers to function call. The operators <code>-&gt;</code> and <code>.</code> are used to access
members of structures; they will be covered in [Chapter @sec:structures], along
with <code>sizeof</code> (size of an object). [Chapter @sec:pointers] discusses <code>*</code>
(indirection through a pointer) and <code>&amp;</code> (address of an object), and [Chapter
@sec:control-flow] discusses the comma operator.</p>
<p>Note that the precedence of the bitwise operators <code>&amp;</code>, <code>^</code>, and <code>|</code> falls below
<code>==</code> and <code>!=</code>. This implies that bit-testing expressions like</p>
<pre><code class="language-c">if ((x &amp; MASK) == 0) ...
</code></pre>
<p>must be fully parenthesized to give proper results.</p>
<p>C, like most languages, does not specify the order in which the operands of an
operator are evaluated. (The exceptions are <code>&amp;&amp;</code>, <code>||</code>, <code>?:</code>, and <code>,</code>.) For
example, in a statement like</p>
<pre><code class="language-c">x = f() = g();
</code></pre>
<p><code>f</code> may be evaluated before <code>g</code> or vice versa; thus if either <code>f</code> or <code>g</code> alters
a variable on which the other depends, <code>x</code> can depend on the order of
evaluation. Intermediate results can be stored in temporary variables to ensure
a particular sequence.</p>
<p>Similarly, the order in which function arguments are evaluated is not
specified, so the statement</p>
<pre><code class="language-c">printf(&quot;%d %d\n&quot;, ++n, power(2, n));    /* WRONG */
</code></pre>
<p>can produce different results with different compiler, depending on whether <code>n</code>
is incremented before <code>power</code> is called. The solution of course, is to write</p>
<pre><code class="language-c">++n;
printf(&quot;%d %d\n&quot;, n, power(2, n));
</code></pre>
<p>Function calls, nested assignment statements, and increment and decrement
operators cause “side effects”—some variable is changed as a by-produce of
the evaluation of an expression. In any expression involving side effects,
there can be subtle dependencies on the order in which variables taking part in
the expression are updated. One unhappy situation is typified by the statement</p>
<pre><code class="language-c">a[i] = i++;
</code></pre>
<p>The question is whether the subscript is the old value of <code>i</code> or the new.
Compilers can interpret this in different ways, and generate different answers
depending on their interpretation. The standard intentionally leaves most such
matters unspecified. When side effects (assignment to variables) take place
within an expression is left to the discretion of the compiler, since the best
order depends strongly on machine architecture. (The standard does specify that
all side effects on arguments take effect before a function is called, but that
would not help in the call to <code>printf</code> above.)</p>
<p>The moral is that writing code that depends on order of evaluation is a bad
programming practice in any language. Naturally, it is necessary to know what
things to avoid, but if you don’t know <em>how</em> they are done on various machines,
you won’t be tempted to take advantage of a particular implementation.</p>
<p>Table: Precedence and Associativity of Operators. Unary <code>+</code>, <code>-</code> and <code>*</code> have
higher precedence than the binary forms. {#tbl:associativity}</p>
<table>
<thead>
<tr>
<th align="left">Operators</th>
<th align="center">Associativity</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"><code>()  []  -&gt;  .</code></td>
<td align="center">left to right</td>
</tr>
<tr>
<td align="left"><code>! ~ ++ -- + - * &amp; (type) sizeof</code></td>
<td align="center">right to left</td>
</tr>
<tr>
<td align="left"><code>*   /   %</code></td>
<td align="center">left to right</td>
</tr>
<tr>
<td align="left"><code>+   -</code></td>
<td align="center">left to right</td>
</tr>
<tr>
<td align="left"><code>&lt;&lt;  &gt;&gt;</code></td>
<td align="center">left to right</td>
</tr>
<tr>
<td align="left"><code>&lt;   &lt;=  &gt;   &gt;=</code></td>
<td align="center">left to right</td>
</tr>
<tr>
<td align="left"><code>==  !=</code></td>
<td align="center">left to right</td>
</tr>
<tr>
<td align="left"><code>&amp;</code></td>
<td align="center">left to right</td>
</tr>
<tr>
<td align="left"><code>^</code></td>
<td align="center">left to right</td>
</tr>
<tr>
<td align="left">`</td>
<td align="center">`</td>
</tr>
<tr>
<td align="left"><code>&amp;&amp;</code></td>
<td align="center">left to right</td>
</tr>
<tr>
<td align="left">`</td>
<td align="center"></td>
</tr>
<tr>
<td align="left"><code>?:</code></td>
<td align="center">right to left</td>
</tr>
<tr>
<td align="left">`= += -= *= /= %= &amp;= ^=</td>
<td align="center">= &lt;&lt;= &gt;&gt;=`</td>
</tr>
<tr>
<td align="left"><code>,</code></td>
<td align="center">left to right</td>
</tr>
</tbody>
</table>
<h1>Control Flow {#sec:control-flow}</h1>
<p>The control-flow statements of a language specify the order in which
computations are performed. We have already met the most common control-flow
constructions in earlier examples; here we will complete the set, and be more
precise about the ones discussed before.</p>
<h2>Statements and Blocks</h2>
<p>An expression such as <code>x = 0</code> or <code>i++</code> or <code>printf(...)</code> becomes a <em>statement</em>
when it is followed by a semicolon, as in</p>
<pre><code class="language-c">x = 0;
i++;
printf(...);
</code></pre>
<p>In C, the semicolon is a statement terminator, rather than a separator as it is
in languages like Pascal.</p>
<p>Braces <code>{</code> and <code>}</code> are used to group declarations and statements together into
a <em>compound statement</em>, or <em>block</em>, so that they are syntactically equivalent
to a single statement. The braces that surround the statements of a function
are one obvious example; braces around multiple statements after an <code>if</code>,
<code>else</code>, <code>while</code>, or <code>for</code> are another (Variables can be declared inside <em>any</em>
block; we will talk about this in Chapter 4.) There is no semicolon after the
right brace that ends a block.</p>
<h2>If-Else</h2>
<p>The <code>if</code>-<code>else</code> statement is used to express decisions. Formally, the syntax is</p>
<pre><code class="language-c">if (expression)
    statement1
else
    statement2
</code></pre>
<p>where the <code>else</code> part is optional. The <em>expression</em> is evaluated; if it is true
(that is, if <em>expression</em> has a non-zero value), <em>statement1</em> is executed. If
it is false (<em>expression</em> is zero) and if there is an <code>else</code> part, <em>statement2</em>
is executed instead.</p>
<p>Since an <code>if</code> simply tests the numeric value of an expression, certain coding
shortcuts are possible. The most obvious is writing</p>
<pre><code class="language-c">if (expression)
</code></pre>
<p>instead of</p>
<pre><code class="language-c">if (expression != 0)
</code></pre>
<p>Sometimes this is natural and clear; at other times it can be cryptic.</p>
<p>Because the <code>else</code> part of an <code>if</code>-<code>else</code> is optional, there is an ambiguity
when an <code>else</code> is omitted from a nested <code>if</code> sequence. This is resolved by
associating the <code>else</code> with the closest previous <code>else</code>-less <code>if</code>. For example,
in</p>
<pre><code class="language-c">if (n &gt; 0)
    if (a &gt; b)
        z = a;
    else
        z = b;
</code></pre>
<p>the <code>else</code> goes with the inner <code>if</code>, as we have shown by indentation. If that
isn’t what you want, braces must be used to force the proper association:</p>
<pre><code class="language-c">if (n &gt; 0) {
    if (a &gt; b)
        z = a;
}
else
    z = b;
</code></pre>
<p>The ambiguity is especially pernicious in situations like this:</p>
<pre><code class="language-c">if (n &gt;= 0)
    for (i = 0; i &lt; n; i++)
        if (s[i] &gt; 0) {
            printf(&quot;...&quot;);
            return i;
        }
else        /* WRONG */
    printf(&quot;error -- n is negative\n&quot;);
</code></pre>
<p>The indentations shows unequivocally what you want, but the compiler doesn’t
get the message, and associates the <code>else</code> with the inner if. This kind of bug
can be hard to find; it’s a good idea to use braces when there are nested
<code>if</code>s.</p>
<p>By the way, notice that there is a semicolon after <code>z = a</code> in</p>
<pre><code class="language-c">if (a &gt; b)
    z = a;
else
    z = b;
</code></pre>
<p>This is because grammatically, a <em>statement</em> follows the <code>if</code>, and an
expression statement like “<code>z = a'</code>” is always terminated by a semicolon.</p>
<h2>Else-If {#sec:else-if}</h2>
<p>The construction</p>
<pre><code class="language-c">if (expression)
    statement
else if (expression)
    statement
else if (expression)
    statement
else if (expression)
    statement
else
    statement
</code></pre>
<p>occurs so often that it is worth a brief separate discussion. This sequence of
<code>if</code> statements is the most general way of writing a multi-way decision. The
<em>expressions</em> are evaluated in order; if any <em>expression</em> is true, the
<em>statement</em> associated with it is executed, and this terminates the whole
chain. As always, the code for each <em>statement</em> is either a single statement,
or a group in braces.</p>
<p>The last <code>else</code> part handles the “none of the above” or default case where none
of the other conditions is satisfied. Sometimes there is no explicit action for
the default; in that case the trailing</p>
<pre><code class="language-c">else
    statement
</code></pre>
<p>can be omitted, or it may be used for error checking to catch an “impossible”
condition.</p>
<p>To illustrate a three-way decision, here is a binary search function that
decides if a particular value <code>x</code> occurs in the sorted array <code>v</code>. The elements
of <code>v</code> must be in increasing order. The function returns the position (a number
between <code>0</code> and <code>n-1</code>) if <code>x</code> occurs in <code>v</code>, and <code>-1</code> if not.</p>
<p>Binary search first compares the input value <code>x</code> to the middle elements of the
array <code>v</code>. If <code>x</code> is less than the middle value, searching focuses on the lower
half of the table, otherwise on the upper half. In either case, the next step
is to compare <code>x</code> to the middle element of the selected half. This process of
dividing the range in two continues until the value is found or the range is
empty.</p>
<pre><code class="language-c">/* binsearch:  find x in v[0] &lt;= v[1] &lt;= ... &lt;= v[n-1] */
int binsearch(int x, int v[], int n)
{
    int low, high, mid;

    low = 0;
    high = n - 1;
    while (low &lt;= high) {
        mid = (low+high) / 2;
        if (x &lt; v[mid])
            high = mid - 1;
        else if (x &gt; v[mid])
            low = mid + 1;
        else    /* found match */
            return mid;
    }
    return -1;  /* no match */
}
</code></pre>
<p>The fundamental decision is whether <code>x</code> is less than, greater than, or equal to
the middle element <code>v[mis]</code> at each step; this is a natural for <code>else</code>-<code>if</code>.</p>
<p><strong>Exercise 3-1.</strong> Our binary search makes two tests inside the loop, when one
would suffice (at the price of more tests outside). Write a version with only
one test inside the loop and measure the different in run-time.</p>
<h2>Switch {#sec:switch}</h2>
<p>The <code>switch</code> statement is a multi-way decision that tests whether an expression
matches one of a number of <em>constant</em> integer values, and branches accordingly.</p>
<pre><code class="language-c">switch (expression) {
    case const-expr:   statements
    case const-expr:   statements
    default:    statements
}
</code></pre>
<p>Each case is labeled by one or more integer-valued constants or constant
expressions. If a case matches the expression value, execution starts at that
case. All case expressions must be different. The case labeled <code>default</code> is
executed if none of the other cases are satisfied. A <code>default</code> is optional; if
it isn’t there and if none of the cases match, no action at all takes place.
Cases and the default clause can occur in any order.</p>
<p>In Chapter 1 we wrote a program to count the occurrences of each digit, white
space, and all other characters, using a sequence of <code>if</code> … <code>else if</code> …
<code>else</code>. Here is the same program with a <code>switch</code>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

main()  /* count digits, white space, others */
{
    int c, i, nwhite, nother, ndigit[10];

    nwhite = nother = 0;
    for (i = 0; i &lt; 10; i++)
        ndigit[i] = 0;
    while ((c = getchar()) != EOF) {
        switch(c) {
            case '0': case '1': case '2': case '3': case '4':
            case '5': case '6': case '7': case '8': case '9':
                ndigit[c-'0']++;
                break;
            case ' ':
            case '\n':
            case '\t':
                nwhite++;
                break;
            default:
                nother++;
                break;
        }
    }
    printf(&quot;digits =&quot;);
    for (i = 0; i &lt; 10; i++)
        printf(&quot; %d&quot;, ndigit[i]);
    printf(&quot;, white space = %d, other = %d\n&quot;,
        nwhite, nother);
    return 0;
}
</code></pre>
<p>The <code>break</code> statement causes an immediate exit from the <code>switch</code>. Because cases
serve just as labels, after the code for one case is done, execution <em>falls
through</em> to the next unless you take explicit action to escape. <code>break</code> and
<code>return</code> are the most common ways to leave a <code>switch</code>. A <code>break</code> statement can
also be used to force an immediate exit from <code>while</code>, <code>for</code>, and <code>do</code> loops, as
will be discussed later in this chapter.</p>
<p>Falling through cases is a mixed blessing. On the positive side, it allows
several cases to be attached to a single action, as with the digits in this
example. But it also implied that normally each case must end with a <code>break</code> to
prevent falling through to the next. Falling through from one case to another
is not robus, being prone to disintegration when the program is modified. With
the exception of multiple labels for a single computation, fall-throughs should
be used sparingly, and commented.</p>
<p>As a matter of good form, put a <code>break</code> after the last case (the <code>default</code>
here) even through it’s logically unnecessary. Some day when another case gets
added at the end, this bit of defensive programming will save you.</p>
<p><strong>Exercise 3-2.</strong> Write a function <code>escape(s,t)</code> that converts characters like
newline and tab into visible escape sequences like <code>\n</code> and <code>\t</code> as it copies
the string <code>t</code> to <code>s</code>. Use a <code>switch</code>. Write a function for the other direction
as well, converting escape sequences into the real characters.</p>
<h2>Loops—While and For</h2>
<p>We have already encountered the <code>while</code> and <code>for</code> loops. In</p>
<pre><code class="language-c">while (expression)
    statement
</code></pre>
<p>the <em>expression</em> is evaluated. If it is non-zero, <em>statement</em> is executed and
<em>expression</em> is re-evaluated. This cycle continues until <em>expression</em> becomes
zero, at which point execution resumes after <em>statement</em>.</p>
<p>The <code>for</code> statement</p>
<pre><code class="language-c">for (expr1; expr2; expr3)
    statement
</code></pre>
<p>is equivalent to</p>
<pre><code class="language-c">expr1;
while (expr2) {
    statement
    expr3;
}
</code></pre>
<p>except for the behavior of <code>continue</code>, which is described in [Section
@sec:break-continue].</p>
<p>Grammatically, the three components of a <code>for</code> loop are expressions. Most
commonly, <em>expr1</em> and <em>expr3</em> are assignments or function calls and <em>expr2</em> is
a relational expression. Any of the three parts can be omitted, although the
semicolons must remain. If <em>expr1</em> or <em>expr3</em> is omitted, it is simply dropped
from the expansion. If the test, <em>expr2</em>, is not present, it is taken as
permanently true, so</p>
<pre><code class="language-c">for (;;) {
    ...
}
</code></pre>
<p>is an “infinite” loop, presumably to be broken by other means, such as a
<code>break</code> or <code>return</code>.</p>
<p>Whether to use <code>while</code> or <code>for</code> is largely a matter of personal preference. For
example, in</p>
<pre><code class="language-c">while ((c = getchar()) == ' ' || c == '\n' || c == '\t')
    ;   /* skip white space characters */
</code></pre>
<p>there is no initialization or re-initialization, so the <code>while</code> is most
natural.</p>
<p>The <code>for</code> is preferable when there is a simple initialization and increment,
since it keeps the loop control statements close together and visible at the
top of the loop. This is most obvious in</p>
<pre><code class="language-c">for (i = 0; i &lt; n; i++)
    ...
</code></pre>
<p>which is the C idiom for processing the first <code>n</code> elements of an array, the
analog of the Fortran <code>DO</code> loop or the Pascal <code>for</code>. The analogy is not
perfect, however, since the index and limit of a C <code>for</code> loop can be altered
from within the loop, and the index variable <code>i</code> retains its value when the
loop terminates for any reason. Because the components of the <code>for</code> are
arbitrary expressions, <code>for</code> loops are not restricted to arithmetic
progressions. Nonetheless, it is bad style to force unrelated computations into
the initialization and increment of a <code>for</code>, which are better reserved for loop
control operations.</p>
<p>As a larger example, here is another version of <code>atoi</code> for converting a string
to its numeric equivalent. This one is slightly more general than the one in
[Chapter @sec:types-ops-expressions]; it copes with optional leading white
space and an optional <code>+</code> or <code>-</code> sign. ([Chapter @sec:functions] shows <code>atof</code>,
which does the same conversion for floating-point numbers.)</p>
<p>The structure of the program reflects the form of the input:</p>
<pre><code>skip white space, if any
get sign, if any
get integer part and convert it
</code></pre>
<p>Each step does its part, and leaves things in a clean state for the next. The
whole process terminates on the first character that could not be part of a
number.</p>
<pre><code class="language-c">#include &lt;ctype.h&gt;

/* atoi:  convert s to integer; version 2 */
int atoi(char s[])
{
    int i, n, sign;

    for (i = 0; isspace(s[i]); i++)  /* skip white space */
        ;
    sign = (s[i] -- '-') ? -1 : 1;
    if (s[i] == '+' || s[i] == '-')  /* skip sign */
        i++;
    for (n = 0; isdigit(s[i]); i++)
        n = 10 * n + (s[i] - '0');
    return sign * n;
}
</code></pre>
<p>The standard library provides a more elaborate function <code>strtol</code> for conversion
of strings to long integers; see [Section @sec:stdlib].</p>
<p>The advantages of keeping loop control centralized are even more obvious when
there are several nested loops. The following function is a Shell sort for
sorting and array of integers. The basic idea of this sorting algorithm, which
was invented in 1959 by D. L. Shell, is that in early stages, far-apart
elements are compared, rather than adjacent ones as in simpler interchange
sorts. This tends to eliminate large amounts of disorder quickly, so later
stages have less work to do. The interval between compared elements is
gradually decreased to one, at which point the soft effectively becomes an
adjacent interchange method.</p>
<pre><code class="language-c">/* shellsort:  sort v[0]...v[n-1] into increasing order */
void shellsort(int v[], int n)
{
    int gap, i, j, temp;

    for (gap = n/2; gap &gt; 0; gap /= 2)
        for (i = gap; i &lt; n' i++)
            for (j=i-gap; j&gt;=0 &amp;&amp; v[j]&gt;v[j+gap]; j-=gap) {
                temp = v[j];
                v[j] = v[j+gap];
                v[j+gap] = temp;
            }
}
</code></pre>
<p>There are three nested loops. The outermost controls the gap between compared
elements, shrinking it form <code>n/2</code> by a factor of two each pass until it becomes
zero. The middle loop steps along the elements. The innermost loop compares
each par of elements that is separated by <code>gap</code> and reverses any that are out
of order. Since <code>gap</code> is eventually reduced to one, all elements are eventually
ordered correctly. Notice how the generality of the <code>for</code> makes the outer loop
fir the same form as the others, even though it is not an arithmetic
progression.</p>
<p>One final C operator is the comma “<code>,</code>” which most often finds use in the <code>for</code>
statement. A pair of expressions separated by a comma is evaluated left to
right, and the type and value of the result are the type and value of the right
operand. Thus in a <code>for</code> statement, it is possible to place multiple expression
in the various parts, for example to process two indices in parallel. This is
illustrated in the function <code>reverse(s)</code>, which reverses the string <code>s</code> in
place.</p>
<pre><code class="language-c">#include &lt;string.h&gt;

/* reverse:  reverse string s in place */
void reverse(char s[])
{
    int c, i, j;

    for (i = 0, j = strlen(s)-1; i &lt; j; i++, j--) {
        c = s[i];
        s[i] = s[j];
        s[j] = c;
    }
}
</code></pre>
<p>The commas that separate function arguments, variables in declarations, etc.,
are <em>not</em> comma operators, and do not guarantee left to right evaluation.</p>
<p>Comma operators should be used sparingly. The most suitable uses are for
constructs strongly related to each other, as in the <code>for</code> loop in <code>reverse</code>,
and in macros where a multistep computation has to be a single expression. A
comma expression might also be appropriate for the exchange of elements in
<code>reverse</code>, where the exchange can be thought of as a single operation:</p>
<pre><code class="language-c">for (i = 0, j = strlen(s)-1; i &lt; j; i++, j--)
    c = s[i], s[i] = s[j], s[j] = c;
</code></pre>
<p><strong>Exercise 3-3.</strong> Write a function <code>expand(s1,s2)</code> that expands shorthand
notations like <code>a-z</code> in the string <code>s1</code> into equivalent complete list
<code>abc...xyz</code> in <code>s2</code>. Allow for letters of either case and digits, and be
prepared to handle cases like <code>a-b-c</code> and <code>a-z0-9</code> and <code>-a-z</code>. Arrange that a
leading or trailer <code>-</code> is taken literally.</p>
<h2>Loops—Do-while {#sec:do-while}</h2>
<p>As we discussed in [Chapter @sec:introduction], the <code>while</code> and <code>for</code> loops
test the termination condition at the top. By contrast, the third loop in C,
the <code>do</code>-<code>while</code>, tests at the bottom <em>after</em> making each pass through the loop
body; the body is always executed at least once.</p>
<p>The syntax of the <code>do</code> is</p>
<pre><code class="language-c">do
    statement
while (expression);
</code></pre>
<p>The <em>statement</em> is executed, then <em>expression</em> is evaluated. If it is true,
<em>statement</em> is evaluated again, and so on. When the expression becomes false,
the loop terminates. Except for the sense of the test, <code>do</code>-<code>while</code> is
equivalent to the Pascal <code>repeat</code>-<code>until</code> statement.</p>
<p>Experience shows that <code>do</code>-<code>while</code> is much less used than <code>while</code> and <code>for</code>.
Nonetheless, from time to time it is valuable, as in the following function
<code>itoa</code>, which converts a number to a character string (the inverse of <code>atoi</code>).
The job is slightly more complicated than might be thought at first, because
the easy methods of generating the digits generate them in the wrong order. We
have chosen to generate the string backwards, then reverse it.</p>
<pre><code class="language-c">/* itoa:  convert n to characters in s */
void itoa(int n, char s[])
{
    int i, sign;

    if ((sign = n) &lt; 0)  /* record sign */
        n = -n;          /* make n positive */
    i = 0;
    do {       /* generate digits in reverse order */
        s[i++] = n % 10 + '0';   /* get next digit */
    } while ((n /- 10) &gt; 0);     /* delete it */
    if (sign &lt; 0)
        s[i++] = '-';
    s[i] = '\0';
    reverse(s);
}
</code></pre>
<p>The <code>do</code>-<code>while</code> is necessary, or at least convenient, since at least one
character must be installed in the array <code>s</code>, even if <code>n</code> is zero. We also used
braces around the single statement that makes up the body of the <code>do</code>-<code>while</code>,
even though they are unnecessary, so the hasty reader will not mistake the
<code>while</code> part for the <em>beginning</em> of a <code>while</code> loop.</p>
<p><strong>Exercise 3-4.</strong> In a two’s complement number representation, our version of
<code>itoa</code> does not handle the largest negative number, that is, the value of <code>n</code>
equal to $-(2^{wordsize-1})$. Explain why not. Modify it to print that value
correctly, regardless of the machine on which it runs.</p>
<p><strong>Exercise 3-5.</strong> Write the function <code>itob(n,s,b)</code> that converts the integer
<code>n</code> into a base <code>b</code> character representation in the string <code>s</code>. In particular,
<code>itob(n,s,16)</code> formats <code>n</code> as a hexadecimal integer in <code>s</code>.</p>
<p><strong>Exercise 3-6.</strong> Write a version of <code>itoa</code> that accepts three arguments
instead of two. The third argument is a minimum field width; the converted
number must be padded with blanks on the left if necessary to make it wide
enough.</p>
<h2>Break and Continue {#sec:break-continue}</h2>
<p>It is sometimes convenient to be able to exit from a loop other than by testing
at the top or bottom. The <code>break</code> statement provides an early exit from <code>for</code>,
<code>while</code>, and <code>do</code>, just as from <code>switch</code>. A <code>break</code> causes the innermost
enclosing loop or <code>switch</code> to be exited immediately.</p>
<p>The following function, <code>trim</code>, removes trailing blanks, tabs, and newlines
from the end of a string, using a <code>break</code> to exit from a loop when the
rightmost non-blank, non-tab, non-newline is found.</p>
<pre><code class="language-c">/* trim:  remove trailing blanks, tabs, newlines */
int trim(char s[])
{
    int n;

    for (n = strlen(s)-1; n&gt;= 0; n--)
        if (s[n] != ' ' &amp;&amp; s[n] != '\t' &amp;&amp; s[n] != '\n')
            break;
    s[n+1] = '\0';
    return n;
}
</code></pre>
<p><code>strlen</code> returns the length of the string. The <code>for</code> loop starts at the end and
scans backwards looking for the first character that is not a blank or tab or
newline. The loop is broken when one is found, or when <code>n</code> becomes negative
(that is, when the entire string has been scanned). You should verify that this
is correct behavior even when the string is empty or contains only white space
characters.</p>
<p>The <code>continue</code> statement is related to <code>break</code>, but less often used; it causes
the next iteration of the enclosing <code>for</code>, <code>while</code>, or <code>do</code> loop to begin. In
the <code>while</code> and <code>do</code>, this means that the test part is executed immediately; in
the <code>for</code>, control passes to the increment step. The <code>continue</code> statement
applies only to loops, not to <code>switch</code>. A <code>continue</code> inside a <code>switch</code> inside a
loop causes the next loop iteration.</p>
<p>As an example, this fragment processes only the non-negative elements in the
array <code>a</code>; negative values are skipped.</p>
<pre><code class="language-c">for (i = 0; i &lt; n; i++) {
    if (a[i] &lt; 0)   /* skip negative elements */
        continue;
    ... /*do positive elements */
}
</code></pre>
<p>The <code>continue</code> statement is often used when the part of the loop that follows
is complicated, so that reversing a test and indenting another level would nest
the program too deeply.</p>
<h2>Goto and Labels</h2>
<p>C provides the infinitely-abusable <code>goto</code> statement, and labels to branch to.
Formally, the <code>goto</code> is never necessary, and in practice it is almost always
easy to write code without it. We have not used <code>goto</code> in this book.</p>
<p>Nevertheless, there are a few situations where <code>goto</code>s may find a place. The
most common is to abandon processing in some deeply nested structure, such as
breaking out of two or more loops at once. The <code>break</code> statement cannot be used
directly since it only exits from the innermost loop. Thus:</p>
<pre><code class="language-c">for (...)
    for (...) {
        ...
        if (disaster)
            goto error;
    }
...
error:
    clean up the mess
</code></pre>
<p>This organization is handy if the error-handling code is non-trivial, and if
errors can occur in several places.</p>
<p>A label has the same form as a variable name, and is followed by a colon. It
can be attached to any statement in the same function as the <code>goto</code>. The scope
of a label is the entire function.</p>
<p>As another example, consider the problem of determining whether two arrays <code>a</code>
and <code>b</code> have an element in common. One possibility is</p>
<pre><code class="language-c">for (i = 0; i &lt; n; i++)
    for (j = 0; j &lt; m; j++)
        if (a[i] == b[j])
            goto found;
/* didn't find any common element */
...
found:
    /* got one:  a[i] == b[j] */
    ...
</code></pre>
<p>Code involving a <code>goto</code> can always be written without one, though perhaps at
the price of some repeated tests or an extra variable. For example, the array
search becomes</p>
<pre><code class="language-c">found = 0;
for (i = 0; i &lt; n &amp;&amp; !found; i++)
    for (j = 0; j &lt; m &amp;&amp; !found; j++)
        if (a[i] == b[j])
            found = 1;
if (found)
    /* got one:  a[i=1] == b[j-1] */
    ...
else
    /* didn't find any common element */
    ...
</code></pre>
<p>With a few exceptions like those cited here, code that relies on <code>goto</code>
statements is generally harder to understand and to maintain than code without
<code>goto</code>s. Although we are not dogmatic about the matter, it does seem that
<code>goto</code> statements should be used rarely, if at all.</p>
<h1>Functions and Program Structure {#sec:functions}</h1>
<p>Functions break large computing tasks into smaller ones, and enable people to
build on what others have done instead of starting over from scratch.
Appropriate functions hide details of operation from parts of the program that
don’t need to know about them, thus clarifying the whole, and easing the pain
of making changes.</p>
<p>C has been designed to make functions efficient and easy to use; C programs
generally consist of many small functions rather than a few big ones. A program
may reside in one or more source files. Source files may be compiled separately
and loaded together, along with previously compiled functions from libraries.
We will not go into that process here, however, since the details vary from
system to system.</p>
<p>Function declaration and definition is the area where the ANSI standard has
made the most visible changes to C. As we saw first in [Chapter
@sec:introduction], it is now possible to declare the types of arguments when a
function is declared. The syntax of function definition also changes, so that
declarations and definitions match. This makes it possible for a compiler to
detect many more errors than it could before. Furthermore, when arguments are
properly declared, appropriate type coercions are performed automatically.</p>
<p>The standard clarifies the rules on the scope of names; in particular, it
requires that there be only one definition of each external object.
Initialization is more general: automatic arrays and structures may now be
initialized.</p>
<p>The C preprocessor has also been enhanced. New preprocessor facilities include
a more complete set of conditional compilation directives, a way to create
quoted strings from macro arguments, and better control over the macro
expansion process.</p>
<h2>Basics of Functions</h2>
<p>To begin, let us design and write a program to print each line of its input
that contains a particular “pattern” or string of characters. (This is a
special case of the UNIX program <code>grep</code>.) For example, searching for the
pattern of letters “<code>ould</code>” in the set of lines</p>
<pre><code>Ah Love! could you and I with Fate conspire
To grasp this sorry Scheme of Things entire,
Would not we shatter it to bits -- and then
Re-mould it nearer to the Heart's Desire!
</code></pre>
<p>will produce the output</p>
<pre><code>Ah Love! could you and I with Fate conspire
Would not we shatter it to bits -- and then
Re-mould it nearer to the Heart's Desire!
</code></pre>
<p>The job falls neatly into three pieces:</p>
<pre><code class="language-c">while (there's another line)
    if (the line contains the pattern)
        print it
</code></pre>
<p>Although it’s certainly possible to put the code for all of this in <code>main</code>, a
better way is to use the structure to advantage by making each part a separate
function. Three small pieces are easier to deal with than one big one, because
irrelevant details can be buried in the functions, and the chance of unwanted
interactions is minimized. And the pieces may even be useful in other programs.</p>
<p>“While there’s another line” is <code>getline</code>, a function that we wrote in [Chapter
@sec:introduction], and “print it” is <code>printf</code>, which someone has already
provided for us. This means we need only write a routine to decide whether the
line contains an occurrence of the pattern.</p>
<p>We can solve that problem by writing a function <code>strindex(s,t)</code> that returns
the position or index in the string <code>s</code> where the string <code>t</code> begins, or <code>-1</code> if
<code>s</code> doesn’t contain <code>t</code>. Because C arrays begin at position zero, indexes will
be zero or positive, and so a negative value like <code>-1</code> is convenient for
signaling failure. When we later need more sophisticated pattern matching, we
only have to replace <code>strindex</code>; the rest of the code can remain the same. (The
standard library provides a function <code>strstr</code> that is similar to <code>strindex</code>,
except that it returns a pointer instead of an index.)</p>
<p>Given this much design, filling in the details of the program is
straightforward. Here is the whole thing, so you can see how the pieces fit
together. For now, the pattern to be searched for is a lateral string, which is
not the most general of mechanisms. We will return shortly to a discussion of
how to initialize character arrays, and in [Chapter @sec:pointers] will show
how to make the pattern a parameter that is set when the program is run. There
is also a slightly different version of <code>getline</code>; you might find it
instructive to compare it to the one in [Chapter @sec:introduction].</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#define MAXLINE 1000    /* maximum input line length */

int getline(char line[], int max);
int strindex(char source[], char searchfor[]);

char pattern[] = &quot;ould&quot;;    /* pattern to search for */

/* find all lines matching pattern */
main()
{
    char line[MAXLINE];
    int found = 0;

    while (getline(line, MAXLINE) &gt;0)
        if (strindex(line, pattern) &gt;= 0) {
            printf(&quot;%s&quot;, line);
            found++;
        }
    return found;
}

/* getline:  get line into s, return length */
int getline(char s[], int lim)
{
    int c, i;

    i = 0;
    whille (--lim &gt; 0 &amp;&amp; (c=getchar()) != EOF &amp;&amp; c != '\n')
        s[i++] = c;
    if (c == '\n')
        s[i++] = c;
    s[i] = '\0';
    return i;
}

/* strindex:  return index of t in s, -1 if none */
int strindex(char s[], char t[])
{
    int i, j, k;

    for (i = 0; s[i] != '\0'; i++) {
        for (j=i, k=0; t[k]!='\0' &amp;&amp; s[j]==t[k]; j++, k++)
            ;
        if (k &gt; 0 &amp;&amp; t[k] == '\0')
            return i;
    }
    return -1;
}
</code></pre>
<p>Each function definition has the form</p>
<pre><code class="language-c">return-type function-name(argument declarations)
{
    declarations and statements
}
</code></pre>
<p>Various parts may be absent; a minimal function is</p>
<pre><code class="language-c">dummy() {}
</code></pre>
<p>which does nothing and returns nothing. A do-nothing function like this is
sometimes useful as a place holder during program development. If the return
type is omitted, <code>int</code> is assumed.</p>
<p>A program is just a set of definitions of variables and functions.
Communication between the functions is by arguments and values returned by the
functions, and through external variables. The functions can occur in any order
in the source file, and the source program can be split into multiple files, so
long as no function is split.</p>
<p>The <code>return</code> statement is the mechanism for returning a value from the called
function to its caller. Any expression can follow <code>return</code>:</p>
<pre><code class="language-c">return expression;
</code></pre>
<p>The <em>expression</em> will be converted to the return type of the function if
necessary. Parentheses are often used around the <em>expression</em>, but they are
optional.</p>
<p>The calling function is free to ignore the returned value. Furthermore, there
need be no expression after <code>return</code>; in that case, no value is returned to the
caller. Control also returns to the caller with no value when execution “falls
off the end” of the function by reaching the closing right brace. It is not
illegal, but probably a sign of trouble, if a function returns a value from one
place and no value from another. In any case, if a function fails to return a
value, its “value” is certain to be garbage.</p>
<p>The pattern-searching program returns a status from <code>main</code>, the number of
matches found. This value is available for use by the environment that called
the program.</p>
<p>The mechanics of how to compile and load a C program that resides on multiple
source files vary from one system to the next. On the UNIX system, for example,
the <code>cc</code> command mentioned in [Chapter @sec:introduction] does the job. Suppose
that the three functions are stored in three files called <code>main.c</code>,
<code>getline.c</code>, and <code>strindex.c</code>. Then the command</p>
<pre><code class="language-sh">cc main.c getline.c strindex.c
</code></pre>
<p>compiles the three files, placing the resulting object code in files <code>main.o</code>,
<code>getline.o</code>, and <code>strindex.o</code>, then loads them all into an executable file
called <code>a.out</code>. If there is an error, say in <code>main.c</code>, that file can be
recompiled by itself and the result loaded with the previous object files, with
the command</p>
<pre><code class="language-sh">cc main.c getline.o strindex.o
</code></pre>
<p>The <code>cc</code> command uses the “<code>.c</code>” versus “<code>.o</code>” naming convention to distinguish
source files from object files.</p>
<p><strong>Exercise 4-1.</strong> Write the function <code>strrindex(s,t)</code>, which returns the
position of the <em>rightmost</em> occurrence of <code>t</code> in <code>s</code>, or <code>-1</code> if there is none.</p>
<h2>Functions Returning Non-integers</h2>
<p>So far our examples of functions have returned either no value (<code>void</code>) or an
<code>int</code>. What if a function must return some other type? Many numerical functions
like <code>sqrt</code>, <code>sin</code>, and <code>cos</code> return <code>double</code>; other specialized functions
return other types. To illustrate how to deal with this, let us write and use
the function <code>atof(s)</code>, which converts the string <code>s</code> to its double-precision
floating-point equivalent. <code>atof</code> is an extension of <code>atioi</code>, which we have
showed versions of in [Chapters @sec:types-ops-expressions; and
@sec:control-flow]. It handles an optional sign and decimal point, and the
presence or absence of either integer part or fractional part. Our version is
<em>not</em> a high-quality input conversion routine; that would take more space than
we care to use. The standard library includes an <code>atof</code>; the header
<code>&lt;stdlib.h&gt;</code> declares it.</p>
<p>First, <code>atof</code> itself must declare the type of value it returns, since it is not
<code>int</code>. The type name precedes the function name:</p>
<pre><code class="language-c">#include &lt;ctype.h&gt;

/* atof:  convert string s to double */
double atof(char s[])
{
    double val, power;
    int i, sign;

    for (i = 0; isspace(s[i]); i++)  /* skip white space */
        ;
    sign = (s[i] == '-') ? -1 : 1;
    if (s[i] == '+' || s[i] == '-')
        i++;
    for (val = 0.0; isdigit(s[i]); i++)
        val = 10.0 * val + (s[i] - '0');
    if (s[i] == '.')
        i++;
    for (power = 1.0; isdigit(s[i]); i++) {
        val = 10.0 * val + (s[i] - '0');
        power *= 10.0;
    }
    return sign * val / power;
}
</code></pre>
<p>Second, and just as important, the calling routine must know that <code>atof</code>
returns a non-<code>int</code> value. One way to ensure this is to declare <code>atof</code>
explicitly in the calling routine. The declaration is shown in this primitive
calculator (barely adequate for check-book balancing), which reads one number
per line, optionally preceded by a sign, and adds them up, printing the running
sum after each input:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define MAXLINE 100

/* rudimentary calculator */
main()
{
    double sum, atof(char[]);
    char line[MAXLINE];
    int getline(char line[], int max);

    sum = 0;
    while (getline(line, MAXLINE) &gt; )
        printf(&quot;\t%g\n&quot;, sum += atof(line));
    return 0;
}
</code></pre>
<p>The declaration</p>
<pre><code class="language-c">double sum, atof(char []);
</code></pre>
<p>says that <code>sum</code> is a <code>double</code> variable, and that <code>atof</code> is a function that
takes one <code>char[]</code> argument and returns a <code>double</code>.</p>
<p>The function <code>atof</code> must be declared and defined consistently. If <code>atof</code> itself
and the call to it in <code>main</code> have inconsistent types in the same source file,
the error will be detected by the compiler. But if (as is more likely) <code>atof</code>
were compiled separately, the mismatch would not be detected, <code>atof</code> would
return a <code>double</code> that <code>main</code> would treat as an <code>int</code>, and meaningless answers
would result.</p>
<p>In the light of what we have said about how declarations must march
definitions, this might seem surprising. The reason a mismatch can happen is
that if there is no function prototype, a function is implicitly declared by
its first appearance in an expression, such as</p>
<pre><code class="language-c">sum += atof(line)
</code></pre>
<p>If a name that has not been previously declared occurs in an expression and is
followed by a left parenthesis, it is declared by context to be a function
name, the function is assumed to return an <code>int</code>, and nothing is assumed about
its arguments. Furthermore, if a function declaration does not include
arguments, as in</p>
<pre><code class="language-c">double atof();
</code></pre>
<p>that too is taken to mean that nothing is to be assumed about the arguments of
<code>atof</code>; all parameter checking is turned off. This special meaning of the empty
argument list is intended to permit older C programs to compile with new
compilers. But it’s a bad idea to use it with new programs. If the function
takes arguments, declare the; if it takes no arguments, use <code>void</code>.</p>
<p>Given <code>atof</code>, properly declared, we could write <code>atoi</code> (convert a string to
<code>int</code>) in terms of it:</p>
<pre><code class="language-c">/* atoi:  convert string s to integer using atof */
int atoi(char s[])
{
    double atof(char s[]);

    return (int) atof(s);
}
</code></pre>
<p>Notice the structure of the declarations and the <code>return</code> statement. The value
of the expression in</p>
<pre><code class="language-c">return expression;
</code></pre>
<p>is converted to the type of the function because the return is taken.
Therefore, the value of <code>atof</code>, a <code>double</code>, is converted automatically to <code>int</code>
when it appears in this <code>return</code>, since the function <code>atoi</code> returns an <code>int</code>.
This operation does potentially discard information, however, so some compilers
warn of it. The cast states explicitly that the operation is intended, and
suppresses any warning.</p>
<p><strong>Exercise 4-2.</strong> Extend <code>atof</code> to handle scientific notation of the form</p>
<pre><code>123.45e-6
</code></pre>
<p>where a floating-point number may be followed by <code>e</code> or <code>E</code> and an optionally
signed exponent.</p>
<h2>External Variables {#sec:extern-vars}</h2>
<p>A C program consists of a set of external objects, which are either variables
or functions. The adjective “external” is used in contrast to “internal,” which
describes the arguments and variables defined inside functions. External
variables are defined outside of any function, and are thus potentially
available to many functions. Functions themselves are always external, because
C does not allow functions to be defined inside other functions. By default,
external variables and functions have the property that all references to them
by the same name, even from functions compiled separately, are references to
the same thing. (The standard calls this property <em>external linkage</em>.) In this
sense, external variables are analogous to Fortran <code>COMMON</code> blocks or variables
in the outermost block in Pascal. We will see later how to define external
variables and functions that are visible only within a single source file.</p>
<p>Because external variables are globally accessible, they provide an alternative
to function arguments and return values for communicating data between
functions. Any function may access an external variable by referring to it by
name, if the name has been declared somehow.</p>
<p>If a large number of variables must be shared among functions, external
variables are more convenient and efficient than long argument lists. As
pointed out in [Chapter @sec:introduction], however, this reasoning should be
applied with some caution, for it can have a bad effect on program structure,
and lead to programs with too many data connections between functions.</p>
<p>External variables are also useful because of their greater scope and lifetime.
Automatic variables are internal to a function; they come into existence when
the function is entered, and disappear when it is left. External variables, on
the other hand, are permanent, so they retain values from one function
invocation to the next. Thus if two functions must share some data, yet neither
calls the other, it is often most convenient if the shared data is kept in
external variables rather than passed in an out via arguments.</p>
<p>Let us examine this issue further with a larger example. The problem is to
write a calculator program that provides the operators <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>.
Because it is easier to implement, the calculator will use reverse Polish
notation instead of infix. (Reverse Polish is used by some pocket calculators,
and in languages like Forth and Postscript.)</p>
<p>In reverse Polish notation, each operator follows its operands; an infix
expression like</p>
<pre><code>
(1 - 2) + (4 + 5)

</code></pre>
<p>is entered as</p>
<pre><code>
1 2 - 4 5 + *

</code></pre>
<p>Parentheses are not needed; the notation is unambiguous as long as we know how
many operands each operator expects.</p>
<p>The implementation is simple. Each operand is pushed onto a stack; when an
operator arrives, the proper number of operands (two for binary operators) is
popped, the operator is applied to them, and the result is pushed back onto the
stack. In the example above, for instance, 1 and 2 are pushed, then replaced by
their difference, -1. Next, 4 and 5 are pushed and then replaced by their sum,
9. The product of -1 and 9, which is -9, replaces them on the stack. The value
on the top of the stack is popped and printed when the end of the input line is
encountered.</p>
<p>The structure of the program is thus a loop that performs the proper operation
on each operator and operand as it appears:</p>
<pre><code>while (next oerator or operand is not end-of-file indicator)
    if (numer)
        push it
    else if (operator)
        pop operands
        do operation
        push result
    else if (newline)
        pop and print top of stack
    else
        error
</code></pre>
<p>The operations of pushing and popping a stack are trivial, but by the time
error detection and recovery are added, they are long enough that it is better
to put each in a separate function than to repeat the code throughout the whole
program. And there should be a separate function for fetching the next input
operator or operand.</p>
<p>The main design decision that has not yet been discussed is where the stack is,
that is, which routines access it directly. One possibility is to keep it in
<code>main</code>, and pass the stack and the current stack position to the routines that
<code>push</code> and <code>pop</code> it. But <code>main</code> doesn’t need to know about the variables that
control the stack; it only does <code>push</code> and <code>pop</code> operations. So we have decided
to store the stack and its associated information in external variables
accessible to the <code>push</code> and <code>pop</code> functions but not to <code>main</code>.</p>
<p>Translating this outline into code is easy enough. If for now we think of the
program as existing in one source file, it will look like this:</p>
<pre><code>#includes
#defines

function declarations for main

main() { ... }


external variables for push and pop

void push(double f) { ... }
double pop(void) { ... }

int getop(char s[]) { ... }


routines called by getop
</code></pre>
<p>Later we will discuss how this might be split into two or more source files.</p>
<p>The function <code>main</code> is a loop containing a big <code>switch</code> on the type of operator
or operand; this is a more typical use of <code>switch</code> than the one shown in
[Section @sec:switch].</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;   /* for atof() */

#define MAXOP   100   /* max size of operand or operator */
#define NUMBER  '0'   /* signal that a number was found */

int getop(char []);
void push(double);
double pop(void);

/* reverse Polish calculator */
main()
{
    int type;
    double op2;
    char s[MAXOP];

    while ((type = getop(s)) != EOF) {
        switch (type) {
        case NUMBER:
            push(atof(s));
            break;
        case '+':
            push(pop() + pop());
            break;
        case '*':
            push(pop() * pop());
            break;
        case '-':
            op2 = pop();
            push(pop() - op2);
            break;
        case '/':
            op2 = pop();
            if (op2 != 0.0)
                push(pop() / op2);
            else
                printf(&quot;error: zero divisor\n&quot;);
            break;
        case '\n':
            printf(&quot;\t%.8g\n&quot;, pop());
            break;
        default:
            printf(&quot;error: unknown command %s\n&quot;, s);
            break;
        }
    }
    return 0;
}
</code></pre>
<p>Because <code>+</code> and <code>*</code> are commutative operators, the order in which the popped
operands are combined is irrelevant, but for <code>-</code> and <code>/</code> the left and right
operands must be distinguished. In</p>
<pre><code class="language-c">
push(pop() - pop());    /* WRONG */

</code></pre>
<p>the order in which the two calls of <code>pop</code> are evaluated is not defined. To
guarantee the right order, it is necessary to pop the first value into a
temporary variable as we did in <code>main</code>.</p>
<pre><code class="language-c">#define MAXVAL  100   /* maximum depth of val stack */

int sp = 0;           /* next free stack position */
double val[MAXVAL];   /* vlue stack */o

/* push:  push f onto value stack */
void push(double f)
{
    if (sp &lt; MAXVAL)
        val[sp++] = f;
    else
        printf(&quot;error: stack full, can't push %g\n&quot;, f);
}



/* pop:  pop and return top values from stack */
double pop(void)
{
    if (sp &gt; 0)
        return val[--sp];
    else {
        printf(&quot;error: stack empty\n&quot;);
        return 0.0;
    }
}
</code></pre>
<p>A variable is external if it is defined outside of any function. Thus the stack
and stack index that must be shared by <code>push</code> and <code>pop</code> are defined outside of
these functions. But <code>main</code> itself does not refer to the stack or stack
position—the representation can be hidden.</p>
<p>Let us now turn to the implementation of <code>getop</code>, the function that fetches the
next operator or operand. The task is easy. Skip blanks and tabs. If the next
character is not a digit or a decimal point, return it. Otherwise, collect a
string of digits (which might include a decimal point), and return <code>NUMBER</code>,
the signal that a number has been collected.</p>
<pre><code class="language-c">#include &lt;ctype.h&gt;

int getch(void);
void ungetch(int);

/* getop:  get next operator or nmeric operand */
int getop(char s[])
{
    int i, c;

    while ((s[0] = c = getch()) == ' ' || c == '\t')
        ;
    s[1] = '\0';
    if (!isdigit(c) &amp;&amp; c != '.')
        return c;     /* not a number */
    i = 0;
    if (isdigit(c))   /* collect integer part */
        while (isdigit(s[++o] = c = getch()))
            ;
    if (c == '.')     /* collect fraction part */
        while (isdigit(s[++i] = c = getch()))
            ;
    s[i] = '\0';
    if (c != EOF)
        ungetch(c);
    return NUMBER;
}
</code></pre>
<p>What are <code>getch</code> and <code>ungetch</code>? It is often the case that a program cannot
determine that it has read enough input until it has read too much. One
instance is collecting the characters that make up a number: until the first
non-digit is seen, the number is not complete. But then the program has read
one character too far, a character that it is not prepared for.</p>
<p>The problem would be solved if it were possible to “un-read” the unwanted
character. Then, every time the program reads one character too many, it could
push it back on the input, so the rest of the code could behave as if it had
never been read. Fortunately, it’s easy to simulate un-getting a character, by
writing a pair of cooperating functions. <code>getch</code> delivers the next input
character to be considered; <code>ungetch</code> remembers the characters put back on the
input, so that subsequent calls to <code>getch</code> will return them before reading new
input.</p>
<p>How they work together is simple. <code>ungetch</code> puts the pushed-back characters
into a shared buffer—a character array. <code>getch</code> reads from the buffer if
there is anything there, and calls <code>getchar</code> if the buffer is empty. There must
also be an index variable that records the position of the current character in
the buffer.</p>
<p>Since the buffer and the index are shared by <code>getch</code> and <code>ungetch</code> and must
retain their values between calls, they must be external to both routines. Thus
we can write <code>getch</code>, <code>ungetch</code>, and their shared variables as:</p>
<pre><code class="language-c">#define BUFSIZE 100

char buf[BUFSIZE];  /* buffer for ungetch */
int  bufp = 0;      /* next free position in buf */

int getch(void) /* get a (possibly pushed back) character */
{
    return (bufp &gt; 0) ? buf[--bufp] : getchar();
}

void ungetch(int c) /* push character back on input */
{
    if (bufp &gt;= BUFSIZE)
        printf(&quot;ungetch: too many characters\n&quot;);
    else
        buf[bufp++] = c;
}
</code></pre>
<p>The standard library includes a function <code>ungetc</code> that provides one character
of pushback; we will discuss it in [Chapter @sec:IO]. We have used an array for
the pushback, rather than a single character, to illustrate a more general
approach.</p>
<p><strong>Exercise 4-3.</strong> Given the basic framework, it’s straightforward to extent the
calculator. Add the modulus(<code>%</code>) operator and provisions for negative numbers.</p>
<p><strong>Exercise 4-4.</strong> Add commands to print the top element of the stack without
popping, to duplicate it, and to swap the two elements. Add a command to clear
the stack.</p>
<p><strong>Exercise 4-5.</strong> Add access to library functions like <code>sin</code>, <code>exp</code>, and <code>pow</code>.
See <code>&lt;math.h&gt;</code> in [Section @sec:math].</p>
<p><strong>Exercise 4-6.</strong> Add commands for handling variables. (It’s easy to provide
twenty-six variables with single-letter names.) Add a variable for the most
recently printed value.</p>
<p><strong>Exercise 4-7.</strong> Write a routine <code>ungets(s)</code> that will push back an entire
string onto the input. Should <code>ungets</code> know about <code>buf</code> and <code>bufp</code>, or should
it just use <code>ungetch</code>?</p>
<p><strong>Exercise 4-8.</strong> Suppose that there will never be more than one character of
pushback. Modify <code>getch</code> and <code>ungetch</code> accordingly.</p>
<p><strong>Exercise 4-9.</strong> Out <code>getch</code> and <code>ungetch</code> do not handle a pushed-back <code>EOF</code>
correctly. Decide what their properties ought to be if an <code>EOF</code> is pushed back,
then implement your design.</p>
<p><strong>Exercise 4-10.</strong> An alternate organization uses <code>getline</code> to read an entire
input line; this makes <code>getch</code> and <code>ungetch</code> unnecessary. Revise the calculator
to use this approach.</p>
<h2>Scope Rules</h2>
<p>The functions and external variables that make up a C program need not all be
compiled at the same time; they source text of the program may be kept in
several files, and previously compiled routines may be loaded from libraries.
Among the questions of interest are</p>
<ul>
<li>How are declarations written so that variables are properly declared during
compilation?</li>
<li>How are declarations arranged so that all the pieces will be properly
connected when the program is loaded?</li>
<li>How are declarations organized so there is only one copy?</li>
<li>How are external variables initialized?</li>
</ul>
<p>Let us discuss these topics by reorganizing the calculator program into several
files. As a practical matter, the calculator is too small to be worth
splitting, but it is a fine illustration of the issues that arise in larger
programs.</p>
<p>The <em>scope</em> of a name is the part of the program within which the name can be
used. For an automatic variable declared at the beginning of a function, the
scope is the function in which the name is declared. Local variables of the
same name in different functions are unrelated. The same is true of the
parameters of the function, which are in effect local variables.</p>
<p>The scope of an external variable or a function lasts form the point at which
it is declared to the end of the file being compiled. For example, if <code>main</code>,
<code>sp</code>, <code>val</code>, <code>push</code>, and <code>pop</code> are defined in one file, in the order shown
above, that is,</p>
<pre><code class="language-c">main() { ... }

int sp = 0;
double val[MAXVAL];

void push(double f) { ... }

double pop(void) { ... }
</code></pre>
<p>then the variables <code>sp</code> and <code>val</code> may be used in <code>push</code> and <code>pop</code> simply by
naming them; no further declarations are needed. But these names are not
visible in <code>main</code>, nor are <code>push</code> and <code>pop</code> themselves.</p>
<p>On the other hand, if an external variable is to be referred to before it is
defined, or if it is defined in a different source file from the one where it
is being used, then an <code>extern</code> declaration is mandatory.</p>
<p>It is important to distinguish between the <em>declaration</em> of an external
variable and its <em>definition</em>. A declaration announces the properties of a
variable (primarily its type); a definition also causes storage to be set
aside. If the lines</p>
<pre><code class="language-c">int sp;
double val[MAXVAL];
</code></pre>
<p>appear outside of any function, they <em>define</em> the external variables <code>sp</code> and
<code>val</code>, cause storage to be set aside, and also serve as the declaration for the
rest of that source file. On the other hand, the lines</p>
<pre><code class="language-c">extern int sp;
extern double val[];
</code></pre>
<p><em>declare</em> for the rest of the source file that <code>sp</code> is an <code>int</code> and that <code>val</code>
is a <code>double</code> array (whose size is determined elsewhere), but they do not
create the variables or reserve storage for them.</p>
<p>There must be only one <em>definition</em> of an external variable among all the files
that make up the source program; other files may contain <code>extern</code> declarations
to access it. (There may also be <code>extern</code> declarations in the file containing
the definition.) Array sizes must be specified with the definition, but are
optional with an <code>extern</code> declaration.</p>
<p>Initialization of an external variable goes only with the definition.</p>
<p>Although it is not a likely organization for this program, the functions <code>push</code>
and <code>pop</code> could be defined in one file, and the variables <code>val</code> and <code>sp</code>
defined and initialized in another. Then these definitions and declarations
would be necessary to tie them together:</p>
<p><em>In file1:</em></p>
<pre><code class="language-c">extern int sp;
extern double val[];

void push(double f) { ... }

double pop(void) { ... }
</code></pre>
<p><em>In file2:</em></p>
<pre><code class="language-c">int sp = 0;
double val[MAXVAL];
</code></pre>
<p>Because the <code>extern</code> declarations in <em>file1</em> lie ahead of and outside the
function definitions, they apply to all functions; one set of declarations
suffices for all of <em>file1</em>. This same organization would also be needed if the
definitions of <code>sp</code> and <code>val</code> followed their use in one file.</p>
<h2>Header Files</h2>
<p>Let us not consider dividing the calculator program into several source files,
as it might be if each of the components were substantially bigger. The <code>main</code>
function would go in one file, which we will call <code>main.c</code>; <code>push</code>, <code>pop</code>, and
their variables go into a second file, <code>stack.c</code>; <code>getop</code> goes into a third,
<code>getop.c</code>. Finally, <code>getch</code> and <code>ungetch</code> go into a fourth file, <code>getch.c</code>; we
separate them from the others because they would come from a
separately-compiled library in a realistic program.</p>
<p>There is one more thing to worry about—the definitions and declarations
shared among the files. As much as possible, we want to centralize this, so
that there is only one copy to get right and keep right as the program evolves.
Accordingly, we will place this common material in a <em>header file</em>, <code>calc.h</code>,
which will be included as necessary. (The <code>#include</code> line is described in
[Section @sec:preprocessor].) The resulting program then looks like this:</p>
<pre><code>            calc.h
            +---------------------+
            | #define NUMBER '0'  |
            | void push(double);  |
            | double pop(void);   |
            | int getop(char []); |
            | int getch(void);    |
            | void ungetch(int);  |
            +---------------------+

main.c:                  getop.c:
+---------------------+  +--------------------+
| #include &lt;stdio.h&gt;  |  | #include &lt;stdio.h&gt; |
| #include &lt;stdlib.h&gt; |  | #include &lt;ctype.h&gt; |
| #include &quot;calc.h&quot;   |  | #include &quot;calc.h&quot;  |
| #define MAXOP 100   |  | getop() {          |
| main() {            |  |     ...            |
|     ...             |  | }                  |
| }                   |  +--------------------+
+---------------------+

stack.c:                 getch.c:
+---------------------+  +---------------------+
| #include &lt;stdio.h&gt;  |  | #include &lt;stdio.h&gt;  |
| #include &quot;calc.h&quot;   |  | #define BUFSIZE 100 |
| #define MAXVAL 100  |  | char buf[BUFSIZE];  |
| int sp = 0;         |  | int bufp = 0;       |
| double val[MAXVAL]; |  | int getch(void) {   |
| void push(double) { |  |     ...             |
|     ...             |  | }                   |
| }                   |  | void ungetch(int) { |
| double pop(void) {  |  |     ...             |
|     ...             |  | }                   |
| }                   |  +---------------------+
+---------------------+
</code></pre>
<p>There is a tradeoff between the desire that each file have access only to the
information it needs for its job and the practical reality that it is harder to
maintain more header files. Up to some moderate program size, it is probably
best to have one header file that contains everything that is to be shared
between any two parts of the program; that is the decision we made here. For a
much larger program, more organization and more headers would be needed.</p>
<h2>Static Variables</h2>
<p>The variables <code>sp</code> and <code>val</code> in <code>stack.c</code>, and <code>buf</code> and <code>bufp</code> in <code>getch.c</code>,
are for the private use of the functions in their respective source files, and
are not meant to be accessed by anything else. The <code>static</code> declaration,
applied to an external variable or function, limits the scope of that object to
the rest of the source file being compiled. External <code>static</code> thus provides a
way to hide names like <code>buf</code> and <code>bufp</code> in the <code>getch</code>-<code>ungetch</code> combination,
which must be external so they can be shared, yet which should not be visible
to users of <code>getch</code> and <code>ungetch</code>.</p>
<p>Static storage is specified by prefixing the normal declaration with the word
<code>static</code>. If the two routines and the two variables are compiled in one file,
as in</p>
<pre><code class="language-c">static char buf[BUFSIZE];  /* buffer for ungetch */
static int  bufp = 0;      /* next free position in buf */

int getch(void) { ... }

void ungetch(int c) { ... }
</code></pre>
<p>then no other routine will be able to access <code>buf</code> and <code>bufp</code>, and those names
will not conflict with the same names in other files of the same program. In
the same way, the variables that <code>push</code> and <code>pop</code> use for stack manipulation
can be hidden, by declaring <code>sp</code> and <code>val</code> to be <code>static</code>.</p>
<p>The external <code>static</code> declaration is most often used for variables, but it can
be applied to functions as well. Normally, function names are global, visible
to any part of the entire program. If a function is declared <code>static</code>, however,
its name is invisible outside of the file in which it is declared.</p>
<p>The <code>static</code> declaration can also be applied to internal variables. Internal
<code>static</code> variables are local to a particular function just as automatic
variables are, but inlike automatics, they remain in existence rather than
coming and going each time the function is activated. This means that internal
<code>static</code> variables provide private, permanent storage within a single function.</p>
<p><strong>Exercise 4-11.</strong> Modify <code>getop</code> so that it doesn’t need to use <code>ungetch</code>.
Hint: use an internal <code>static</code> variable.</p>
<h2>Register Variables</h2>
<p>A <code>register</code> declaration advises the compiler that the variable in question
will be heavily used. The idea is that <code>register</code> variables are to be placed in
machine registers, which may result in smaller and faster programs. But
compilers are free to ignore the advice.</p>
<p>The <code>register</code> declaration looks like</p>
<pre><code class="language-c">register int  x;
register char c;
</code></pre>
<p>and so on. The <code>register</code> declaration can only be applied to automatic
variables and to the formal parameters of a function. In this latter case, it
looks like</p>
<pre><code class="language-c">f(register unsigned m, register long n)
{
    register i;
    ...
}
</code></pre>
<p>In practice, there are restrictions on register variables, reflecting the
realities of underlying hardware. Only a few variables in each function may be
kept in register, and only certain types are allowed. Excess register
declarations are harmless, however, since the word <code>register</code> is ignored for
excess or disallowed declarations. And it is not possible to take the address
of a register variable (a topic to be covered in [Chapter @sec:pointers]),
regardless of whether the variable is actually placed in a register. The
specific restrictions on number and types of register variables vary from
machine to machine.</p>
<h2>Block Structure</h2>
<p>C is not a block-structured language in the sense of Pascal or similar
languages, because functions may not be defined within other functions. On the
other hand, variables can be defined in a block-structured fashion within a
function. Declarations of variables (including initializations) may follow the
left brace that introduces <em>any</em> compound statement, not just the one that
begins a function. Variables declared in this way hide any identically named
variables in outer blocks, and remain in existence until the matching right
brace. For example, in</p>
<pre><code class="language-c">if (n &gt; 0) {
    int i;  /* declare a new i */

    for (i = 0; i &lt; n; i++)
        ...
}
</code></pre>
<p>the scope of the variable <code>i</code> is the “<code>true</code>” branch of the <code>if</code>; this <code>i</code> is
unrelated to any <code>i</code> outside the block. An automatic variable declared and
initialized in a block is initialized each time the block is entered. A
<code>static</code> variable is initialized only the first time the block is entered.</p>
<p>Automatic variables, including formal parameters, also hide external variables
and functions of the same name. Given the declarations</p>
<pre><code class="language-c">int x;
int y;

f(double x)
{
    double y;
    ...
}
</code></pre>
<p>then within the function <code>f</code>, occurrences of <code>x</code> refer to the parameter, which
is a <code>double</code>; outside of <code>f</code>, they refer to the external <code>int</code>. The same is
true of the variable <code>y</code>.</p>
<p>As a matter of style, it’s best to avoid variable names that conceal names in
an outer scope; the potential for confusion and error is too great.</p>
<h2>Initialization</h2>
<p>Initialization has been mentioned in passing many times so far, but always
peripherally to some other topic. This section summarizes some of the rules,
now that we have discussed the various storage classes.</p>
<p>In the absence of explicit initialization, external and static variables are
guaranteed to be initialized to zero; automatic and register variables have
undefined (i.e., garbage) initial values.</p>
<p>Scalar variables may be initialized when they are defined, by following the
name with an equals sign and an expression:</p>
<pre><code class="language-c">int x = 1;
char squote = '\'';
long day = 1000L * 60L * 60L * 24L;  /* milliseconds/day */
</code></pre>
<p>For external and static variables, the initializer must be a constant
expression; the initialization is done once, conceptually before the program
begins execution. For automatic and register variables, it is done each time
the function or block is entered.</p>
<p>For automatic and register variables, the initializer is not restricted to
being a constant: it may be an expression involving previously defined values,
even function calls. For example, the initializations of the binary search
program in [Section @sec:else-if] could be written as</p>
<pre><code class="language-c">int binsearch(int x, int v[], int n)
{
    int low = 0;
    int high = n - 1;
    int mid;
    ...
}
</code></pre>
<p>instead of</p>
<pre><code class="language-c">int low, high, mid;

low = 0
high = n - 1;
</code></pre>
<p>In effect, initializations of automatic variables are just shorthand for
assignment statements. Which form to prefer is largely a matter of taste. We
have generally used explicit assignments, because initializers in declarations
are harder to see and further away from the point of use.</p>
<p>An array may be initialized by following its declaration with a list of
initializers enclosed in braces and separated by commas. For example, to
initialize an array <code>days</code> with the number of days in each month:</p>
<pre><code class="language-c">int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
</code></pre>
<p>When the size of the array is omitted, the compiler will compute the length by
counting the initializers, of which there are 12 in this case.</p>
<p>If there are fewer initializers for an array than the number specified, the
missing elements will be zero for external, static, and automatic variables. It
is an error to have too many initializers. There is no way to specify
repetition of an initializer, nor to initialize an element in the middle of an
array without supplying all the preceding values as well.</p>
<p>Character arrays are a special case of initialization; a string may be used
instead of the braces and commas notation:</p>
<pre><code class="language-c">char pattern[] = &quot;ould&quot;;
</code></pre>
<p>is a shorthand for the longer but equivalent</p>
<pre><code class="language-c">char pattern[] = { 'o', 'u', 'l', 'd', '\0' };
</code></pre>
<p>In this case, the array size is five (four characters plus the terminating
<code>\0</code>).</p>
<h2>Recursion</h2>
<p>C functions may be used recursively; that is, a function may call itself either
directly or indirectly. Consider printing a number as a character string. As we
mentioned before, the digits are generated in the wrong order: low-order digits
are available before high-order digits, but they have to be printed the other
way around.</p>
<p>There are two solutions to this problem. One is to store the digits in an array
as they are generated, then print them in reverse order, as we did with <code>itoa</code>
in [Section @sec:do-while]. The alternative is a recursive solution, in which
<code>printd</code> first calls itself to cope with any leading digits, then prints the
trailing digit. Again, this version can fail on the largest negative number.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

/* printd:  print n in decimal */
void printd(int n)
{
    if (n &lt; 0) {
        putchar('-');
        n = -n;
    }
    if (n / 10)
        printd(n / 10);
    putchar(n % 10 + '0');
}
</code></pre>
<p>When a function calls itself recursively, each invocation gets a fresh set of
all the automatic variables, independent of the previous set. Thus in
<code>printd(123)</code> the first <code>printd</code> revives the argument <code>n = 123</code>. It passes <code>12</code>
to a second <code>printd</code>, which in turn passes <code>1</code> to a third. The third-level
<code>printd</code> prints <code>1</code>, then returns to the second level. The <code>printd</code> prints <code>2</code>,
then returns to the first level. That one prints <code>3</code> and terminates.</p>
<p>Another good example of a recursion is quicksort, a sorting algorithm developed
by C. A. R. Hoare in 1962. Given an array, one element is chosen and the others
are partitioned into two subsets—those less than the partition element and
those greater than or equal to it. The same process is then applied recursively
to the two subsets. When a subset has fewer than two elements, it doesn’t need
any sorting; this stops the recursion.</p>
<p>Our version of quicksort is not the fastest possible, but it’s one of the
simplest. We use the middle element of each subarray for partitioning.</p>
<pre><code class="language-c">/* qsort:  sort v[left]...v[right] into increasing order */
void qsort(int v[], int left, int right)
{
    int i, last;
    void swap(int v[], int i, int j);

    if (left &gt;= right)    /* do nothing if array contains */
        return;           /* fewer than two elements */
    swap(v, left, (left + right)/2); /* move partition elem */
    last = left;                     /* to v[0] */
    for (i = left+1; i &lt;= right; i++)   /* partition */
        if (v[i] &lt; v[left])
            swap(v, ++last, i);
    swap(v, left, last);         /* restore partition elem */
    qsort(v, left, last);
    qsort(v, last+1, right);
}
</code></pre>
<p>We moved the swapping operation into a separate function <code>swap</code> because it
occurs three times in <code>qsort</code>.</p>
<pre><code class="language-c">/* swap:  interchange v[i] and v[j] */
void swap(int v[], int i, int j)
{
    int temp;

    temp = v[i];
    v[i] = v[j];
    v[j] = temp;
}
</code></pre>
<p>The standard library includes a version of <code>qsort</code> that can sort objects of any
type.</p>
<p>Recursion may provide no saving in storage, since somewhere a stack of the
values being processed must be maintained. Nor will to be faster. But recursive
code is more compact, and often much easier to write and understand than the
non-recursive equivalent. Recursion is especially convenient for recursively
defined data structures like trees: we will see a nice example in [Section
@sec:self-ref-struct].</p>
<p><strong>Exercise 4-12.</strong> Adapt the ideas of <code>printd</code> to write a recursive version of
<code>itoa</code>; that is convert, an integer into a string by calling a recursive
routine.</p>
<p><strong>Exercise 4-13.</strong> Write a recursive version of the function <code>reverse(s)</code>,
which reverses the string <code>s</code> in place.</p>
<h2>The C Preprocessor {#sec:preprocessor}</h2>
<p>C provides certain language facilities by means of a preprocessor, which is
conceptually a separate first step in compilation. The two most frequently used
features are <code>#include</code>, to include the contents of a file during compilation,
and <code>#define</code>, to replace a token by an arbitrary sequence of characters. Other
features described in this section include conditional compilation and macros
with arguments.</p>
<h3>File inclusion</h3>
<p>File inclusion makes it easy to handle collections of <code>#defines</code> and
declarations (among other things). Any source line of the form</p>
<pre><code class="language-c">#include &quot;filename&quot;
</code></pre>
<p>or</p>
<pre><code class="language-c">#include &lt;filename&gt;
</code></pre>
<p>is replaced by the contents of the file <em>filename</em>. If the <em>filename</em> is
quoted, searching for the file typically begins where the source program was
found; if it is not found there, or if the name is enclosed in <code>&lt;</code> and <code>&gt;</code>,
searching follows an implementation-defined rule to find the file. An included
file may itself contain <code>#include</code> lines.</p>
<p>There are often several <code>#include</code> lines at the beginning of a source file, to
include common <code>#define</code> statements and <code>extern</code> declarations, or to access the
function prototype declarations for library functions from headers like
<code>&lt;stdio.h&gt;</code>. (Strictly speaking, these need not be filed; the details of how
headers are accessed are implementation-dependent.)</p>
<p><code>#include</code> is the preferred way to tie the declarations together for a large
program. It guarantees that all the source files will be supplied with the same
definitions and variable declarations, and thus eliminates a particularly nasty
kind of bug. Naturally, when an included file is changed, all files that depend
on it must be recompiled.</p>
<h3>Macro Substitution</h3>
<p>A definition has the form</p>
<pre><code class="language-c">#define  name  replacement text
</code></pre>
<p>It calls for a macro substitution of the simplest kind—subsequent occurrences
of the token <em>name</em> will be replaced by the <em>replacement text</em>. The name in a
<code>#define</code> has the same form as a variable name; the replacement text is
arbitrary. Normally the replacement text is the rest of the line, but a long
definition may be continued onto several lines by placing a <code>\</code> at the end of
each line to be continued. The scope of a name defined with <code>#define</code> is from
its point of definition to the end of the source file being compiled. A
definition may use previous definitions. Substitutions are made only for
tokens, and do not take place within quoted strings. For example, if <code>YES</code> is a
defined name, there would be no substitution in <code>printf(&quot;YES&quot;)</code> or in <code>YESMAN</code>.</p>
<p>Any name may be defined with any replacement text. For example,</p>
<pre><code class="language-c">#define  forever  for(;;)   /* infinite loop */
</code></pre>
<p>defines a new work, <code>forever</code>, for an infinite loop.</p>
<p>It is possible to define macros with arguments, so the placement text can be
different for different calls of the macro. As an example, define a macro
called <code>max</code>:</p>
<pre><code class="language-c">#define  max(A, B)  ((A) &gt; (B) ? (A) : (B))
</code></pre>
<p>Although it looks like a function call, a use of <code>max</code> expands into in-line
code. Each occurrence of a formal parameter (here <code>A</code> or <code>B</code>) will be replaced
by the corresponding actual argument. Thus the line</p>
<pre><code class="language-c">x = max(p+1, r+s);
</code></pre>
<p>will be replaced by the line</p>
<pre><code class="language-c">x = ((p+q) &gt; (r+s) ? (p+q) : (r+s));
</code></pre>
<p>So long as the arguments are treated consistently, this macro will serve for
any data type; there is no need for different kinds of <code>max</code> for different data
types, as there would be with functions.</p>
<p>If you examine the expansion of <code>max</code>, you will notice some pitfalls. The
expressions are evaluated twice; this is bad if they involve side effects like
increment operators or input and output. For instance,</p>
<pre><code class="language-c">max(i++, j++)   /* WRONG */
</code></pre>
<p>will increment the larger value twice. Some care also has to be taken with
parentheses to make sure the order of evaluation is preserved; consider what
happens when the macro</p>
<pre><code class="language-c">#define  square(x)  x * x   /* WRONG */
</code></pre>
<p>is invoked as square(z+1).</p>
<p>Nonetheless, macros are valuable. One practical example comes from <code>&lt;stdio.h&gt;</code>,
in which <code>getchar</code> and <code>putchar</code> are often defined as macros to avoid the
run-time overhead of a function call per character processed. The functions in
<code>&lt;ctype.h&gt;</code> are also usually implemented as macros.</p>
<p>Names may be undefined with <code>#undef</code>, usually to ensure that a routine is
really a function, not a macro:</p>
<pre><code class="language-c">#undef getchar

int getchar(void) { ... }
</code></pre>
<p>Formal parameters are not replaced within quoted strings. If, however, a
parameter name is precede by a <code>#</code> in the replacement text, the combination
will be expanded into a quoted string with the parameter replaced by the actual
argument. This can be combined with string concatenation to make, for example,
a debugging print macro.</p>
<pre><code class="language-c">#define dpring(expr)  printf(#expr &quot; = %g\n&quot;, expr)
</code></pre>
<p>When this is invoked, as in</p>
<pre><code class="language-c">dprint(x/y);
</code></pre>
<p>the macro is expanded into</p>
<pre><code class="language-c">printf(&quot;x/y&quot; &quot; = %g\n&quot;, x/y);
</code></pre>
<p>and the strings are concatenated, so the effect is</p>
<pre><code class="language-c">printf(&quot;x/y = %g\n&quot;, x/y);
</code></pre>
<p>Within the actual argument, each <code>&quot;</code> is replaced by <code>\&quot;</code> and each <code>\</code> by <code>\\</code>,
so the result is a legal string constant.</p>
<p>The preprocessor operator <code>##</code> provides a way to concatenate actual arguments
during macro expansion. If a parameter in the replacement text is adjacent to a
<code>##</code>, the parameter is replaced by the actual argument, the <code>##</code> and
surrounding white space are removed, and the result is re-scanned. For example,
the macro <code>paste</code> concatenates its two arguments:</p>
<pre><code class="language-c">#define  paste(front, back)  front ## back
</code></pre>
<p>so <code>paste(name, 1)</code> creates a token <code>name1</code>.</p>
<p>The rules for nested uses of <code>##</code> are arcane; further details may be found in
[Appendix @sec:ref-man].</p>
<p><strong>Exercise 4-14.</strong> Define a macro <code>swap(t,x,y)</code> that interchanges two arguments
of type <code>t</code>. (Block structure will help.)</p>
<h3>Conditional Inclusion</h3>
<p>It is possible to control preprocessing itself with conditional statements that
are evaluated during preprocessing. This provides a way to include code
selectively, depending on the value of conditions evaluated during compilation.</p>
<p>The <code>#if</code> line evaluates a constant integer expression (which may not include
<code>sizeof</code>, casts, or <code>enum</code> constants). If the expression is non-zero,
subsequent lines until an <code>#endif</code> or <code>#elif</code> or <code>#else</code> are included. (The
preprocessor statement <code>#elif</code> is like <code>else if</code>.) The expression
<code>defined(name)</code> in a <code>#if</code> is <code>1</code> if the <em>name</em> has been defined, and <code>0</code>
otherwise.</p>
<p>For example, to make sure that the contents of a file <code>hdr.h</code> are included only
once, the contents of the file are surrounded with a conditional like this:</p>
<pre><code class="language-c">#if !defined(HDR)
#define HDR

/* contents of hdr.g go here */
#endif
</code></pre>
<p>The first inclusion of <code>hdr.h</code> defines the name <code>HDR</code>; subsequent inclusions
will find the name defined and skip down to the <code>#endif</code>. A similar style can
be used to avoid including files multiple times. If this style is used
consistently, then each header can itself include any other headers on which it
depends, without the user of the header having to deal with interdependence.</p>
<p>This sequence tests the name <code>SYSTEM</code> to decide which version of a header to
include:</p>
<pre><code class="language-c">#if SYSTEM == SYSV
    #define HDR &quot;sysv.h&quot;
#elif SYSTEM == BSD
    #define HDR &quot;bsd.h&quot;
#elif SYSTEM == MSDOS
    #define HDR &quot;msdos.h&quot;
#else
    #define HDR &quot;default.h&quot;
#endif
#include HDR
</code></pre>
<p>The <code>#ifdef</code> and <code>#ifndef</code> lines are specialized forms that test whether a name
is defined. The first example of <code>#if</code> above could have been written</p>
<pre><code class="language-c">#ifndef HDR
#define HDR

/* contents of hdr.h go here */

#endif
</code></pre>
<h1>Pointers and Arrays {#sec:pointers}</h1>
<p>A pointer is a variable that contains the address of a variable. Pointers are
much used in C, partly because they are sometimes the only way to express a
computation, and partly because they usually lead to more compact and efficient
code than can be obtained in other ways. Pointers and arrays are closely
related; this chapter also explores this relationship and hows how to exploit
it.</p>
<p>Pointers have been lumped with the <code>goto</code> statement as a marvelous way to
create impossible-to-understand programs. This is certainly true when they are
used carelessly, and it is easy to create pointers that point somewhere
unexpected. With discipline, however, pointers can also be used to achieve
clarity and simplicity. This is the aspect that we will try to illustrate.</p>
<p>The main change in ANSI C is to make explicit the rules about how pointers can
be manipulated, in effect mandating what good programmers already practice and
good compilers already enforce. In addition, the type <code>void *</code> (pointer to
<code>void</code>) replaces <code>char *</code> as the proper type for a generic pointer.</p>
<h2>Pointers and Addresses</h2>
<p>Let us begin with a simplified picture of how memory is organized. A typical
machine has an array of consecutively numbered or addressed memory cells that
may be manipulated individually or in contiguous groups. One common situation
is that any byte can be a <code>char</code>, a pair of one-byte cells can be treated as a
<code>short</code> integer, and four adjacent bytes form a <code>long</code>. A pointer is a group of
cells (often two or four) that can hold an address. So if <code>c</code> is a <code>char</code> and
<code>p</code> is a pointer that points to it, we could represent the situation this way:</p>
<pre><code class="language-c">                        +-------------------------+
                        |                         |
                     p:****                    c: v
-----------------------------------------------------------------
              |   |   |   |             |   |   |   |   |
    ...       | | | | | | |    ...      | | | | | | | | |   ...
              |   |   |   |             |   |   |   |   |https://jekyllrb.com/docs/upgrading/
-----------------------------------------------------------------
</code></pre>
<p>The unary operator <code>&amp;</code> gives the address of an object, so the statement</p>
<pre><code class="language-c">p = &amp;c;
</code></pre>
<p>assigns the address of <code>c</code> to the variable <code>p</code>, and <code>p</code> is said to “point to”
<code>c</code>. The <code>&amp;</code> operator only applies to objects in memory: variables and array
elements. It cannot be applied to expressions, constants, or <code>register</code>
variables.</p>
<p>The unary operators <code>*</code> is the <em>indirection</em> or <em>dereferencing</em> operator; when
applied to a pointer, it accesses the object the pointer points to. Suppose
that <code>x</code> and <code>y</code> are integers and <code>ip</code> is a pointer to <code>int</code>. This artificial
sequence shows how to declare a pointer and how to use <code>&amp;</code> and <code>*</code>:</p>
<pre><code class="language-c">int x = 1, y = 2, z[10];
int *ip;         /* ip is a poitner to int */

ip = &amp;x;         /* ip now points to x */
y = *ip;         /* y is now 1 */
*ip = 0;         /* x is now 0 */
ip = &amp;z[0];      /* ip now poitns to z[0] */
</code></pre>
<p>The declarations of <code>x</code>, <code>y</code>, and <code>z</code> are what we’ve seen all along. The
declaration of the pointer <code>ip</code>,</p>
<pre><code class="language-c">int *ip;
</code></pre>
<p>is intended as a mnemonic; it says that the expression <code>*ip</code> is an <code>int</code>. The
syntax of the declaration for a variable mimics the syntax of expressions in
which the variable might appear. This reasoning applies to function
declarations as well. For example,</p>
<pre><code class="language-c">double *dp, atof(char *);
</code></pre>
<p>says that in an expression <code>*dp</code> and <code>atof(s)</code> have values of type <code>double</code>,
and that the argument of <code>atof</code> is a pointer to <code>char</code>.</p>
<p>You should also note the implication that a pointer is constrained to point to
a particular kind of object: every pointer points to a specific data type.
(There is one exception: a “pointer to <code>void</code>” is used to hold any type of
pointer but cannot be dereferenced itself. We’ll come back to it in [Section
@sec:p-to-f].)</p>
<p>If <code>ip</code> points to the integer <code>x</code>, then <code>*ip</code> can occur in any context where
<code>x</code> could, so</p>
<pre><code class="language-c">*ip = *ip + 10;
</code></pre>
<p>increments <code>*ip</code> by 10.</p>
<p>The unary operators <code>*</code> and <code>&amp;</code> bind more tightly than arithmetic operators, so
the assignment</p>
<pre><code class="language-c">y = *ip + 1
</code></pre>
<p>takes whatever <code>ip</code> points at, adds 1, and assigns the result to <code>y</code>, while</p>
<pre><code class="language-c">*ip += 1;
</code></pre>
<p>increments what <code>ip</code> points to, as do</p>
<pre><code class="language-c">++*ip
</code></pre>
<p>and</p>
<pre><code class="language-c">(*ip)++
</code></pre>
<p>The parentheses are necessary in this last example; without them, the
expression would increment <code>ip</code> instead of what it points to, because unary
operators like <code>*</code> ad <code>++</code> associate right to left.</p>
<p>Finally, since pointers are variables, they can be use without dereferencing.
For example, if <code>iq</code> is another pointer to <code>int</code>,</p>
<pre><code class="language-c">iq = ip
</code></pre>
<p>copies the contents of <code>ip</code> into <code>iq</code>, thus making <code>iq</code> point to whatever <code>ip</code>
pointed to.</p>
<h2>Pointers and Function Arguments</h2>
<p>Since C passes arguments to functions by value, there is no direct way for the
called function to alter a variable in the calling function. For instance, a
sorting routine might exchange two out-of-order elements with a function called
<code>swap</code>. It is not enough to write</p>
<pre><code class="language-c">swap(a, b);
</code></pre>
<p>where the <code>swap</code> function is defined as</p>
<pre><code class="language-c">void swap(int x, int y)  /* WRONG */
{
    int temp;

    temp = x;
    x = y;
    y = temp;
}
</code></pre>
<p>Because of call by value, <code>swap</code> can’t affect the arguments <code>a</code> and <code>b</code> in the
routine that called it. The function only swaps <em>copies</em> of <code>a</code> and <code>b</code>.</p>
<p>The way to obtain the desired effect is for the calling program to pass
<em>pointers</em> to the values to be changed:</p>
<pre><code class="language-c">swap(&amp;a, &amp;b);
</code></pre>
<p>Since the operator <code>&amp;</code> produces the address of a variable, <code>&amp;a</code> is a pointer to
<code>a</code>. In <code>swap</code> itself, the parameters are declared to be pointers, and the
operands are accessed indirectly through them.</p>
<pre><code class="language-c">void swap(int *px, int *py)  /* interchange *px and *py */
{
    int temp;

    temp = *px;
    *px = *py;
    *py = temp;
}
</code></pre>
<p>Pictorially:</p>
<pre><code>in caller:
+----------+
|          |
|    +---+ |
| a: |   |&lt;--------+
|    +---+ |       |
|          |       |
|    +---+ |       |
| b: |   |&lt;----+   |
|    +---+ |   |   |
|          |   |   |
+----------+   |   |
               |   |
in swap:       |   |
+-----------+  |   |
|           |  |   |
|     +---+ |  |   |
| px: | *----------+
|     +---+ |  |
|           |  |
|     +---+ |  |
| py: | *------+
|     +---+ |
|           |
+-----------+
</code></pre>
<p>Pointer arguments enable a function to access and change objects in the
function that called it. As an example, consider a function <code>getint</code> that
performs free-format input conversion by breaking a stream of characters into
integer values, one integer per call. <code>getint</code> has to return the value it found
and also signal end of file when there is no more input. These values have to
be passed back by separate paths, for no matter what value is used for <code>EOF</code>,
that could also be the value of an input integer.</p>
<p>One solution is to have <code>getint</code> return the end of file status as its function
value, while using a pointer argument to store the converted integer back in
the calling function. This is the scheme used by <code>scanf</code> as well; see [Section
@sec:scanf].</p>
<p>The following loop fills an array with integers by calls to <code>getint</code>:</p>
<pre><code class="language-c">int n, array[SIZE], getint( int *);

for (n = 0; n &lt; SIZE &amp;&amp; getint(&amp;array[n]) != EOF; n++)
    ;
</code></pre>
<p>Each call sets <code>array[n]</code> to the next integer found in the input and increments
<code>n</code>. Notice that it is essential to pass the address of <code>array[n]</code> to <code>getint</code>.
Otherwise there is no way for <code>getint</code> to communicate the converted integer
back to the caller.</p>
<p>Our version of <code>getint</code> returns <code>EOF</code> for end of file, zero if the next input
is not a number, and a positive value if the input contains a valid number.</p>
<pre><code class="language-c">#include &lt;ctype.h&gt;

int getch(void);
void ungetch(int);

/* getint:  get next integer from input into *pn */
int getint(int *pn)
{
    int c, sign;

    while (isspace(c = getch()))    /* skip white space */
        ;
    if (!isdigit(c) &amp;&amp; c != EOF &amp;&amp; c != '+' &amp;&amp; c != '-') {
        ungetch(c);    /* it's not a number */
        return 0;
    }
    sign = (c == '-') ? -1 : 1;
    if (c == '+' || c == '-')
        c = getch();
    for (*pn = 0; isdigit(c); c = getch())
        *pn = 10 * *pn + (c - '0');
    *pn *= sign;
    if (c != EOF)
        ungetch(c);
    return c;
}
</code></pre>
<p>Throughout <code>getint</code>, <code>*pn</code> is used as an ordinary <code>int</code> variable. We have also
used <code>getch</code> and <code>ungetch</code> (described in [Section @sec:extern-vars]) so the one
extra character that must be read can be pushed back onto the input.</p>
<p><strong>Exercise 5-1.</strong> As written, <code>getint</code> treats a <code>+</code> or <code>-</code> not followed by a
digit as a valid representation of zero. Fix it to push such a character back
on the input.</p>
<p><strong>Exercise 5-2.</strong> Write <code>getfloat</code>, the floating-point analog of <code>getint</code>. What
type does <code>getfloar</code> return as its function value?</p>
<h2>Pointers and Arrays</h2>
<p>In C, there is a strong relationship between pointers and arrays, string enough
that pointers and arrays should be discussed simultaneously. Any operation that
can be achieved by array subscripting can also be done with pointers. The
pointer version will in general be faster, but at least to the uninitiated,
somewhat harder to understand.</p>
<p>The declaration</p>
<pre><code class="language-c">int a[10];
</code></pre>
<p>defines an array <code>a</code> of size 10, that is, a block of 10 consecutive objects
named <code>a[0]</code>, <code>a[1]</code>,…, <code>a[9]</code>.</p>
<pre><code>            +-------------------------------------------------+
       a:   |    |    |    |    |    |    |    |    |    |    |
            +-------------------------------------------------+
             a[0] a[1]                                    a[9]
</code></pre>
<p>The notation <code>a[i]</code> refers to the <code>i</code>-th element of the array. If <code>pa</code> is a
pointer to an integer, declared as</p>
<pre><code class="language-c">int *pa;
</code></pre>
<p>then the assignment</p>
<pre><code class="language-c">pa = &amp;a[0];
</code></pre>
<p>sets <code>pa</code> to point to element zero of <code>a</code>; that is, <code>pa</code> contains the address
of <code>a[0]</code>.</p>
<pre><code>   pa:
    +---+
    | *-------+
    +---+     |
              v
            +-------------------------------------------------+
       a:   |    |    |    |    |    |    |    |    |    |    |
            +-------------------------------------------------+
             a[0] a[1]                                    a[9]
</code></pre>
<p>Now the assignment</p>
<pre><code class="language-c">x = *pa;
</code></pre>
<p>will copy the contents of <code>a[0]</code> into <code>x</code>.</p>
<p>If <code>pa</code> points to a particular element of an array, then by definition <code>pa+1</code>
points to the next element, <code>pa+i</code> points <code>i</code> elements after <code>pa</code>, and <code>pa-i</code>
points <code>i</code> elements before. Thus, if <code>pa</code> points to <code>a[0]</code>,</p>
<pre><code class="language-c">*(pa+1)
</code></pre>
<p>refers to the contents of <code>a[1]</code>, <code>pa+i</code> is the address of <code>a[i]</code>, and
<code>*(pa+i)</code> is the contents of <code>a[i]</code>.</p>
<pre><code>    pa:     pa+1:---+  pa+2:--+
     +---+          |         |
     | *-------+    |    +----+
     +---+     |    |    |
               v    v    v
             +-------------------------------------------------+
        a:   |    |    |    |    |    |    |    |    |    |    |
             +-------------------------------------------------+
              a[0] a[1]                                    a[9]
</code></pre>
<p>These remarks are true regardless of the type or size of the variables in the
array <code>a</code>. The meaning of “adding 1 to a pointer,” and by extension, all
pointer arithmetic, is that <code>pa+1</code> points to the next object, and <code>pa+i</code> points
to the <code>i</code>-th object beyond <code>pa</code>.</p>
<p>The correspondence between indexing and pointer arithmetic is very close. By
definition, the value of a variable or expression of type array is the address
of element zero of the array. Thus after the assignment</p>
<pre><code class="language-c">pa = &amp;a[0];
</code></pre>
<p><code>pa</code> and <code>a</code> have identical values. Since the name of an array is a synonym for
the location of the initial element, the assignment <code>pa=&amp;a[0]</code> can also be
written as</p>
<pre><code class="language-c">pa = a;
</code></pre>
<p>Rather more surprising, at least at first sight, is the fact that a reference
to <code>a[i]</code> can also be written as <code>*(a+i)</code>. In evaluating <code>a[i]</code>, C converts it
to <code>*(a+i)</code> immediately; the two forms are equivalent. Applying the operator
<code>&amp;</code> to both parts of this equivalence, it follows that <code>&amp;a[i]</code> and <code>a+i</code> are
also identical: <code>a+i</code> is the address of the <code>i</code>-th element beyond <code>a</code>. As the
other side of this coin, if <code>pa</code> is a pointer, expressions may use it with a
subscript; <code>pa[i]</code> is identical to <code>*(pa+i)</code>. In short, an array-and-index
expression is equivalent to one written as a pointer and offset.</p>
<p>There is one difference between an array name and a pointer that must be kept
in mind. A pointer is a variable, so <code>pa=a</code> and <code>pa++</code> are legal. But an array
name is not a variable; constructions like <code>a=pa</code> and <code>a++</code> are illegal.</p>
<p>When an array name is passed to a function, what is passed is the location of
the initial element. Within the called function, this argument is a local
variable, and so an array name parameter is a pointer, that is, a variable
containing an address. We can use this fact to write another version of
<code>strlen</code>, which computes the length of a string.</p>
<pre><code class="language-c">/* strlen:  return length of string s */
int strlen(char *s)
{
    int n;

    for (n = 0; *s != '\0'; s++)
        n++;
    return n;
}
</code></pre>
<p>Since <code>s</code> is a pointer, incrementing it is perfectly legal; <code>s++</code> has no effect
on the character string in the function that called <code>strleng</code>, but merely
increments <code>strlen</code>’s private copy of the pointer. That manes that calls like</p>
<pre><code class="language-c">strlen(&quot;hello, world&quot;);  /* string constant */
strlen(array);           /* char array[100]; */
strlen(ptr);             /* char *ptr; */
</code></pre>
<p>all work.</p>
<p>As formal parameters in a function definition,</p>
<pre><code class="language-c">char s[];
</code></pre>
<p>and</p>
<pre><code class="language-c">char *s;
</code></pre>
<p>are equivalent; we prefer the latter because it says more explicitly that the
parameter is a pointer. When an array name is passed to a function, the
function can at its convenience believe that it has been handed either an array
or a pointer, and manipulate it accordingly. It can even use both notations if
it seems appropriate and clear.</p>
<p>It is possible to pass part of an array to a function, by passing a pointer to
the beginning of the subarray. For example, if <code>a</code> is an array,</p>
<pre><code class="language-c">f(&amp;a[2])
</code></pre>
<p>and</p>
<pre><code class="language-c">f(a+2)
</code></pre>
<p>both pass to the function <code>f</code> the address of the subarray that starts at
<code>a[2]</code>. Within <code>f</code>, the parameter declaration can read</p>
<pre><code class="language-c">f(int arr[]) { ... }
</code></pre>
<p>or</p>
<pre><code class="language-c">f(int *arr) { ... }
</code></pre>
<p>So as far as <code>f</code> is concerned, the fact that the parameter refers to part of a
larger array is of no consequence.</p>
<p>If one is sure that the elements exist, it is also possible to index backwards
in an array: <code>p[-1]</code>, <code>p[-2]</code>, ans so on are syntactically legal, and refer to
the elements that immediately precede <code>p[0]</code>. Of course, it is illegal to refer
to objects that are not within the array bounds.</p>
<h2>Address Arithmetic</h2>
<p>If <code>p</code> is a pointer to some element of an array, then <code>p++</code> increments <code>p</code> to
point to the next element, and <code>p+=i</code> increments it to point <code>i</code> elements
beyond where it currently does. These and similar constructions are the
simplest forms of pointer or address arithmetic.</p>
<p>C is consistent and regular in its approach to address arithmetic; its
integration of pointers, arrays, and address arithmetic is one of the strengths
of the language. Let us illustrate by writing a rudimentary storage allocator.
There are two routines. The first, <code>alloc(n)</code>, returns a pointer <code>p</code> to
<code>n</code>-consecutive character positions, which can be used by the caller of <code>alloc</code>
for storing characters. The second, <code>afree(p)</code>, releases the storage thus
acquired so it can be re-used later. The routines are “rudimentary” because the
calls to <code>afree</code> must be made in the opposite order to the calls made on
<code>alloc</code>. That is, storage managed by <code>alloc</code> and <code>afree</code> is a stack, or
last-in, first-out list. The standard library provides analogous functions
called <code>malloc</code> and <code>free</code> that have no such restrictions; in [Section
@sec:stor-alloc] we will show how they can be implemented.</p>
<p>The easiest implementation is to have <code>alloc</code> hand out pieces of a large
character array that we will call <code>allocbuf</code>. This array is private to <code>alloc</code>
and <code>afree</code>. Since they deal in pointers, not array indices, no other routine
need to know the name of the array, which can be declared <code>statoc</code> om the
source file containing <code>alloc</code> and <code>afree</code>, and thus be invisible outside it.
In practical implementations, the array may well not even have a name; it might
instead be obtained by calling <code>malloc</code> or by asking the operating system for a
pointer to some unnamed block of storage.</p>
<p>The other information needed is how much of <code>allocbuf</code> has been used. We use a
pointer, called <code>allocp</code>, that points to the next free element. When <code>alloc</code> is
asked for <code>n</code> characters, it checks to see if there is enough room left in
<code>allocbuf</code>. If so, <code>alloc</code> returns the current value of <code>allocp</code> (i.e., the
beginning of the free block), then increments it by <code>n</code> to point to the next
free area. If there is no room, <code>alloc</code> returns zero. <code>afree(p)</code> merely sets
<code>allocp</code> to <code>p</code> if <code>p</code> is inside <code>allocbuf</code>.</p>
<pre><code>before call to alloc:
                     allocp:-+
                             |
                             v
          +-----------------------------------------------------+
allocbuf: |   |      |  |   |                                   |
          +-----------------------------------------------------+
          &lt;-----in use------&gt;&lt;-------------free-----------------&gt;

after call to alloc:
                                allocp:-+
                                        |
                                        v
          +-----------------------------------------------------+
allocbuf: |   |      |  |   |          |                        |
          +-----------------------------------------------------+
          &lt;----------in use------------&gt;&lt;----------free---------&gt;
</code></pre>
<pre><code class="language-c">#define ALLOCSIZE 10000 /* size of available space */

static char allocbuf[ALLOCSIZE];  /* storage for alloc */
static char *allocp = allocbuf;   /* next free position */

char *alloc(int n)  /* return pointer to n characters */
{
    if (allocbuf + ALLOCSIZE - allocp &gt;= n) { /* it fits */
        allocp += n;
        return allocp - n; /* old p */
    } else      /* not enough room */
        return 0;
}

void afree(char *p)  /* free storage pointed to by p */
{
    if (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE)
        allocp = p;
}
</code></pre>
<p>In general a pointer can be initialized just as any other variable can, though
normally the only meaningful values are zero or an expression involving the
addresses of previously defined data of appropriate type. The declaration</p>
<pre><code class="language-c">static char *allocp = allocbuf;
</code></pre>
<p>defined <code>allocp</code> to be a character pointer and initializes it to point to the
beginning of <code>allocbuf</code>, which is the next free position when the program
starts. This could have also been written</p>
<pre><code class="language-c">static char *allocp = &amp;allocbuf[0];
</code></pre>
<p>since the array name <em>is</em> the address of the zeroth element.</p>
<p>The test</p>
<pre><code class="language-c">if (allocbuf + ALLOCSIZE - allocp &gt;= n) { /* it fits */
</code></pre>
<p>checks if there’s enough room to satisfy the request for <code>n</code> characters. If
there is, the new value of <code>allocp</code> would be at most one beyond the end of
<code>allocbuf</code>. If the request can be satisfied, <code>alloc</code> returns a pointer to the
beginning of a block of characters (notice the declaration of the function
itself). If not, <code>alloc</code> must return some signal that no space is left. <code>C</code>
guarantees that zero is never a valid address for data, so a return value of
zero can be used in signal an abnormal event, in this case, no space.</p>
<p>Pointers and integers are not interchangeable. Zero is the sole exception: the
constant zero may be assigned to a pointer, and a pointer may be compared with
the constant zero. The symbolic constant <code>NULL</code> is often used in place of zero,
as a mnemonic to indicate more clearly that this is a special value for a
pointer. <code>NULL</code> is defined in <code>&lt;stdio.h&gt;</code>. We will use <code>NULL</code> henceforth.</p>
<p>Tests like</p>
<pre><code class="language-c">if (allocbuf + ALLOCSIZE - allocp &gt;= n) { /* it fits */
</code></pre>
<p>and</p>
<pre><code class="language-c">if (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE)
</code></pre>
<p>shows several important facets of pointer arithmetic. First, pointers may be
compared under certain circumstances. If <code>p</code> and <code>q</code> point to members of the
same array, then relations like <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;=</code>, etc., work properly. For
example,</p>
<pre><code class="language-c">p &lt; q
</code></pre>
<p>is true if <code>p</code> points to an earlier member of the array than <code>q</code> does. Any
pointer can be meaningfully compared for equality or inequality with zero. But
the behavior is undefined for arithmetic or comparisons with pointers that do
not point to members of the same array. (There is one exception: the address of
the first element past the end of an array can be used in pointer arithmetic.)</p>
<p>Second, we have already observed that a pointer and an integer may be added or
subtracted. The construction</p>
<pre><code class="language-c">p + n
</code></pre>
<p>means that the address of the <code>n</code>-th object beyond the one <code>p</code> currently points
to. This is true regardless of the kind of object <code>p</code> points to; <code>n</code> is scaled
according to the size of the objects <code>p</code> points to, which is determined by the
declaration of <code>p</code>. If an <code>int</code> if four bytes, for example, the <code>int</code> will be
scaled by four.</p>
<p>Pointer subtraction is also valid: is <code>p</code> and <code>q</code> point to elements of the same
array, and <code>p&lt;q</code>, then <code>q-p+1</code> is the number of elements from <code>p</code> to <code>q</code>
inclusive. This fact can be used to write ye another version of <code>strlen</code>:</p>
<pre><code class="language-c">/* strlen:  return length of string s */
int strlen(char *s)
{
    char *p = s;

    while (*p  != '\0')
        p++;
    return p - s;
}
</code></pre>
<p>In its declaration, <code>p</code> is initialized to <code>s</code>, that is, to point to the first
character of the string. In the <code>while</code> loop, each character in turn is
examined until the <code>'\0'</code> at the end is seen. Because <code>p</code> points to characters,
<code>p++</code> advances <code>p</code> to the next character each time, and <code>p-s</code> gives the number
of character advanced over, that is, the string length. (The number of
characters in the string could be too large to store in an <code>int</code>. The header
<code>&lt;stddef.h&gt;</code> defines a type <code>ptrdiff_t</code> that is large enough to hold the signed
difference of two pointer values. If we were being cautious, however, we would
use <code>size_t</code> for the return type of <code>strlen</code>, to make the standard library
version. <code>size_t</code> is the unsigned integer type returned by the <code>sizeof</code>
operator.)</p>
<p>Pointer arithmetic is consistent: if we had been dealing with <code>floatis</code>, which
occupy more storage than <code>chars</code>, and if <code>p</code> were a pointer to a <code>float</code>, <code>p++</code>
would advance to the next <code>float</code>. Thus we could write another version of
<code>alloc</code> that maintains <code>floats</code> instead of <code>chars</code>, merely by changing <code>char</code>
to <code>float</code> throughout <code>alloc</code> and <code>afree</code>. All the pointer manipulations
automatically take into account the size of the object pointed to.</p>
<p>The valid pointer operations are assignment of pointers of the same type,
adding or subtracting a pointer and an integer, subtracting or comparing two
pointers to members of the same array, and assigning or comparing to zero. All
other pointer arithmetic is illegal. It is not legal to add two pointers, or to
multiply or divide or shift or mask them, or to add <code>float</code> or <code>double</code> to
them, or even, except for <code>void *</code>, to assign a pointer of one type to a
pointer of another type without a cast.</p>
<h2>Character Pointers and Functions</h2>
<p>A <em>string constant</em>, written as</p>
<pre><code class="language-c">&quot;I am a string&quot;
</code></pre>
<p>is an array of characters. In the internal representation, the array is
terminated with the null character <code>'\0'</code> so that programs can find the end.
The length in storage is thus one more than the number of characters between
the double quotes.</p>
<p>Perhaps the most common occurrence of string constants is as arguments to
functions, as in</p>
<pre><code class="language-c">printf(&quot;hello, world\n&quot;);
</code></pre>
<p>When a character string like this appears in a program, access to it is through
a character pointer; <code>printf</code> receives a pointer to t he beginning of the
character array. That is, a string constant is accessed by a pointer to its
first element.</p>
<p>String constants need not be function arguments. If <code>pmessage</code> is declared as</p>
<pre><code class="language-c">char *pmessage;
</code></pre>
<p>then the statement</p>
<pre><code class="language-c">pmessage = &quot;now is the time&quot;;
</code></pre>
<p>assigns to <code>pmessage</code> a pointer to the character array. This is <em>not</em> a string
copy; only pointers are involved. C does not provide any operators for
processing an entire string of characters as a unit.</p>
<p>There is an important difference between these definitions:</p>
<pre><code class="language-c">char amessage[] = &quot;now is the time&quot;;  /* an array */
char *pmessage = &quot;now is the time&quot;;   /* a pointer */
</code></pre>
<p><code>amessage</code> is an array, just big enough to hold the sequence of characters and
<code>'\0'</code> that initializes it. Individual characters within the array may be
changed but <code>amessage</code> will always refer to the same storage. On the other
hand, <code>pmessage</code> is a pointer, initialized to point elsewhere, but the result
is undefined if you try to modify the string contents.</p>
<pre><code>          +---+     +-------------------+
pmessage: | *-----&gt; | now is the time\0 |
          +---+     +-------------------+

          +-------------------+
amessage: | now is the time\0 |
          +-------------------+
</code></pre>
<p>We will illustrate more aspects of pointers and arrays by studying versions of
two useful functions adapted from the standard library. The first function is
<code>strcpy(s,t)</code>, which copies the string <code>t</code> to the string <code>s</code>. It would be nice
just to say <code>s=t</code> but this copies the pointer, not the characters. To copy the
characters, we need to a loop. The array version is first:</p>
<pre><code class="language-c">/* strcpy:  copy t to s; array subscript version */
void strcpy(char *s, char *t)
{
    int i;

    i = 0;
    while ((s[i] = t[i]) != '\0')
        i++;
}
</code></pre>
<p>For contrast, here is a version of <code>strcpy</code> with pointers:</p>
<pre><code class="language-c">/* strcpy:  copy t to s; pointer version 1 */
void strcpy(char *s, char *t)
{
    while ((*s = *t) != '\0') {
        s++;
        t++;
    }
}
</code></pre>
<p>Because arguments are passed by value, <code>strcpy</code> can use the parameters <code>s</code> and
<code>t</code> in any way it pleases. Here they are conveniently initialized pointers,
which are marched along the arrays a character at a time, until the <code>'\0'</code> that
terminates <code>t</code> has been copied to <code>s</code>.</p>
<p>In practice, <code>strcpy</code> would not be written as we showed it above. Experienced C
programmers would prefer</p>
<pre><code class="language-c">/* strcpy:  copy t to s; pointer version 2 */
void strcpy(char *s, char *t)
{
    while ((*s++ = *t++) != '\0')
        ;
}
</code></pre>
<p>This moves the increment of <code>s</code> and <code>t</code> into the test part of the loop. The
value of <code>*t++</code> is the character that <code>t</code> was incremented; the postfix <code>++</code>
doesn’t change <code>t</code> until after this character has been fetched. In the same
way, the character is stored into the old <code>s</code> position before <code>s</code> is
incremented. This character is also the value that is compared against <code>'\0'</code>
to control the loop. The net effect is that characters are copied from <code>t</code> to
<code>s</code>, up to and including the terminating <code>'\0'</code>.</p>
<p>As the final abbreviation, observe that a comparison against <code>'\0'</code> is
redundant, since the question is merely whether the expression is zero. So the
function would likely be written as</p>
<pre><code class="language-c">/* strcpy:  copy t to s; pointer version 3 */
void strcpy(char *s, char *t)
{
    while (*s++ = *t++)
        ;
}
</code></pre>
<p>Although this may seem cryptic at first sight, the notational convenience is
considerable, and the idiom should be masted, because you will see it
frequently in C programs.</p>
<p>The <code>strcpy</code> in the standard library (<code>&lt;string.h&gt;</code>) returns the target string
as its function value.</p>
<p>The second routine that we will examine is <code>strcmp(s,t)</code>, which compares the
character strings <code>s</code> and <code>t</code>, and returns negative, zero, or positive is <code>s</code>
is lexicographically less than, equal to, or greater than <code>t</code>. The value is
obtained by subtracting the characters at the first position where <code>s</code> and <code>t</code>
disagree.</p>
<pre><code class="language-c">/* strcmp:  return &lt;- if s&lt;t, 0 if s==t, &gt;0 if s&gt;t */
int strcmp(char *s, char *t)
{
    int i;

    for (i = 0; s[i] == t[i]; i++)
        if (s[i] == '\0')
            return 0;
    return s[i] - t[i];
}
</code></pre>
<p>The pointer version of <code>strcmp</code>:</p>
<pre><code class="language-c">/* strcmp:  return &lt;- if s&lt;t, 0 if s==t, &gt;0 if s&gt;t */
int strcmp(char *s, char *t)
{
    for ( ; *s == *t; s++, t++)
        if (*s == '\0')
            return 0;
    return *s - *t;
}
</code></pre>
<p>Since <code>++</code> and <code>--</code> are either prefix or postfix operators, other combinations
of <code>*</code> and <code>++</code> and <code>--</code> occur, although less frequently, For example,</p>
<pre><code class="language-c">*--p
</code></pre>
<p>decrements <code>p</code> before fetching the character that <code>p</code> points to. In fact, the
pair of expressions</p>
<pre><code class="language-c">*p++ = cal;    /* push val onto stack */
val = *--p;    /* pop top of stack into val */
</code></pre>
<p>are the standard idioms for pushing and popping a stack; see [Section
@sec:extern-vars].</p>
<p>The header <code>&lt;string.h&gt;</code> contains declarations for the functions mentioned in
this section, plus a variety of other string-handling functions from the
standard library.</p>
<p><strong>Exercise 5-3.</strong> Write a pointer version of the function <code>strcat</code> that we
showed in [Chapter @sec:types-ops-expressions]: <code>strcat(s,t)</code> copies the string
<code>t</code> to the end of <code>s</code>.</p>
<p><strong>Exercise 5-4.</strong> Write the function <code>strend(s,t)</code>, which returns 1 if the
string <code>t</code> occurs at the end of the string <code>s</code>, and zero otherwise.</p>
<p><strong>Exercise 5-5.</strong> Write versions of the library functions <code>strncpy</code>, <code>strncat</code>,
and <code>strncmp</code>, which operate on at most the first <code>n</code> characters of their
argument strings. For example, <code>strncpy(s,t,n)</code> copies at most <code>n</code> characters
of <code>t</code> to <code>s</code>. Full descriptions are in [Appendix @sec:std-lib].</p>
<p><strong>Exercise 5-6.</strong> Rewrite appropriate programs from earlier chapters and
exercises with pointers instead of array indexing. Good possibilities include
<code>getline</code> ([Chapters @sec:introduction; and @sec:functions]), <code>atoi</code>, <code>itoa</code>,
and their variants ([Chapters @sec:types-ops-expressions; -@sec:control-flow;
and @sec:functions]), <code>reverse</code> ([Chapter @sec:control-flow]), and <code>strindex</code>
and <code>getop</code> ([Chapter @sec:functions]).</p>
<h2>Pointer Arrays; Pointers to Pointers {#sec:pointer-to-pointer}</h2>
<p>Since pointers are variables themselves, they can be stored in arrays just as
other variables can. Let us illustrate by writing a program that will sort a
set of text lines into alphabetical order, a stripped-down version of the UNIX
program <code>sort</code>.</p>
<p>In [Chapter @sec:control-flow] we presented a Shell sort function that would
sort an array of integers, and in [Chapter @sec:functions] we improved on it
with a quicksort. The same algorithms will work, except that now we have to
deal with lines of text, which are of different lengths, and which, unlike
integers, can’t be compared or moved in a single operation. We need a data
representation that will cope efficiently and conveniently with variable-length
text lines.</p>
<p>This is where the array of pointers enters. If the lines to be sorted are
stored end-to-end in one long character array, then each line can be accessed
by a pointer to its first character. The pointers themselves can be stored in
an array. Two line scan be compared by passing their pointers to <code>strcmp</code>. When
two out-of-order lines have to be exchanged, the pointers in the pointer array
are exchanged, not the text lines themselves.</p>
<pre><code>+---+                         +---+
|   |                         |   |
|   |       +--------+        |   |               +--------+
| *--------&gt;| defghi |        | *-----------+  +-&gt;| defghi |
|   |       +--------+        |   |         |  |  +--------+
|   |                         |   |  +---------+
|   |       +-------------+   |   |  |      |     +-------------+
| *--------&gt;| jklmnopqrst |   | *----+   +-------&gt;| jklmnopqrst |
|   |       +-------------+   |   |      |  |     +-------------+
|   |                         |   |      |  |
|   |       +-----+           |   |      |  |     +-----+
| *--------&gt;| abc |           | *--------+  +----&gt;| abc |
|   |       +-----+           |   |               +-----+
|   |                         |   |
+---+                         +---+
</code></pre>
<p>This eliminates the twin problems of complicated storage management and high
overhead that would go with moving the lines themselves.</p>
<p>The sorting process has three steps:</p>
<pre><code>
read all the lines of input
sort them
print them in order

</code></pre>
<p>As usual, it’s best to divide the program into functions that match this
natural division, with the main routine controlling the other functions. Let us
defer the sorting method for a moment, and concentrate on the data structure
and the input and output.</p>
<p>The input routine has to collect and save the characters of each line, and
build an array of pointers to the lines. It will also have to count the number
of input lines, since that information is needed for sorting and printing.
Since the input function can only cope with a finite number of input lines, it
can return some illegal line count like <code>-1</code> if too much input is presented.</p>
<p>The output routine only has to print the lines in the order in which they
appear in the array of pointers.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAXLINES 5000       /* max #lines to be sorted */

char *lineptr[MAXLINES];    /* pointers to text lines */

int readlines(char *lineptr[], int nlines);
void writelines(char *lineptr[], int nlines);

void qsort(char *lineptr[], int left, int right);

/* sort input lines */
main()
{
    int nlines;    /* number of input lines read */

    if ((nlines = readlines(lineptr, MAXLINES)) &gt;= 0) {
        qsort(lineptr, 0, nlines-1);
        writelines(lineptr, nlines);
        return 0;
    } else {
        printf(&quot;error: input too big to sort\n&quot;);
        return 1;
    }
}

#define MAXLEN 1000   /* max length of any input line */
int getline(char *, int);
char *alloc(int);

/* readlines: read input lines */
int readlines(char *lineptr[], int maxlines)
{
    int len, nlines;
    char *p, line[MAXLEN];

    nlines = 0;
    while ((len = getline(line, MAXLEN)) &gt; 0)
        if (nlines &gt;= maxlines || (p = alloc(len)) == NULL)
            return -1;
        else {
            line[len-1] = '\0'; /* delete newline */
            strcpy(p, line);
            lineptr[nlines++] = p;
        }
    return nlines;
}

/* writelines:  write output lines*/
void writelines(char *lineptr[], int nlines)
{
    int i;

    for (i = 0; i &lt; nlines; i++)
        printf(&quot;%s\n&quot;, lineptr[i]);
}
</code></pre>
<p>The function <code>getline</code> is from [Section @sec:char-arr].</p>
<p>The main new thing is the declaration for <code>lineptr</code>:</p>
<pre><code class="language-c">char *lineptr[MAXLINES]
</code></pre>
<p>says that <code>lineptr</code> is an array of <code>MAXLINES</code> elements, each element of which
is a pointer to a <code>char</code>. That is, <code>lineptr[i]</code> is a character pointer, and
<code>*lineptr[i]</code> is the character it points to, the first character of the <code>i</code>-th
saved text line.</p>
<p>Since <code>lineptr</code> is itself the name of an array, it can be treated as a pointer
in the same manner as in our earlier examples, and <code>writelines</code> can be written
instead as</p>
<pre><code class="language-c">/* writelines:  write output lines */
void writelines(char *lineptr[], int nlines)
{
    while (nlines-- &gt; 0)
        printf(&quot;%s\n&quot;, *lineptr++);
}
</code></pre>
<p>Initially <code>*lineptr</code> points to the first line each increment advances it to the
next line pointer while <code>nlines</code> is counted down.</p>
<p>With input and output under control, we can proceed to sorting. The quicksort
from [Chapter @sec:control-flow] needs minor changes: the declarations have to
be modified, and the comparison operation must be done by calling <code>strcmp</code>. The
algorithm remains the same, which gives us some confidence that it will still
work.</p>
<pre><code class="language-c">/* qsort:  sort v[left]...v[right] into increasing order */
void qsort(char *v[], int left, int right)
{
    int i, last;
    void swap(char *v[], int i, int j);

    if (left &gt;= right)   /* do nothing if array contains */
        return;          /* fewer than two elements */
    swap(v, left, (left + right)/2);
    last = left;
    for (i = left+1; i &lt;= right; i++)
        if (strcmp(v[i], v[left]) &lt; 0)
            swap(v, ++last, i);
    swap(v,left, last);
    qsort(v, left, last-1);
    qsort(v, last+1, right);
}
</code></pre>
<p>Similarly, the swap routine needs only trivial changes:</p>
<pre><code class="language-c">/* swap: interchange v[i] and v[j] */
void swap(char *v[], int i, int j)
{
    char *temp;
    v[i] = v[j];
    v[j] = temp;
}
</code></pre>
<p>Since any individual element of <code>v</code> (alias of <code>lineptr</code>) is a character
pointer, <code>temp</code> must be also, so one can be copied to the other.</p>
<p><strong>Exercise 5-7.</strong> Rewrite <code>readlines</code> to store lines in an array supplied by
<code>main</code>, rather than calling <code>alloc</code> to maintain storage. How much aster is the
program?</p>
<h2>Multi-dimensional Arrays</h2>
<p>C provides rectangular multi-dimensional arrays, although in practice they are
much less used than arrays of pointers. In this section, we will show some of
their properties.</p>
<p>Consider the problem of date conversion, from day of the month to day of the
year and vice versa. For example, March 1 is the 60-th day of a non-leap year,
and the 61st day of a leap year. Let us define two functions to do the
conversions: <code>day_of_year</code> converts the month and day into the day of the year,
and <code>month_day</code> converts the day of the year into the month and day. Since this
latter functions computes two values, the month and day arguments will be
pointers:</p>
<pre><code class="language-c">month_day(1988, 60, &amp;m, &amp;d)
</code></pre>
<p>sets <code>m</code> to <code>2</code> and <code>d</code> to <code>29</code> (February 29th).</p>
<p>These functions both need the same information, a table of the number of days
in each month (“thirty days hath September …”). Since the number of days per
month differs for leap years and non-leap years, it’s easier to separate them
into two rows of a two-dimensional array than to keep track of what happens to
February during computation. The array and the functions for performing the
transformations are as follows:</p>
<pre><code class="language-c">static char daytab[2][13] = {
    {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
    {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
}

/* day_of_year:  set day of year from month &amp; day */
int day_of_year(int year, int month, int day)
{
    int i, leap;

    leap = year%4 == 0 &amp;&amp; year%100 != 0 || year%400 = 0;
    for (i = 1; i &lt; month; i++)
        day += daytab[leap][i];
    return day;
}

/* month_day:  set month, dat from day of year */
void month_day(int year, int yearday, int *pmonth, int *pday)
{
    int i, leap;

    leap = year%4 == 0 &amp;&amp; year%100 != 0 || year%400 = 0;
    for (i = 1; yearday &gt; daytab[leap][i]; i++)
        yearday -= daytab[leap][i];
    *pmonth = i;
    *pday = yearday;
}
</code></pre>
<p>Recall that the arithmetic value of a logical expression, such as the one for
<code>leap</code>, is either zero (false) or one (true), so it can be used as a subscript
of the array <code>daytab</code>.</p>
<p>The array <code>daytab</code> has to be external to both <code>day_of_year</code> and <code>month_day</code>, so
they can both use it. We made it <code>char</code> to illustrate a legitimate use of
<code>char</code> for storing small non-character integers.</p>
<p><code>daytab</code> is the first two-dimensional array we have dealt with. In C, a
two-dimensional array is really a one-dimensional array, each of whose elements
is an array. Hence subscripts are written as</p>
<pre><code class="language-c">daytab[i][j]    /* [row][col */
</code></pre>
<p>rather than</p>
<pre><code class="language-c">daytab[i,j]     /* WRONG */
</code></pre>
<p>Other than this notational distinction, a two-dimensional array can be treated
in much the same way as in other languages. Elements are stored by rows, so
they rightmost subscript, or column, varies fastest as elements are accessed in
storage order.</p>
<p>An array is initialized by a list of initializers in braces; each row of a
two-dimensional array is initialized by a corresponding sub-list. We started
the array <code>daytab</code> with a column of zero so that month numbers can run from the
natural <code>1</code> to <code>12</code> instead of <code>0</code> to <code>11</code>. Since space is not at a premium
here, this is clearer than adjusting the indices.</p>
<p>If a two-dimensional array is to be passed to a function, the parameter
declaration in the function must include the number of columns; the number of
rows is irrelevant, since what is passed is, as before, a pointer to an array
of rows, where each row is an array of <code>13 ints</code>. In this particular case, it
is a pointer to objects that are arrays of <code>13 ints</code>. Thus if the array
<code>daytab</code> is to be passed to a function <code>f</code>, the declaration of <code>f</code> would be</p>
<pre><code class="language-c">f(int daytab[2][13]) { ... }
</code></pre>
<p>It could also be</p>
<pre><code class="language-c">f(int daytab[][13]) { ... }
</code></pre>
<p>since the number of rows is irrelevant, or it could be</p>
<pre><code class="language-c">f(int (*daytab)[13]) { ... }
</code></pre>
<p>which says that the parameter is a pointer to an array of 13 integers. The
parentheses are necessary since brackets <code>[]</code> have higher precedence than <code>*</code>.
Without parentheses, the declaration</p>
<pre><code class="language-c">int *daytab[13]
</code></pre>
<p>is an array of 13 pointers to integers. More generally, only the first
dimension (subscript) of an array is free; all the others have to be specified.</p>
<p>[Section @sec:complicated-decs] has a further discussion of complicated
declarations.</p>
<p><strong>Exercise 5-8.</strong> There is no error checking in <code>day_of_year</code> or <code>month_day</code>.
Remedy this defect.</p>
<h2>Initialization of Pointer Arrays</h2>
<p>Consider the problem of writing a function <code>month_name(n)</code>, which returns a
pointer to a character string containing the name of the <code>n</code>-th month. This is
an ideal application for an internal <code>static</code> array. <code>month_name</code> contains a
private array of character strings, and returns a pointer to the proper one
when called. This section shows how that array of names is initialized.</p>
<p>The syntax is similar to previous initializations:</p>
<pre><code class="language-c">/* month_name:  return name of `n`-th month */
char *month_name(int n)
{
    static char *name[] = {
        &quot;Illegal month&quot;,
        &quot;January&quot;, &quot;February&quot;, &quot;March&quot;,
        &quot;April&quot;, &quot;May&quot;, &quot;June&quot;,
        &quot;July&quot;, &quot;August&quot;, &quot;September&quot;,
        &quot;October&quot;, &quot;November&quot;, &quot;December&quot;
    };

    return (n &lt; 1 || n &gt; 12) ? name[0] : name[n];
}
</code></pre>
<p>The declaration of <code>name</code>, which is an array of character pointers, is the same
as <code>lineptr</code> in the sorting example. The initializer is a list of character
strings; each is assigned to the corresponding position in the array. The
characters of the <code>i</code>-th string are placed somewhere, and a pointer to them is
stored in <code>name[i]</code>. Since the size of the array <code>name</code> is not specified, the
compiler counts the initializer and fills in the correct number.</p>
<h2>Pointers vs. Multi-dimensional Arrays</h2>
<p>Newcomers to C are sometimes confused about the difference between a
two-dimensional array and an array of pointers, such as <code>name</code> in the example
above. Given the definitions</p>
<pre><code class="language-c">int a[10][20];
int *b[10];
</code></pre>
<p>then <code>a[3][4]</code> and <code>b[3][4]</code> are both syntactically legal references to a
single <code>int</code>. But <code>a</code> is a true two-dimensional array: 200 <code>int</code>-sized
locations have been set aside, and the conventional rectangular subscript
calculation $20 \times row + col$ is used to find the element <code>a[row][col]</code>.
For <code>b</code>, however, the definition only allocates 10 pointers and does not
initialize them; initialization must be done explicitly, either statically or
with code. Assuming that each element of <code>b</code> does point to a twenty-element
array, then there will be 200 <code>int</code>s set aside, plus ten cells for the
pointers. The important advantage of the pointer array is that the rows of the
arrays may be of different lengths. That is, each element of <code>b</code> need not point
to a twenty-element vector; some may point to two elements, some to fifty, and
some to none at all.</p>
<p>Although we have phrased this discussion in terms of integers, by far the most
frequent use of arrays of pointers is to store character strings of diverse
lengths, as in the function <code>month_name</code>. Compare the declaration and picture
of an array of pointers:</p>
<pre><code class="language-c">char *name[] = { &quot;Illegal month&quot;, &quot;Jan, &quot;Feb&quot;, &quot;Mar&quot; };
</code></pre>
<pre><code>name:
  +---+
  |   |
  |   |       +-----------------+
  | *--------&gt;| Illegal month\0 |
  |   |       +-----------------+
  |   |
  |   |       +-------+
  | *--------&gt;| Jan\0 |
  |   |       +-------+
  |   |
  |   |       +-------+
  | *--------&gt;| Feb\0 |
  |   |       +-------+
  |   |
  |   |       +-------+
  | *--------&gt;| Mar\0 |
  |   |       +-------+
  |   |
  +---+
</code></pre>
<p>with those for a two-dimensional array:</p>
<pre><code class="language-c">char aname[][15] = { &quot;Illegal month&quot;, &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot; };
</code></pre>
<pre><code>+--------------------------------------------------------------+
| Illegal month\0 Jan            Feb\0          Mar\0          |
+--------------------------------------------------------------+
  0               15             30             45
</code></pre>
<p><strong>Exercise 5-9.</strong> Rewrite the routines <code>day_of_year</code> and <code>month_day</code> with
pointers instead of indexing.</p>
<h2>Command-line Arguments</h2>
<p>In environments that support C, there is a way to pass command-line arguments
or parameters to a program when it begins executing. When <code>main</code> is called, it
is called with two arguments. The first (conventionally called <code>argc</code>, for
argument count) is the number of command-line arguments the program was invoked
with; the second (<code>argv</code>, for argument vector) is a pointer to an array of
character strings that contain the arguments, one per string. We customarily
use multiple levels of pointers to manipulate these character strings.</p>
<p>The simplest illustration is the program <code>echo</code>, which echoes its command-line
arguments on a single line, separated by blanks. That is, the command</p>
<pre><code class="language-sh">echo hello, world
</code></pre>
<p>prints the output</p>
<pre><code>hello, world
</code></pre>
<p>By convention, <code>argv[0]</code> is the name by which the program was invoked, so
<code>argc</code> is at least 1. If <code>argc</code> is 1, there are no command-line arguments after
the program name. In the example above, <code>argc</code> is 3, and <code>argv[0]</code>, <code>argv[1]</code>,
and <code>argv[2]</code> are “<code>echo</code>”, “<code>hello,</code>”, and “<code>world</code>” respectively. The first
optional argument is <code>argv[1]</code> and the last is <code>argv[argc-1]</code>; additionally,
the standard requires that <code>argv[argc]</code> be a null pointer.</p>
<pre><code>argv:
 +---+     +---+
 | *------&gt;|   |
 +---+     |   |       +--------+
           | *--------&gt;| echo\0 |
           |   |       +--------+
           |   |
           |   |       +----------+
           | *--------&gt;| hello,\0 |
           |   |       +----------+
           |   |
           |   |       +---------+
           | *--------&gt;| world\0 |
           |   |       +---------+
           |   |
           |   |
           | 0 |
           |   |
           |   |
           +---+
</code></pre>
<p>The first version of <code>echo</code> treats <code>argv</code> as an array of character pointers:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

/* echo command-line arguments; 1st version */
main(int argc, char *argv[])
{
    int i;

    for (i = 1; i &lt; argc; i++)
        printf(&quot;%s%s&quot;, argv[i], (i &lt; argc-1) ? &quot; &quot; : &quot;&quot;);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<p>Since <code>argv</code> is a pointer to an array of pointers, we can manipulate the
pointer rather than index the array. This next variation is based on
incrementing <code>argv</code>, which is a pointer to a pointer to <code>char</code>, while <code>argc</code> is
counted down:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

/* echo command-line arguments; 2nd version */
main(int argc, char *argv[])
{
    while (--argc &gt; 0)
        printf(&quot;%s%s&quot;, *++argv, (argc &gt; 1) ? &quot; &quot; : &quot;&quot;);
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
<p>Since <code>argv</code> is a pointer to the beginning of the array of argument strings,
incrementing it by 1 (<code>++argv</code>) makes it point to the original <code>argv[1]</code>
instead of <code>argv[0]</code>. Each successive increment moves it along to the next
argument; <code>*argv</code> is then the pointer to that argument. At the same time,
<code>argc</code> is decremented; when it becomes zero, there are no arguments left to
print.</p>
<p>Alternatively, we could write the <code>printf</code> statement as</p>
<pre><code class="language-c">printf((argc &gt; 1) ? &quot;%s &quot; : &quot;%s&quot;, *++argv);
</code></pre>
<p>This shows that the format argument of <code>printf</code> can be an expression too.</p>
<p>As a second example, let us make some enhancements to the pattern-finding
program from [Section @sec:functions]. If you recall, we wired the search
pattern deep into the program, an obviously unsatisfactory arrangement.
Following the lad of the UNIX program <code>grep</code>, let us change the program so the
pattern to be matched is specified by the first argument on the command line.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define MAXLINE 1000

int getline(char *line, int max);

/* find:  print lines that match pattern from 1st arg */
main(int argc, char *argv[])
{
    char line[MAXLINE];
    int found = 0;

    if (argc != 2)
        printf(&quot;Usage: find pattern\n&quot;);
    else
        while (getline(line, MAXLINE) &gt; 0)
            if (strstr(line, argv[1]) != NULL) {
                printf(&quot;%s&quot;, line);
                found++;
            }
    return found;
}
</code></pre>
<p>The standard library function <code>strstr(s,t)</code> returns a pointer to the first
occurrence of the string <code>t</code> in the string <code>s</code>, or <code>NULL</code> if there is none. It
is declared in <code>&lt;string.h&gt;</code>.</p>
<p>The model can now be elaborated to illustrate further pointer constructions.
Suppose we want to allow two optional arguments. One says “print all lines
<em>except</em> those that match the pattern;” the second says “precede each printed
line by its line number.”</p>
<p>A common convention for C programs on UNIX systems is that an argument that
begins with a minus sign introduces an optional flag or parameter. If we choose
<code>-x</code> (for “except”) to signal the inversion, and <code>-n</code> (“number”) to request
line numbering, then the command</p>
<pre><code class="language-sh">find -x -n pattern
</code></pre>
<p>will print each line that doesn’t match the patter, preceded by its line
number.</p>
<p>Optional arguments should be permitted in any order, and the rest of the
program should be independent of the number of arguments that were present.
Furthermore, it is convenient for users if optional arguments can be combined,
as in</p>
<pre><code class="language-sh">find -nx pattern
</code></pre>
<p>Here is the program:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#define MAXLINE 1000

int getline(char *line, int max);

/* find:  print lines that match pattern from 1st arg */
main(int argc, char *argv[])
{
    char line[MAXLINE];
    long lineno = 0;
    int c, except = 0, number = 0, found = 0;

    while (--argc &gt; 0 &amp;&amp; (*++argv)[0] == '-')
        while (c = *++argv[0])
            switch (c) {
            case 'x':
                except = 1;
                break;
            case 'n':
                number = 1;
                break;
            default:
                printf(&quot;find: illegal option %c\n&quot;, c);
                argc = 0;
                found = -1;
                break;
            }
    if (argc != 1)
        printf(&quot;Usage: find: -x -n pattern\n&quot;);
    else
        while (getline(line, MAXLINE) &gt; 0) {
            lineno++;
            if ((strstr(line, *argv) != NULL) != except) {
                if (number)
                    prtinf(&quot;%ld:&quot;, lineno);
                printf(&quot;%s&quot;, line);
                found++;
            }
        }
    return found;
}
</code></pre>
<p><code>argc</code> is decremented and <code>argv</code> is incremented before each optional argument.
At the end of the loop, there are no errors, <code>argc</code> tells how many arguments
remain unprocessed and <code>argv</code> points to the first of these. Thus <code>argc</code> should
be 1 and <code>*argv</code> should point at the pattern. Notice that <code>*++argv</code> is a
pointer to an argument string, so <code>(*++argv)[0]</code> is its first character. (An
alternative valid form would be <code>**++argv</code>.) Because <code>[ ]</code> binds tighter than
<code>*</code> and <code>++</code>, the parentheses are necessary; without them the expression would
be taken as <code>*++(argv[0])</code>. In fact, that is what we used in the inner loop,
where the task is to walk along a specified argument string. In the inner loop,
the expression <code>*++argv[0]</code> increments the pointer <code>argv[0]</code>!</p>
<p>It is rare that one uses pointer expressions more complicated than these; in
such cases, breaking them into two or three steps will be more intuitive.</p>
<p><strong>Exercise 5-10.</strong> Write the program <code>expr</code>, which evaluates a reverse Polish
expression from the command line, where each operator or operand is a separate
argument. For example,</p>
<pre><code class="language-sh">expr 2 3 4 + *
</code></pre>
<p>evaluates $2 \times (3+$)$.</p>
<p><strong>Exercise 5-11.</strong> Modify the programs <code>entab</code> and <code>detab</code> (written as
exercises in [Chapter @sec:introduction]) to accept a list of tab stops as
arguments. Use the default tab settings if there are no arguments.</p>
<p><strong>Exercise 5-12.</strong> Extend <code>entab</code> and <code>detab</code> to accept the shorthand</p>
<pre><code class="language-sh">entab -m +n
</code></pre>
<p>to mean tab stops every <em>n</em> columns, starting at column <em>m</em>. Choose convenient
(for the user) default behavior.</p>
<p><strong>Exercise 5-13.</strong> Write the program <code>tail</code>, which prints the last <em>n</em> lines of
its input. By default, <em>n</em> is 10, let us say, but it can be changed by an
optional argument, so that</p>
<pre><code class="language-sh">tail -n
</code></pre>
<p>prints the last <em>n</em> lines. The program should behave rationally no matter how
unreasonable the input or the value of <em>n</em>. Write the program so it makes the
best use of available storage; lines should be stored as in the sorting program
of [Section @sec:pointer-to-pointer], not in a two-dimensional array of fixed
size.</p>
<h2>Pointers to Functions {#sec:p-to-f}</h2>
<p>In C, a function itself is not a variable, but it is possible to define
pointers to functions, which can be assigned, placed in arrays, passed to
functions, returned by functions, and so on. We will illustrate this by
modifying the sorting procedure written earlier in this chapter so that if the
optional argument <code>-n</code> is given, it will sort the input lines numerically
instead of lexicographically.</p>
<p>A sort often consists of three parts—a comparison that determines the
ordering of any pair of objects, and change that reverses their order, and a
sorting algorithm that makes comparisons and exchanges until the objects are in
order. The sorting algorithm is independent of the comparison and exchange
operations, so by passing different comparison and exchange functions to it, we
can arrange to sort by different criteria. This is the approach taken in our
new sort.</p>
<p>Lexicographic comparison of two lines is done by <code>strcmp</code>, as before; we will
also need a routine <code>numcmp</code> that compares two lines on the basis of numeric
value and returns the kind of condition indication as <code>strcmp</code> does. These
functions are declared ahead of <code>main</code> and a pointer t the appropriate one is
passed to <code>qsort</code>. We have skimped on error processing for arguments, so as to
concentrate on the main issues.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define MAXLINES 5000     /* max #lines to be sorted */
char *lineptr[MAXLINES];  /* pointers to text lines */

int readlines(char *lineptr[], int nlines);
void writelines(char *lineptr[]. int nlines);

void qsort(void *lineptr[], int left, int right,
           int (*comp)(void *, void *));
int numcmp(char *, char *);

/* sort input lines */
main(int argc, char *argv[])
{
    int nlines;           /* number of input lines read */
    int numeric = 0;      /* 1 if numeric sort */

    if (argc &gt; 1 &amp;&amp; strcmp(argv[1], &quot;-n&quot;) == 0)
        numeric = 1;
    if ((nlines = readlines(lineptr, MAXLINES)) &gt;= 0) {
        qsort((void **) lineptr, 0, nlines-1,
          (int (*)(void*,void*))(numeric ? numcmp : strcmp));
        writelines(lineptr, nlines);
        return 0;
    } else {
        printf(&quot;input too big to sort\n&quot;);
        return 1;
    }
}
</code></pre>
<p>In the call to <code>qsort</code>, <code>strcmp</code> and <code>numcmp</code> are addresses of functions. Since
they are known to be functions, the <code>&amp;</code> operator is not necessary, in the same
way that it is not needed before an array name.</p>
<p>We have written <code>qsort</code> so it can process any data type, not just character
strings. As indicated by the function prototype, <code>qsort</code> expects an array of
pointers, two integers, and a function with two pointer arguments. The generic
pointer type <code>void *</code> is used for the pointer arguments. Any pointer can be
cast to <code>void *</code> and back again without loss of information, so we can call
<code>qsort</code> by casting arguments to <code>void *</code>. The elaborate cast of the function
argument casts the arguments of the comparison function. These will generally
have no effect on actual representation, but assure the compiler that all is
well.</p>
<pre><code class="language-c">/* qsort:  sort v[left]...v[right] into increasing order */
void qsort(void *v[], int left, int right,
           int (*comp)(void *, void *))
{
    int i, last;
    void swap(void *v[], int, int);

    if (left &gt;= right(  /* do nothing if array contains */
        return;         /* fewer than two elements */
    swap(v, left, (left + right)/2);
    last = left;
    for (i = left+1; i &lt;= right; i++)
        if ((*comp)(v[i], v[left]) &lt; 0)
            swap(v, ++last, i);
    swap(v, left, last);
    qsort(v, left, last-1, comp);
    qsort(v, last+1, right, comp);
}
</code></pre>
<p>The declarations should be studied with some care. The fourth parameter of
<code>qsort</code> is</p>
<pre><code class="language-c">int (*comp)(void *, void *)
</code></pre>
<p>which says that <code>comp</code> is a pointer to a function that has two <code>void *</code>
arguments and returns an <code>int</code>.</p>
<p>The use of <code>comp</code> in the line</p>
<pre><code class="language-c">if ((*comp)(v[i], v[left]) &lt; 0)
</code></pre>
<p>is consistent with the declaration: <code>comp</code> is a pointer to a function, <code>*comp</code>
is the function, and</p>
<pre><code class="language-c">(*comp)(v[i], v[left])
</code></pre>
<p>is the call to it. The parentheses are needed so the components are correctly
associated; without them,</p>
<pre><code class="language-c">int *comp(void *, void *)    /* WRONG */
</code></pre>
<p>says that <code>comp</code> is a function returning a pointer to an <code>int</code>, which is very
different.</p>
<p>We have already shown <code>strcmp</code>, which compares two strings. Here is <code>numcmp</code>,
which compares two strings on a leading numeric value, computed by calling
<code>atof</code>:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

/* numcmp:  compare s1 and s2 numerically */
int numcmp(char *s1, char *s2)
{
    double v1, v2;

    v1 = atof(s1);
    v2 = atof(s2);
    if (v1 &lt; v2)
        return -1;
    else if (v1 &gt; v2)
        return 1;
    else
        return 0;
}
</code></pre>
<p>The <code>swap</code> function, which exchanges two pointers, is identical to what we
presented earlier in the chapter, except that the declarations are changed to
<code>void *</code>.</p>
<pre><code class="language-c">void swap(void *v[], int i, int j)
{
    void *temp;
    temp = v[i];
    v[i] = v[j];
    v[j] = temp;
}
</code></pre>
<p>A variety of other options can be added to the sorting program; some make
challenging exercises.</p>
<p><strong>Exercise 5-14.</strong> Modify the sort program to handle a <code>-r</code> flag, which
indicates sorting in reverse (decreasing) order. Be sure that <code>-r</code> works with
<code>-n</code>.</p>
<p><strong>Exercise 5-15.</strong> Add the option <code>-f</code> to fold upper and lower case together,
so that case distinctions are not made during sorting; for example, <code>a</code> and <code>A</code>
compare equal.</p>
<p><strong>Exercise 5-16.</strong> Add the <code>-d</code> (“directory order”) option, which makes
comparisons only on letters, numbers and blanks. Make sure it works in
conjunction with <code>-f</code>.</p>
<p><strong>Exercise 5-17.</strong> Add a field-handling capability, so sorting may be done
infields within lines, each field sorted according to an independent set of
options. (The index for this book was sorted with <code>-df</code> for the index category
and <code>-n</code> for the page numbers.)</p>
<h2>Complicated Declarations {#sec:complicated-decs}</h2>
<p>C is sometimes castigated for the syntax of its declarations, particularly the
ones that involve pointers to functions. The syntax is an attempt to make the
declaration and the use agree; it works well for simple cases, but it can be
confusing for the harder ones, because declarations cannot be read left to
right, and because parentheses are over-used. The difference between</p>
<pre><code class="language-c">int *f();       /* f: function returning pointer to int */
</code></pre>
<p>and</p>
<pre><code class="language-c">int (*pf)();    /* pf: pointer to function returning int */
</code></pre>
<p>illustrates the problem: <code>*</code> is a prefix operator and it has lower precedence
than <code>( )</code>, so parentheses are necessary to force the proper association.</p>
<p>Although truly complicated declarations rarely arise in practice, it is
important to know how to understand them, and, if necessary, how to create
them. One good way to synthesize declarations is in small steps with <code>typedef</code>,
which is discussed in [Section @sec:typedef]. As an alternative, in this
section we will present a pair of programs that convert from valid C to a word
description and back again. The word descriptions read left to right.</p>
<p>The first, <code>dcl</code>, is the more complex. It converts a C declaration into a word
description, as in these examples:</p>
<pre><code>char **argv
    argv:  pointer to pointer to char
int (*daytab)[13]
    daytab:  pointer to array[13] of int
int *daytab[13]
    daytab:  array[13] of pointer to int
void *comp()
    comp:  function returning poitner to void
void (*comp)()
    comp:  pointer to function returning void
char (*(*x())[])()
    x: function returning pointer to array[] of
    pointer to function returning char
char (*(*x[3])())[5]
    x: array[3] of pointer to function returning
    pointer to array[5] of char
</code></pre>
<p><code>dcl</code> is based on the grammar that specifies a declarator, which is spelled out
precisely in [Section  @sec:declarators]; this is a simplified form:</p>
<pre><code>dcl:           optional *'s direct-dcl
direct-dcl:    name
               (decl)
               directl-dcl()
               direct-dcl[optional size]
</code></pre>
<p>In words, a <em>dcl</em> is a <em>direct-dcl</em>, perhaps precede by <code>*</code>’s. A <em>direct-dcl</em>
is a name, or a parenthesized <em>dcl</em>, or a <em>direct-dcl</em> followed by parentheses,
or a <em>direct-dcl</em> followed by brackets with an optional size.</p>
<p>This grammar can be used to parse declarations. For instance, consider this
declarator:</p>
<pre><code class="language-c">(*pfa[])()
</code></pre>
<p><code>pfa</code> will be identified as a <em>name</em> and thus as a <em>direct-dcl</em>. Then <code>pfa[]</code>
is also a <em>direct-dcl</em>. Then <code>*pfa[]</code> is a recognized as a <em>dcl</em>, so <code>(*pfa[])</code>
is a <em>direct-dcl</em>. Then <code>(*pfa[])()</code> is a <em>direct-dcl</em> and thus a <em>dcl</em>. We can
also illustrate the parse with a parse tree like this (where <em>direct-dcl</em> has
been abbreviated to <em>dir-dcl</em>):</p>
<pre><code>(  *        pfa      []  ) ()
 \  \        |       /  /  /
  \  \     name     /  /  /
   \  \      |     /  /  /
    \  \  dir-dcl /  /  /
     \  \    |   /  /  /
      \  \dir-dcl  /  /
       \  \  |    /  /
        \   dcl  /  /
         \   |  /  /
          dir-dcl /
             |   /
          dir-dcl
             |
            dcl
</code></pre>
<p>The heart of the <code>dcl</code> program is a pair of functions, <code>dcl</code> and <code>dirdcl</code>, that
parse a declaration according to this grammar. Because the grammar is
recursively defined, the functions call each other recursively as they
recognize pieces of a declaration; the program is called a recursive-descent
parser.</p>
<pre><code class="language-c">/* dcl:  parse a declarator */
void dcl(void)
{
    int ns;

    for (ns = 0; gettoken() == '*'; )   /* count *'s */
        ns++;
    dirdcl();
    while (ns-- &gt; 0)
        strcat(out, &quot; pointer to&quot;);
}

/* dirdcl:  parse a direct declarator */
void dirdcl(void)
{
    int type;

    if (tokentype == '(') {          /* ( dcl ) */
        dcl();
        if (tokentype != ')')
            printf(&quot;error: missing )\n&quot;);
    } else if (tokentype == NAME)    /* variable name */
        strcpy(name, token);
    else
        printf(&quot;error: expected name of (dcl)\n&quot;);
    while ((type=gettoken()) == PARENS || type == BRACKETS)
        if (type == PARENS)
            strcat(out, &quot; function returning&quot;);
        else {
            strcat(out, &quot; array&quot;);
            stract(out, token);
            strcat(out, &quot; of&quot;);
        }
}
</code></pre>
<p>Since the programs are intended to be illustrative, not bullet-proof, there are
significant restrictions on <code>dcl</code>. It can only handle a simple data type like
<code>char</code> or <code>int</code>. It does not handle argument types in functions, or qualifiers
like <code>const</code>. Spurious blanks confuse it. It doesn’t do much error recovery, so
invalid declarations will also confuse it. These improvements are left as
exercises.</p>
<p>Here are the global variables and the main routine:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

#define  MAXTOKEN   100

enum { NAME, PARENS, BRACKETS };

void dcl(void);
void dirdcl(void);

int gettoken(void);
int tokentype;            /* type of last token */
char token[MAXTOKEN];     /* last token string */
char name[MAXTOKEN];      /* identifier name */
char datatype[MAXTOKEN];  /* data type = char, int, etc. */
char out[1000];           /* output string */

main() /*convert declaration to words */
{
    while (gettoken() !+ EOF) {   /* 1st token on line */
        strcpy(datatype, token);  /* is the datatype */
        out[0] = '\0';
        dcl();      /* parse rest of line */
        if (tokentype != '\n')
            printf(&quot;syntax error\n&quot;);
        printf(&quot;%s: $s $s\n&quot;, name, out, datatype);
    }
    return 0;
}
</code></pre>
<p>The function <code>gettoken</code> skips blanks and tabs, then finds the next token in the
input; a “token” is a name, a pair of parentheses, a pair of brackets perhaps
including a number, or any other single character.</p>
<pre><code class="language-c">int gettoken(void)  /* return next token */
{
    int c, getch(void);
    void ungetch(int);
    char *p = token;

    while ((c = getch()) == '' || c == '\t')
        ;
    if (c == '(') {
        if ((c = getch()) == ')') {
            strcpy(token, &quot;()&quot;);
            return tokentype = PARENS;
        } else {
            ungetch(c);
            return tokentype = '(';
        }
    } else if (c == '[') {
        for (*p++ = c; (*0++ = getch()) != ']'; )
            ;
        *p = '\0';
        return tokentype = BRACKETS;
    } else if (isalpha(c)) {
        for (*p++ = c; isalnum(n = getch()); )
            *p++ = c;
        *p = '\0';
        ungetch(c);
        return tokentype = NAME;
    } else
        return tokentype = c;
}
</code></pre>
<p><code>getch</code> and <code>ungetch</code> were discussed in [Chapter @sec:functions].</p>
<p>Going in the other direction is easier, especially if we do not worry about
generating redundant parentheses. The program <code>undcl</code> converts a word
description like “<code>x</code> is a function returning a pointer to an array of pointers
to functions returning char,” which we will express as</p>
<pre><code>x () * [] * () char
</code></pre>
<p>to</p>
<pre><code class="language-c">char (*(*x())[])()
</code></pre>
<p>The abbreviated input syntax lets use reuse the <code>gettoken</code> function. <code>undcl</code>
also uses the same external variables as <code>dcl</code> does.</p>
<pre><code class="language-c">/* undcl:  convert word description to declaration */
main()
{
    int type;
    char temp[MAXTOKEN];

    while (gettoken() != EOF) {
        strcpy(out, token);
        while ((type = gettoken()) != '\n')
            if (type == PARENS || type == BRACKETS)
                strcat(out, token);
            else if (type == '*') {
                sprintf(temp, &quot;(*%s)&quot;, out);
                strcpy(out, temp);
            } else if (type == NAME) {
                sprintf(temp, &quot;%s %s&quot;, token, out);
                strcpy(out, temp);
            } else
                printf(&quot;Invalid input at %s\n&quot;, token);
        printf(&quot;%s\n&quot;, out);
    }
    return 0;
}
</code></pre>
<p><strong>Exercise 5-18.</strong> Make <code>dcl</code> recover from input errors.</p>
<p><strong>Exercise 5-19.</strong> Modify <code>undcl</code> so that it does not add redundant parentheses
to declarations.</p>
<p><strong>Exercise 5-20.</strong> Expand <code>dcl</code> to handle declarations with function argument
type, qualifiers like <code>const</code>, and so on.</p>
<h1>Structures {#sec:structures}</h1>
<p>A structure is a collection of one or more variables, possibly of different
types, grouped together under a single name for convenient handling.
(Structures are called “records” in some languages, notably Pascal.) Structures
help to organize complicated data, particularly in large programs, because they
permit a group of related variables to be treated as a unit instead of as
separate entities.</p>
<p>One traditional example of a structure is the payroll record: an employee is
described by a set of attributes such as name, address, social security number,
salary, etc. Some of these in turn could be structures: a name has several
components, as does an address and even a salary. Another example, more typical
for C, comes from graphics: a point is a pair of coordinates, a rectangle is a
pair of points, and so on.</p>
<p>The main change made by the ANSI standard is to define structure
assignment—structures may be copied and assigned to, passed to functions, and
returned by functions. This has been supported by most compilers for many
years, but the properties are now precisely defined. Automatic structures and
arrays may now also be initialized.</p>
<h2>Basics of Structures</h2>
<p>Let us create a few structure suitable for graphics. The basic object is a
point, which we will assume has an <em>x</em> coordinate and a <em>y</em> coordinate, both
integers.</p>
<pre><code>      y
      ^
      |
     ---
      |
     ---
      |
     ---              * (4,3)
      |
     ---
      |
     ---
      |
------*---|---|---|---|---|---|---------&gt; x
(0,0) |
      |
      |
</code></pre>
<p>The two components can be placed in a structure declared like this:</p>
<pre><code class="language-c">struct point {
    int x;
    int y;
};
</code></pre>
<p>The keyword <code>struct</code> introduces a structure declaration, which is a list of
declarations enclosed in braces. An optional name called a <em>structure tag</em> may
follow the word <code>struct</code> (as with <code>point</code> here). The tag names this kind of
structure, and can be used subsequently as a shorthand for the part of the
declaration in braces.</p>
<p>The variables named in a structure are called <em>members</em>. A structure member or
tag and an ordinary (i.e., non-member) variable can have the same name without
conflict, since they can always be distinguished by context. Furthermore, the
same member names may occur in different structures, although as a matter of
style on would normally use the same names only for closely related objects.</p>
<p>A <code>struct</code> declaration defines a type. The right brace that terminates the list
of members may be followed by a list of variables, just as for any basic type.
That is,</p>
<pre><code class="language-c">struct { ... } x, y, z;
</code></pre>
<p>is syntactically analogous to</p>
<pre><code class="language-c">int x, y, z;
</code></pre>
<p>in the sense that each statement declares <code>x</code>, <code>y</code> and <code>z</code> to be variables of
the named type and causes space to be set aside for them.</p>
<p>A structure declaration that is not followed by a list of variables reserves no
storage; it merely describes a template or the shape of a structure. If the
declaration is tagged, however, the tag can be used later in definitions of
instances of the structure. For example, given the declaration of <code>point</code>
above,</p>
<pre><code class="language-c">struct point pt;
</code></pre>
<p>defines a variable <code>pt</code> which is a structure of type <code>struct point</code>. A
structure can be initialized by following its definition with  a list of
initializers, each a constant expression for the members:</p>
<pre><code class="language-c">struct point maxpt = { 320. 200 };
</code></pre>
<p>An automatic structure may also be initialized by assignment or by calling a
function that returns a structure of the right type.</p>
<p>A member of a particular structure is referred to in an expression by a
construction of the form</p>
<pre><code>structure-name.member
</code></pre>
<p>The structure member operator “<code>.</code>” connects the structure name and the member
name. To print the coordinates of the point <code>pt</code>, for instance,</p>
<pre><code class="language-c">printf(&quot;%d,%d&quot;, pt.x, pt.y);
</code></pre>
<p>or to compute the distance from the origin $(0,0)$ to <code>pt</code>,</p>
<pre><code class="language-c">double dist, sqrt(double);

dist = sqrt((double)pt.x * pt.x + (double)pt.y * pt.y);
</code></pre>
<p>Structure can be nested. One representation of a rectangle is a pair of points
that denote the diagonally opposite corners:</p>
<pre><code>      y
      ^
      |
      |   +-------------------------* pt2
      |   |                         |
      |   |                         |
      |   |                         |
      |   |                         |
      |   |                         |
      |   |                         |
      |   *-------------------------+
      |   pt1
      |
------+---------------------------------&gt; x
      |
      |
      |
</code></pre>
<pre><code class="language-c">struct rect {
    struct point pt1;
    struct point pt2;
};
</code></pre>
<p>The <code>rect</code> structure contains two <code>point</code> structures. If we declare <code>screen</code> as</p>
<pre><code class="language-c">struct rect screen;
</code></pre>
<p>then</p>
<pre><code class="language-c">screen.pt1.x
</code></pre>
<p>refers to the <em>x</em> coordinate of the <code>pt1</code> member of <code>screen</code>.</p>
<h2>Structures and Functions</h2>
<p>The only legal operation on a structure are copying it or assigning to it as a
unit, taking its address with <code>&amp;</code>, and accessing its members. Copy and
assignment include passing arguments to functions and returning values from
functions as well. Structures may not be compared. A structure may also be
initialized by an assignment.</p>
<p>Let us investigate structures by writing some functions to manipulate points
and rectangles. There are at least three possible approaches: pass components
separately, pass an entire structure, or pass a pointer to it. Each has its
good points and bad points.</p>
<p>The first function, <code>makepoint</code>, will take two integers and return a <code>point</code>
structure:</p>
<pre><code class="language-c">/* makepoint:  make a point from x and y components */
struct point makepoint(int x, int y)
{
    struct point temp;

    temp.x = x;
    temp.y = y;
    return temp;
}
</code></pre>
<p>Notice that there is no conflict between the argument name and the member with
the same name; indeed the re-use of the name stresses the relationship.</p>
<p><code>makepoint</code> can now be used to initialize any structure dynamically, or to
provide structure arguments to a function:</p>
<pre><code class="language-c">struct rect screen;
struct point middle;
struct point makepoint(int, int);

screen.pt1 = makepoint(0, 0);
screen.pt2 = makepoint(XMAX, YMAX);
middle = makepoint((screen.pt1.x + screen.pt2.x)/2,
                   (screen.pt1.y + screen.pt2.y)/2);
</code></pre>
<p>The next step is a step of functions to do arithmetic on points. For instance,</p>
<pre><code class="language-c">/* addpoint:  add two points */
struct point addpoint(struct point p1, struct point p2)
{
    p1.x += p2.x;
    p1.y += p2.y;
    return p1;
}
</code></pre>
<p>Here both the arguments and the return value are structures. We incremented the
components in <code>p1</code> rather than using an explicit temporary variable to
emphasize that structure parameters are passed by value like any others.</p>
<p>As another example, the function <code>ptinrect</code> tests whether a point is inside a
rectangle, where we have adopted the convention that a rectangle includes its
left and bottom sides but not its top and right sides:</p>
<pre><code class="language-c">/* ptinrect:  return 1 if p in r, 0 if not */
int ptinrect(struct point p, struct rect t)
{
    return p.x &gt;= r.pt1.x &amp;&amp; p.x &lt; r.pt2.x
        &amp;&amp; p.y &gt;= r.pt1.y &amp;&amp; p.y &lt; r.pt2.y;
}
</code></pre>
<p>This assumes that the rectangle is represented in a standard form where the
<code>pt1</code> coordinates are less than the <code>pt2</code> coordinates. The following function
return a rectangle guaranteed to be in canonical form:</p>
<pre><code class="language-c">#define min(a, b) ((a) &lt; (b) ? (a) : (b))
#define max(a, b) ((a) &gt; (b) ? (a) : (b))

/* canonrect:  canonicalize coordinates of rectangle */
struct rect canonrect(struct rect t)
{
    struct rect temp;

    temp.pt1.x = min(r.pt1.x, r.pt2.x);
    temp.pt1.y = min(r.pt1.y, r.pt2.y);
    temp.pt2.x = max(r.pt1.x, r.pt2.x);
    temp.pt2.y = max(r.pt1.y, r.pt2.y);
    return temp;
}
</code></pre>
<p>If a large structure is to be passed to a function, it is generally more
efficient to pass a pointer than to copy the whole structure. Structure
pointers are just like pointers to ordinate variables. The declaration</p>
<pre><code class="language-c">struct point *pp;
</code></pre>
<p>says that <code>pp</code> is a pointer to a structure of type <code>struct point</code>. If <code>pp</code>
points to a <code>point</code> structure, <code>*pp</code> is the structure, and <code>(*pp).x</code> and
<code>(*pp).y</code> are the members. To use <code>pp</code>, we might write, for example,</p>
<pre><code class="language-c">struct point origin, *pp;

pp = &amp;origin;
printf(&quot;origin is (%d,%d)\n&quot;, (*pp).x, (*pp).y);
</code></pre>
<p>The parentheses are necessary in <code>(*pp).x</code> because the precedence of the
structure member operator <code>.</code> is higher than <code>*</code>. The expression <code>*pp.x</code> means
<code>*(pp.x)</code>, which is illegal here because <code>x</code> is not a pointer.</p>
<p>Pointers to structures are so frequently used that an alternative notation is
provided as a shorthand. If <code>p</code> is a pointer to a structure, then</p>
<pre><code class="language-c">p-&gt;member-of-strcture
</code></pre>
<p>refers to the particular member. (The operator <code>-&gt;</code> is a minus sign immediately
followed by <code>&gt;</code>.) So we could write instead</p>
<pre><code class="language-c">printf(:Origin is (%d,%d)\n&quot;, pp-&gt;x, pp-&gt;y);
</code></pre>
<p>Both <code>.</code> and <code>-&gt;</code> associate from left to right, so if we have</p>
<pre><code class="language-c">struct rect r, *rp = &amp;r;
</code></pre>
<p>then these four expressions are equivalent:</p>
<pre><code class="language-c">r.pt1.x
rp-&gt;pt1.x
(r.pt1).x
(rp-&gt;pt1).x
</code></pre>
<p>The structure operators <code>.</code> and <code>-&gt;</code>, together with <code>( )</code> for function calls
and <code>[ ]</code> for subscripts, are at the top of the precedence hierarchy and thus
bind very tightly. For example, given the declaration</p>
<pre><code class="language-c">struct {
    int len;
    char *str;
} *p;
</code></pre>
<p>then</p>
<pre><code class="language-c">++p-&gt;len
</code></pre>
<p>increments <code>len</code>, not <code>p</code>, because the implied parenthesizeation is
<code>++(p-&gt;len)</code>. Parentheses can be used to alter the binding: <code>(++p)-&gt;len</code>
increments <code>p</code> before accessing <code>len</code>, and <code>(p++)-&gt;len</code> increments <code>p</code>
afterward. (This last set of parentheses is unnecessary.)</p>
<p>In the same way, <code>*p-&gt;str</code> fetches whatever <code>str</code> points to; <code>*p-&gt;str++</code>
increments <code>str</code> after accessing whatever it points to (just like <code>*s++</code>);
<code>(*p-&gt;str)++</code> increments whatever <code>str</code> points to; and <code>*p++-&gt;str</code> increments
<code>p</code> after accessing whatever <code>str</code> points to.</p>
<h2>Arrays of Structures</h2>
<p>Consider writing a program to count the occurrences of each C keyword. We need
an array of character strings to hold the names, and an array of integers for
the counts. One possibility is to use two parallel arrays, <code>keyword</code> and
<code>keycount</code>, as in</p>
<pre><code class="language-c">char *keyword[NKEYS];
int keycount[NKEYS];
</code></pre>
<p>But the very fact that the arrays are parallel suggests a different
organization, an array of structures. Each keyword entry is a pair:</p>
<pre><code class="language-c">char *word;
int count;
</code></pre>
<p>and there is an array of pairs. The structure declaration</p>
<pre><code class="language-c">struct key {
    char *word;
    int count;
} keytab[NKEYS];
</code></pre>
<p>declares a structure of type <code>key</code>, defines an array <code>keytab</code> of structure of
this type, and sets aside storage for them. Each element of the array is a
structure. This could also be written</p>
<pre><code class="language-c">struct key {
    char *word;
    int count;
};

struct key keytab[NKEYS];
</code></pre>
<p>Since the structure <code>keytab</code> contains a constant set of names, it is easiest to
make it an external variable and initialize it once and for all when it is
defined. The structure initialization is analogous to earlier ones—the
definition is followed by a list of initializers enclosed in braces:</p>
<pre><code class="language-c">struct key {
    char *word;
    int count;
} keytab[] = {
    &quot;auto&quot;, 0,
    &quot;break&quot;, 0,
    &quot;case&quot;, 0,
    &quot;char&quot;, 0,
    &quot;const&quot;, 0,
    &quot;continue&quot;, 0,
    &quot;default&quot;, 0,
    /* ... */
    &quot;unsigned&quot;, 0,
    &quot;void&quot;, 0,
    &quot;volatile&quot;, 0,
    &quot;while&quot;, 0
};
</code></pre>
<p>The initializer are listed in pairs corresponding to the structure members. It
would be more precise to enclose initializers for each “row” or structure in
braces, as in</p>
<pre><code class="language-c">    { &quot;auto&quot;, 0 },
    { &quot;break&quot;, 0 },
    { &quot;case&quot;, 0 },
    ...
</code></pre>
<p>but the inner braces are not necessary when the initialisers are simple
variables or character strings, and when all are present. As usual, the number
of entries in the array <code>keytab</code> will be computed if initializers are present
and the <code>[ ]</code> is left empty.</p>
<p>The keyword-counting program begins with the definition of <code>keytab</code>. The main
routine reads the input by repeatedly calling a function <code>getword</code> that fetches
one word at a time. Each word is looked up in <code>keytab</code> with a version of the
binary search function that we wrote in [Chapter @sec:control-flow]. The list
of keywords must be sorted in increasing order in the table.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;

#define MAXWORD 100

int getword(char *, int);
int binsearch(char *, struct key *, int);

/* count C keyword */
main()
{
    int n;
    char word[MAXWORD];

    while (getword(word, MAXWORD) != EOF)
        if (isalpha(word[0]))
            if ((n = binsearch(word, keytab, NKEYS)) &gt;= 0)
                keytab[n].count++;
    for (n = 0; n &lt; NKEYS; n++)
        if (keytab[n].count &gt; 0)
            printf(&quot;%4d %s\n&quot;,
                keytab[n].count, keytab[n].word;
    return 0;
}

/* binsearch:  find word in tab[0]...tab[n-1] */
int binsearch(char *word, struct key tab[], int n)
{
    int cond;
    int low, high, mid;

    low = 0;
    high = n - 1;
    while (low &lt;= high) {
        mid = (low+high) / 2;
        if ((cond = strcmp(word, tab[mid].word)) &lt; 0)
            high = mid - 1;
        else if (cond &gt; 0)
            low = mid + 1;
        else
            return mid;
    }
    return -1;
}
</code></pre>
<p>We will show the function <code>getword</code> in a moment; for now it suffices to say
that each call to <code>getword</code> finds a word, which is copied into the array named
as its first argument.</p>
<p>The quantity <code>NKEYS</code> is the number of keywords in <code>keytab</code>. Although we could
count this by hand, it’s a lot easier and safer to do it by machine, especially
if the list is subject to change. One possibility would be to terminate the
list of initializer with a null pointer, then loop along <code>keytab</code> until the end
is found.</p>
<p>But this is more than is needed, since the size of the array is completely
determined at compile time. The size of the array is the size of one entry
times the number of entries, so the number of entries is just</p>
<pre><code>size of keytab / size of struct key
</code></pre>
<p>C provides a compile-time unary operator called <code>sizeof</code> that can be used to
compute the size of any object. The expressions</p>
<pre><code class="language-c">sizeof object
</code></pre>
<p>and</p>
<pre><code class="language-c">sizeof(type name)
</code></pre>
<p>yield an integer equal to the size of the specified object or type in bytes.
(Strictly, <code>sizeof</code> produces an unsigned integer value whose type, <code>size_t</code>, is
defined in the header <code>&lt;stddef.h&gt;</code>.) An object can be a variable or array or
structure. A type name can be the name of a basic type like <code>int</code> or <code>double</code>,
or a derived type like a structure or a pointer.</p>
<p>In our case, the number of keywords is the size of the array divided by the
size of one element. This computation is used in a <code>#define</code> statement to set
the value of <code>NKEYS</code>:</p>
<pre><code class="language-c">#define  NKEYS  (sizeof keytab / sizeof(struct key))
</code></pre>
<p>Another way to write this is to divide the array size by the size of a specific
element:</p>
<pre><code class="language-c">#define  NKEYS  (sizeof keytab / sizeof keytab[0])
</code></pre>
<p>This has the advantage that it does not need to be changed if the type changes.</p>
<p>A <code>sizeof</code> can not be used in a <code>#if</code> line, because the preprocessor does not
parse type names. But the expression in <code>#define</code> is not evaluated by the
preprocessor, so the code here is legal.</p>
<p>Now for the function <code>getword</code>. We have written a more general <code>getword</code> than
is necessary for this program, but it is not complicated. <code>getword</code> fetches the
next “word” from the input, where a word is either a string of letters and
digits beginning with a letter, or a single non-white space character. The
function value is the first character of the word, or <code>EOF</code> for the end of
file, or the character itself if it is not alphabetic.</p>
<pre><code class="language-c">/* getword:  get next word or character from input */
int getword(char *word, int lim)
{
    int c, getch(void);
    void ungetch(int);
    char *w = word;

    while (isspace(c = getch()))
        ;
    if (c != EOF)
        *w++ = c;
    if (!isalpha(c)) {
        *w = '\0';
        return c;
    }
    for ( ; --lim &gt; 0; w++)
        if (!isalnum(*w = getch())) {
            ungetch(*w);
            break;
        }
    *w = '\0';
    return word[0];
}
</code></pre>
<p><code>getword</code> uses the <code>getch</code> and <code>ungetch</code> that we wrote in [Chapter
@sec:functions]. When the collection of an alphanumeric token stops, <code>getword</code>
has gone one character too fat. The call to <code>ungetch</code> pushes that character
back on the input for the next call. <code>getword</code> also uses <code>isspace</code> to skip
white space, <code>isalpha</code> to identify letters, and <code>isalnum</code> to identify letters
and digits; all are from the standard header <code>&lt;ctype.h&gt;</code>.</p>
<p><strong>Exercise 6-1.</strong> Our version of <code>getword</code> does not properly handle
underscores, string constants, comments, or preprocessor control lines. Write a
better version.</p>
<h2>Pointers to Structures</h2>
<p>To illustrate some of the considerations involved with pointers to and arrays
of structures, let us write the keyword-counting program again, this time using
pointers instead of array indices.</p>
<p>The external declaration of <code>keytab</code> need not change, but <code>main</code> and
<code>binsearch</code> do need modifications.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#define MAXWORD 100

int getword(char *, int);
struct key *binsearch(char *, struct key *, int);

/* count C keywords; pointer version */
main()
{
    char word[MAXWORD];
    struct key *p;

    while (getword(word, MAXWORD) != EOF)
        if (isalpha(word[0]))
            if ((p=binsearch(word, keytab, NKEYS)) != NULL)
                p-&gt;count++;
    for (p = keytab; p &lt; keytab + NKEYS; o++)
        if (p-&gt;count &gt; 0)
            printf(&quot;%4d %s\n&quot;, p-&gt;count, p-&gt;word);
    return 0;
}

/* binsearch:  find word in tab[0]...tab[n-1] */
struct key *binsearch(char *word, struct key *tab, int n)
{
    int cond;
    struct key *low = &amp;tab[0];
    struct key *high = &amp;tab[n];
    struct key *mid;

    while (low &lt; high) {
        mid = low + (high-low) / 2;
        if ((cond = strcmp(word, mid-&gt;word)) &lt; 0)
            high = mid;
        else if (cond &gt; 0)
            low = mid + 1;
        else
            return mid;
    }
    return NULL;
}
</code></pre>
<p>There are several things worthy of note here. First, the declaration of
<code>binsearch</code> must indicate that it returns a pointer to <code>struct key</code> instead of
an integer; this is declared both in the function prototype and in <code>binsearch</code>.
If <code>binsearch</code> finds the word, it returns a pointer to it; if it fails, it
returns <code>NULL</code>.</p>
<p>Second, the elements of <code>keytab</code> are now accessed by pointers. This requires
significant changes in <code>binsearch</code>.</p>
<p>The initializers for <code>low</code> and <code>high</code> are now pointers to the beginning and
just past the end of the table.</p>
<p>The computation of the middle element can no longer be simply</p>
<pre><code class="language-c">mid = (low+high) / 2    /* WRONG */
</code></pre>
<p>because the addition of two pointers is illegal. Subtraction is legal, however,
so <code>high-low</code> is the number of elements, and thus</p>
<pre><code class="language-c">mid = low + (high-low) / 2
</code></pre>
<p>sets <code>mid</code> to point to the element halfway between <code>low</code> and <code>high</code>.</p>
<p>The most important change is to adjust the algorithm is to make sure that it
does not generate an illegal pointer to attempt to access an element outside
the array. The problem is that <code>&amp;tab[-1]</code> and <code>&amp;tab[n]</code> are both outside the
limits of the array tab. The former is strictly illegal, and it is illegal to
dereference the latter. The language definition does guarantee, however, that
pointer arithmetic that involves the first element beyond the end of an array
(that is, <code>&amp;tab[n]</code>) will work correctly.</p>
<p>In <code>main</code> we wrote</p>
<pre><code class="language-c">for (p = keytab; p &lt; keytab + NKEYS; p++)
</code></pre>
<p>If <code>p</code> is a pointer to a structure, arithmetic on <code>p</code> takes into account the
size of the structure, so <code>p++</code> increments <code>p</code> by the correct amount to get the
next element of the array of structures, and the test stops the loop at the
right time.</p>
<p>Don’t assume, however, that the size of a structure is the sum of the sizes of
its members. Because of alignment requirements for different objects, there may
be unnamed “holes” in a structure. Thus, for instance, if a <code>char</code> is one byte
and an <code>int</code> four bytes, the stucture</p>
<pre><code class="language-c">struct {
    char c;
    int i;
}
</code></pre>
<p>might well require eight bytes, not five. The <code>sizeof</code> operator returns the
proper value.</p>
<p>Finally, an aside on program format: when a function returns a complicated type
like a structure pointer, as in</p>
<pre><code class="language-c">struct key *binsrach(char *word, struct key *tab, int n)
</code></pre>
<p>the function name can be hard to see, and to find with a text editor.
Accordingly an alternate style is sometimes used:</p>
<pre><code class="language-c">struct key *
binsearch(char *word, struct key *tab, int n)
</code></pre>
<p>This is a matter of personal taste; pick the form you like and hold to it.</p>
<h2>Self-referential Structures {#sec:self-ref-struct}</h2>
<p>Suppose we want to handle the more general problem of counting the occurrences
of <em>all</em> the words in some input. Since the list of words isn’t known in
advance, we can’t conveniently  sort it and use a binary search. Yet we can’t
do a linear search for each word as it arrives, to see if it’s already been
seen; the program would take too long. (More precisely, its running time is
likely to grow quadratically with the number of input words.) How can we
organize the data to cope efficiently with a list of arbitrary words?</p>
<p>One solution is to keep the set of words seen so far sorted at all times, by
placing each word into its proper position in the order as it arrives. This
shouldn’t be done by shifting words in a linear array, though—that also takes
too long. Instead we will use a data structure called a <em>binary tree</em>.</p>
<p>The tree contains one “node” per distinct word; each node contains</p>
<pre><code>a pointer to the text of the word
a count of the number of occuerences
a pointer to the left child node
a pointer to the right child node
</code></pre>
<p>No node may have more than two children; it might have only zero or one.</p>
<p>The nodes are maintained so that at any node the left subtree contains only
words that are lexicographically less than the word at the node, and the right
subtree contains only words that are greater. This is the tree for the sentence
“now is the time for all good men to come to the aid of their party”, as built
by inserting each word as it is encountered:</p>
<pre><code>                       now
                      /   \
                     /     \
                    /       \
                   /         \
                  is         the
                 /  \         / \
                /    \       /   \
               /      \     /     \
              /        \   /       \
            for       men of       time
           /   \          \         /  \
          /     \          \       /    \
         /       \          \     /      \
        /         \          \   /        \
      all         good    party their     to
     /   \
    /     \
   /       \
aid         come
</code></pre>
<p>To find out whether a new word is already in the tree, start at the root and
compare the new word to the word stored at that node. If they match, the
question is answered affirmatively. If the new word is less than the tree word,
continue searching at the left child, otherwise at the right child. If there is
no child in the required direction, the new word is not in the tree, and in
fact the empty slot of the proper place to add the new word. This process is
recursive, since the search from any node uses a search from one of its
children. Accordingly, recursive routines for insertion and printing will be
most natural.</p>
<p>Going back to the description of a node, it is conveniently represented as a
structure with four components:</p>
<pre><code class="language-c">struct tnode {        /* the tree node: */
    char *word;           /* points to the text */
    int count;            /* number of occurrences */
    struct tnode *left;   /* left child */
    struct tnode *right;  /* right child */
};
</code></pre>
<p>This recursive declaration of a node might look chancy, but it’s correct. It is
illegal for a structure to contain an instance of itself, but</p>
<pre><code class="language-c">struct tnode *left;
</code></pre>
<p>declares <code>left</code> to be a pointer to a <code>tnode</code>, not a <code>tnode</code> itself.</p>
<p>Occasionally, one needs a variation of self-referential structures: two
structures that refer to each other. The way to handle this is:</p>
<pre><code class="language-c">struct t {
    ...
    struct s *p;    /* p points to an s */
};
struct s {
    ...
    struct t *q;    /* q points to a t */
}
</code></pre>
<p>The code for the whole program is surprisingly small, given a handful of
supporting routines like <code>getword</code> that we have already written. The main
routine reads words with <code>getword</code> and installs them in the tree with <code>addree</code>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;

#define MAXWORD 100
struct tnode *addtree(struct tnode *, char *);
void treeprint(struct tnode *);
int getword(char *, int);

/* word frequency count */
main()
{
    struct tnode *root;
    char word[MAXWORD];

    root = NULL;
    while (getword(word, MAXWORD) != EOF)
        if (isalpha(word[0]))
            root = addtree(root, word);
    treeprint(root);
    return 0;
}
</code></pre>
<p>The function <code>addtree</code> is recursive. A word is presented by <code>main</code> to the top
level (the root) of the tree. At each stage, that word is compared to the word
already stored at the node, and is percolated down to either the left or right
subtree by a recursive call to <code>addree</code>. Eventually the word either matches
something already in the tree (in which case the count is incremented), or a
null pointer is encountered, indicating that a node must be created and added
to the tree. If a new node is created, <code>addtree</code> returns a pointer to it, which
is installed in the parent node.</p>
<pre><code class="language-c">
struct tnode *talloc(void);
char *strdup(char *);

/* addtree:  add a node with w, at or below p */
struct tnode *addtree(struct tnode *p, char *w)
{
    int cond;

    if (p == NULL) {    /* a new word has arrived */
        p = talloc();   /* make a new node */
        p-&gt;word = strdup(w);
        p-&gt;count = 1;
        p-&gt;left = p-&gt;right = NULL;
    } else if ((cond = strcmp(w, p-&gt;word)) == 0)
        p-&gt;count++;     /* repeated word */
    else if (cond &lt; 0)  /* less than into left subtree */
        p-&gt;left = addtree(p-&gt;left, w);
    else
        p-&gt;right = addtree(p-&gt;right, w);
    return p;
}

</code></pre>
<p>Storage for the new node is fetched by a routine <code>talloc</code>, which returns a
pointer to a free space suitable for holding a tree node, and the new word is
copied to a hidden place by <code>strdup</code>. (We will discuss these routines in a
moment.) The count is initialized, and the two children are made null. This
part of the code is executed only at the leaves of the tree, when a new node is
being added. We have (unwisely) omitted error checking on the values returned
by <code>strdup</code> and <code>talloc</code>.</p>
<p><code>treeprint</code> prints the tree in sorted order; at each node, it prints the left
subtree (all the words less than this word), than the word itself, then the
right subtree (all the words greater). If you feel shaky about how recursion
works, simulate <code>treeprint</code> as it operates on the tree shown above.</p>
<pre><code class="language-c">/* treeprint:  in-order print of tree p */
void treeprint(struct tnode *p)
{
    if (p != NULL) {
        treeprint(p-&gt;left);
        printf(&quot;%4d %s\n&quot;, p-&gt;count, p-&gt;word);
        treeprint(p-&gt;right);
    }
}
</code></pre>
<p>A practical note: if the tree becomes “unbalanced” because the words don’t
arrive in random order, the running time of the program can grow too much. As a
worst case, if the words are already in order, this program does an expensive
simulation of linear search. There are generalizations of the binary tree that
do not suffer from this worst-case behavior, but we will not describe them
here.</p>
<p>Before we leave this example, it is also worth a brief digression on a problem
related to storage allocators. Clearly it’s desirable that there be only one
storage allocator in a program, even though it allocates different kinds of
objects. But if one allocator is to process requests for, say, pointers to
<code>chars</code> and pointer to <code>struct tnodes</code>, two questions arise. First, how does it
meet the requirements of most real machines that objects of certain types must
satisfy alignment restrictions (for example, integers often must be located at
even addresses)? Second, what declarations can cope with the fact that an
allocator must necessarily return different kinds of pointers?</p>
<p>Alignment requirements can generally be satisfied easily, at the cost of some
wasted space, by ensuring that the allocator always returns a pointer that
meets <em>all</em> alignment restrictions. The <code>alloc</code> of [Chapter @sec:pointers] does
not guarantee any particular alignment, so we will use the standard library
function <code>malloc</code>, which does. In [Chapter @sec:UNIX] we will show one way to
implement <code>malloc</code>.</p>
<p>The question of the type declaration for a function like <code>malloc</code> is a vexing
one for any language that takes its type-checking seriously. In C, the proper
method is to declare that <code>malloc</code> returns a pointer to <code>void</code>, then explicitly
coerce the pointer into the desired type with a cast. <code>malloc</code> and related
routines are declared in the standard header <code>&lt;stdlib.h&gt;</code>. Thus <code>talloc</code> can be
written as</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

/* talloc:  make a tnode */
struct tnode *talloc(void)
{
    return (struct tnode *) malloc(sizeof(struct tnode));
}
</code></pre>
<p><code>strdup</code> merely copies the string given by its argument into a safe place,
obtained by a call on <code>malloc</code>:</p>
<pre><code class="language-c">char *strdup(char *s)   /* make a duplicate of s */
{
    char *p;

    p = (char *) malloc(strlen(s)+1);   /* +1 for '\0' */
    if (p != NULL)
        strcpy(p, s);
    return p;
}
</code></pre>
<p><code>malloc</code> returns <code>NULL</code> if no space is available; <code>strdup</code> passes that value
on, leaving error-handling to its caller.</p>
<p>Storage obtained by <code>malloc</code> may be freed for re-use by calling <code>free</code>; see
[Chapters @sec:IO; and @sec:UNIX]</p>
<p><strong>Exercise 6-2.</strong> Write a program that reads a C program and prints in
alphabetical order each group of variables names that are identical in first 6
characters, but different somewhere thereafter. Don’t count words within
strings and comments. Make 6 a parameter that can be set from the command line.</p>
<p><strong>Exercise 6-3.</strong> Write a cross-referencer that prints a list of all words in
document, and, for each word, a list of the line numbers on which it occurs.
Remove noise words like “the”, “and,” and so on.</p>
<p><strong>Exercise 6-4.</strong> Write a program that prints the distinct words in its input
sorted into decreasing order of frequency of occurrence. Precede each word by
its count.</p>
<h2>Table Lookup</h2>
<p>In this section we will write the innards of a table-lookup package, to
illustrate more aspects of structures. This code is typical of what might be
found in the symbol table management routines of a macro processor a compiler.
For example, consider the <code>#define</code> statement. When a line like</p>
<pre><code class="language-c">#define  IN  1
</code></pre>
<p>is encountered, the name <code>IN</code> and the replacement test <code>1</code> are stored in a
table. Later, when the name IN` appears in a statement like</p>
<pre><code class="language-c">state = IN;
</code></pre>
<p>it must be replaced by <code>1</code>.</p>
<p>There are two routines that manipulate the names and replacement texts.
<code>install(s,t)</code> records the name <code>s</code> and the replacement text <code>t</code> in a table;
<code>s</code> and <code>t</code> are just character strings. <code>lookup(s)</code> searches for <code>s</code> in the
table, and returns a pointer to the place where it was found, or <code>NULL</code> if it
wasn’t there.</p>
<p>The algorithm is a hash search—the incoming name is converted into a samll
non-negative integer, which is then used to index into an array of pointers. An
array element points to the beginning of a linked list of blocks describing
names that have that hash value. It is <code>NULL</code> if no names have hased to that
value.</p>
<pre><code>+---+
|   |
|   |         +---+
| *----------&gt;|   |           +---+
|   |         | *------------&gt;|   |
|   |         |   |           | 0 |
|   |         | *----&gt;        |   |
| 0 |         |   |           | *-----&gt; name
|   |         | *----&gt;        |   |
|   |         |   |           | *-----&gt; defn
|   |         +---+           |   |
| 0 |                         +---+
|   |
|   |
|   |         +---+
| *----------&gt;|   |
|   |         | 0 |
|   |         |   |
|   |         | *-----&gt; name
| 0 |         |   |
|   |         | *-----&gt; defn
+---+         |   |
              +---+
</code></pre>
<p>A block in the list is a structure containing pointers to the name, the
replacement text, and the next block in the list. A null next-pointer marks the
end of the list.</p>
<pre><code class="language-c">struct nlist {        /* table entry: */
    struct nlist *next;    /* next entry in chain */
    char *name;            /* defined name */
    char *defn;            /* replacement text */
};
</code></pre>
<p>The pointer array is just</p>
<pre><code class="language-c">#define HASHSIZE 101

static struct nlist *hashtab[HASHSIZE]; /* pointer table*/
</code></pre>
<p>The hashing function, which is used by both <code>lookup</code> and <code>install</code>, adds each
character value in the string to scrambled combination of the previous ones and
returns the remainder modulo the array size. This is not the best possible hash
function, but it is short and effective.</p>
<pre><code class="language-c">/* hash:  form hash value for string s */
unsigned hash(char *s)
{
    unsigned hashval;

    for (hashval = 0; *s != '\0'; s++)
        hashval = *s + 31 * hashval;
    return hashval $ HASHSIZE;
}
</code></pre>
<p>Unsigned arithmetic ensures that the hash value is non-negative.</p>
<p>The hashing process produces a starting index in the array <code>hashtab</code>; if the
string is to be found anywhere, it will be in the list of blocks beginning
there. The search is performed by <code>lookup</code>. If <code>lookup</code> finds the entry already
present, it returns a pointer to it; if not, it returns <code>NULL</code>.</p>
<pre><code class="language-c">/* lookup:  look for s in hashtab */
struct nlist *lookup(char *s)
{
    struct list *np;

    for (np = hashtab[hash(s)]; np != NULL; np = np-&gt;next)
        if (strcmp(s, np-&gt;name) == 0)
            return np;  /* found */
    return NULL;        /* not found */
}
</code></pre>
<p>The <code>for</code> loop in <code>lookup</code> is the standard idiom for wlaking along a linked
list:</p>
<pre><code class="language-c">for (ptr = head; ptr != NULL; ptr = ptr-&gt;next)
    ...
</code></pre>
<p><code>install</code> uses <code>lookup</code> to determine whether the name being installed is
already present; if so, the new definition will supersede the old one.
Otherwise, a new entry is created. <code>install</code> returns <code>NULL</code> if for any reason
there is no room for a new entry.</p>
<pre><code class="language-c">struct nlist *lookup(char *);
char *strdup(char *);

/* install:  put (name, defn) in hashtab */
struct nlist *install(char *name, char *defn)
{
    struct nlist *np;
    unsigned hashval;

    if ((np = lookup(name)) == NULL) {  /* not found */
        np = (struct nlist *) malloc(sizeof(*np));
        if (np == NULL || (np-&gt;name = strdup(name)) == NULL)
            return NULL;
        hashval = hash(name);
        np-&gt;next = hashtab[hashval];
        hashtab[hashval] = np;
    } else      /* already there */
        free((void *) np-&gt;defn);  /* free previous defn */
    if ((np-&gt;defn = strdup(defn)) == NULL)
        return NULL;
    return np;
}
</code></pre>
<p><strong>Exercise 6-5.</strong> Write a function <code>undef</code> that will remove a name and
definition from the table maintained by <code>lookup</code> and <code>install</code>.</p>
<p><strong>Exercise 6-6.</strong> Implement a simple version of the <code>#define</code> processor (i.e.,
no arguments) suitable for use with C programs, based on the routines of this
section. You may also find <code>getch</code> and <code>ungetch</code> helpful.</p>
<h2>Typedef {#sec:typedef}</h2>
<p>C provides a facility called <code>typedef</code> for creating new data type names. For
example, the declaration</p>
<pre><code class="language-c">typedef int Length;
</code></pre>
<p>makes the name <code>Length</code> a synonym for <code>int</code>. The type <code>Length</code> can be used in
declarations, casts, etc., in exactly the same ways that the type <code>int</code> can be:</p>
<pre><code class="language-c">Length  len, maxlen;
Length  *lengths[];
</code></pre>
<p>Similarly, the declaration</p>
<pre><code class="language-c">typedef char *String;
</code></pre>
<p>makes <code>String</code> a synonym for <code>char *</code> or character pointer, which may then be
used in declarations and casts:</p>
<pre><code class="language-c">String p, lineptr[MAXLINES], alloc(int);
int strcmp(String, String);
p = (String) malloc(100);
</code></pre>
<p>Notice that the type being declared in a <code>typedef</code> appears in the position of a
variable name, not right after the word <code>typedef</code>. Syntactically, <code>typedef</code> is
like the storage classes <code>extern</code>, <code>static</code>, etc. We have used capitalized
names for <code>typedef</code>s, to make them stand out.</p>
<p>As a more complicated example, we could make <code>typedef</code>s for the tree nodes
shown earlier in this chapter:</p>
<pre><code class="language-c">typedef struct tnode *Treeptr;

typedef struct tnode {   /* the tree node: */
    char *word;              /* points to the text */
    int count;               /* number of occurrences */
    Treeptr left;            /* left child */
    Treeptr right;           /* right child */
} Treenode;
</code></pre>
<p>This creates two new type keywords called <code>Treenode</code> (a structure) and
<code>Treeptr</code> (a pointer to the structure). Then the routine <code>talloc</code> could become</p>
<pre><code class="language-c">Treeptr talloc(void)
{
    return (Treeptr) malloc(sizeof(Treenode));
}
</code></pre>
<p>It must be emphasized that a <code>typedef</code> declaration does not create a new type
in any sense; it merely adds a new name for some existing type. Nor are there
any new semantics: variables declared this way have exactly the same properties
as variables whose declarations are spelled out explicitly. In effect,
<code>typedef</code> is like <code>#define</code>, except that since it is interpreted by the
compiler, it can cope with textual substitutions that are beyond the
capabilities of the preprocessor. For example,</p>
<pre><code class="language-c">typedef int (*PFI)(char *, char *);
</code></pre>
<p>create the type <code>PFI</code>, for “pointer to function (of two <code>char *</code> arguments)
returning <code>int</code>,” which can be used in contexts like</p>
<pre><code class="language-c">PFI strcmp, numcmp;
</code></pre>
<p>in the sort program of [Chapter @sec:pointers].</p>
<p>Besides purely aesthetic issues, there are two main reasons for using
<code>typedef</code>s. The first is to parametrize a program against portability problems.
If <code>typedef</code>s are used for data types that may be machine-dependent, only the
<code>typedef</code>s need change when the program is moved. One common situation is to
use <code>typedef</code> names for various integer quantities, then make an appropriate
set of choices of <code>short</code>, <code>int</code>, and <code>long</code> for each host machine. Types like
<code>size_t</code> and <code>ptrdiff_t</code> from the standard library are examples.</p>
<p>The second purpose of <code>typedef</code>s is to provide better documentation for a
program—a type called <code>Treeptr</code> may be easier to understand than one declared
only as a pointer to a complicated structure.</p>
<h2>Unions</h2>
<p>A <em>union</em> is a variable that may hold (at different times) objects of different
types and sizes, with the compiler keeping track of size and alignment
requirements. Unions provide a way to manipulate different kinds of data in a
single area of storage, without embedding any machine-dependent information in
the program. They are analogous to variant records in Pascal.</p>
<p>As an example such as might be found in a compiler symbol table manager,
suppose that a constant may be an <code>int</code>, <code>float</code>, or a character pointer. The
value of a particular constant must be stored in a variable of the proper type,
yet it is most convenient for table management if the value occupies the same
amount of storage and is stored in the same place regardless of its type. This
is the purpose of a union—a single variable that can legitimately hold any
one of several types. The syntax is based on structures:</p>
<pre><code class="language-c">union 8_tag {
    int ival;
    float fval;
    char *sval;
} u;
</code></pre>
<p>The variable <code>u</code> will be large enough to hold the largest of the three types;
the specific size is implementation-dependent. Any one of these types may be
assigned to <code>u</code> and then used in expressions, so long as the usage is
consistent: the type retrieved must be the type most recently stored. It is the
programmer’s responsibility yo keep track of which type is currently stored in
a union; the results are implementation-dependent if something is stored as one
type and extracted as another.</p>
<p>Syntactically, members of a union are accessed as</p>
<pre><code class="language-c">union-name.member
</code></pre>
<p>or</p>
<pre><code class="language-c">union-pointer-&gt;member
</code></pre>
<p>just as for structures. If the variable <code>utype</code> is used to keep track of the
current type stored in <code>u</code>, then one might see code such as</p>
<pre><code class="language-c">if (utype == INT)
    printf(&quot;%d\n&quot;, u.ival);
else if (utype == FLOAT)
    printf(&quot;%f\n&quot;, u.fval);
else if (utype == STRING)
    printf(&quot;%s\n&quot;, u.sval);
else
    printf(&quot;bad type %d in utype\n&quot;, utype);
</code></pre>
<p>Unions may occur within structures and arrays, and vice versa. The notation for
accessing a member of a union in a structure (or vice versa) is identical to
that for nested structures. For example, in the structure array defined by</p>
<pre><code class="language-c">struct {
    char *name;
    int flags;
    int utype;
    union {
        int ival;
        float fval;
        char *sval;
    } u;
} symtab[NSYM];
</code></pre>
<p>the member <code>ival</code> is referred to as</p>
<pre><code class="language-c">symtab[i].u.ival
</code></pre>
<p>and the first character of the string <code>sval</code> by either of</p>
<pre><code class="language-c">*symtab[i].u.sval
symtab[i].u.sval[0]
</code></pre>
<p>In effect, a union is a structure in which all members have offset zero from
the base, the structure is big enough to hold the “widest” member, and the
alignment is appropriate for all of the types in the union. The same operations
are permitted on unions as on structures: assignment to or copying as a unit,
taking the address, and accessing a member.</p>
<p>A union may only be initialized with a value of the type of its first member;
thus the union <code>u</code> described above can only be initialized with an integer
value.</p>
<p>The storage allocator in [Chapter @sec:UNIX] shows how a union can be used to
force a variable to be aligned on a particular kind of storage boundary.</p>
<h2>Bit-fields</h2>
<p>When storage space is at a premium, it may be necessary to pack several objects
into a single machine word; one common use is a set of single-but flags in
applications like compiler symbol tables. Externally-imposed data formats, such
as interfaces to hardware devices, also often require the ability to get at
pieces of a word.</p>
<p>Image a fragment of a compiler that manipulates a symbol table. Each identifier
in a program has certain information associated with it, for example, whether
or not it is a keyword, whether or not it is external and/or static, and so on.
The most compact way to encode such information is a set of one-bit flags in a
single <code>char</code> or <code>int</code>.</p>
<p>The usual way this is done is to define a set of “masks” corresponding to the
relevant bit positions, as in</p>
<pre><code class="language-c">#define KEYWORD  01
#define EXTERNAL 02
#define STATIC   04
</code></pre>
<p>or</p>
<pre><code class="language-c">enum { KEYWORD = 01, EXTERNAL = 02, STATIC = 04 };
</code></pre>
<p>The numbers must be powers of two. Then accessing the bits becomes a matter of
“bit-fiddling” with the shifting, masking, and complementing operators that
were described in [Chapter @sec:types-ops-expressions].</p>
<p>Certain idioms appear frequently:</p>
<pre><code class="language-c">flags |= EXTERNAL | STATIC;
</code></pre>
<p>turns on the <code>EXTERNAL</code> and <code>STATIC</code> bits in <code>flags</code>, while</p>
<pre><code class="language-c">flags &amp;= ¬(EXTERNAL ~ STATIC);
</code></pre>
<p>turns them off, and</p>
<pre><code class="language-c">if ((flags &amp; (EXTERNAL ~ STATIC)) == 0) ...
</code></pre>
<p>is true if both bits are off.</p>
<p>Although these idioms are readily mastered, as an alternative C offers the
capability of defining and accessing fields within a word directly rather than
by bitwise logical operators. A <em>bit-field</em>, or <em>field</em> for short, is a set of
adjacent bits within a simple implementation-defined storage unit that we call
a “word.” The syntax of field definition and access is based on structures. For
example, the symbol table <code>#define</code>s above could be replaced by the definition
of three fields:</p>
<pre><code class="language-c">struct {
    unsigned int is_keyword : 1;
    unsigned int is_extern  : 1;
    unsigned int is_static  : 1;
} flags;
</code></pre>
<p>This defines a variable called <code>flags</code> that contains three 1-bit fields. The
number following the colon represents the field width in bits. The fields are
declared <code>unsigned int</code> to ensure that they are unsigned quantities.</p>
<p>Individual fields are referenced in the same way as other structure members:
<code>flags.is_keyword</code>, <code>flags.is_extern</code>, etc. Fields behave like small integers,
and may participate in arithmetic expressions just like other integers. Thus
the previous examples may be written more naturally as</p>
<pre><code class="language-c">flags.is_extern = flags.is_static = 1;
</code></pre>
<p>to turn the bits on;</p>
<pre><code class="language-c">flags.is_extern = flags.is_static = 0;
</code></pre>
<p>to turn them off; and</p>
<pre><code class="language-c">if (flags.is_extern == 0 &amp;&amp; flags.is_static == 0)
    ...
</code></pre>
<p>to test them.</p>
<p>Almost everything about fields is implementation-dependent. Whether a filed may
overlap a word boundary is implementation-defined. Fields need not be named;
unnamed fields (a colon and width only) are used for padding. The special width
0 may be used to force alignment at the next word boundary.</p>
<p>Fields are assigned left to right on some machines and right to left on others.
This means that although fields are useful for maintaining internally-defined
data structures, the question of which end comes first has to be carefully
considered when picking apart externally-defined data; programs that depend on
such things are not portable. Fields may be declared only as <code>int</code>s; for
portability, specify <code>signed</code> or <code>unsigned</code> explicitly. They are not arrays,
and they do not have addresses, so the <code>&amp;</code> operator cannot be applied to them.</p>
<h1>Input and Output {#sec:IO}</h1>
<p>Input and output facilities are not part of the C language itself, so we have
not emphasized them in our presentation thus far. Nonetheless, programs
interact with their environment in much more complicated ways than those we
have shown before. In this chapter we will describe the standard library, a set
of functions that provide input and output, string handling, storage
management, mathematical routines, and a variety of other services for C
programs. We will concentrate on input and output.</p>
<p>The ANSI standard defines these library functions precisely, so that they can
exist in compatible form on any system where C exists. Programs that confine
their system interactions to facilities provided by the standard library can be
moved from one system to another without change.</p>
<p>The properties of library functions are specified in more than a dozen headers;
we have already seen several of these, including <code>&lt;stdio.h&gt;</code>, <code>&lt;string.h&gt;</code>, and
<code>&lt;ctype.h&gt;</code>. We will not present the entire library here, since we are more
interested in writing C programs that use it. The library is described in
detail in [Appendix @sec:std-lib].</p>
<h2>Standard Input and Output {#sec:stdin-stdout}</h2>
<p>As we said in [Chapter @sec:introduction], the library implements a simple
model of text input and output. A text stream consists of a sequence of lines;
each line ends with a newline character. If the system doesn’t operate that
way, the library does whatever is necessary to make it appear as if it does.
For instance, the library might convert carriage returns and linefeed to
newline on input and back again on output.</p>
<p>The simplest input mechanism is to read one character at a time from the
<em>standard input</em>, normally the keyboard, with <code>getchar</code>:</p>
<pre><code class="language-c">int getchar(void)
</code></pre>
<p><code>getchar</code> returns the next input character each time it is called, or <code>EOF</code>
when it encounters end of file. The symbolic constant <code>EOF</code> is defined in
<code>&lt;stdio.h&gt;</code>. The value is typically <code>-1</code>, but tests should be written in terms
of <code>EOF</code> so as to be independent of the specific value.</p>
<p>In many environments, a file may be substituted for the keyboard by suing the
<code>&lt;</code> convention for input redirection: if a program <code>prog</code> uses <code>getchar</code>, then
the command line</p>
<pre><code class="language-sh">prog &lt;infile
</code></pre>
<p>causes <code>prog</code> to read characters from <code>infile</code> instead. The switching of the
input is done in such a way that <code>prog</code> is oblivious to the change; in
particular, the string “<code>&lt;infile</code>” is not included in the command-line
arguments in <code>argv</code>. Input switching is also invisible if the input comes from
another program via a pipe mechanism: one some systems, the command line</p>
<pre><code class="language-sh">otherprog | prog
</code></pre>
<p>runs the two programs <code>otherprog</code> and <code>prog</code>, and pipes the standard output of
<code>otherprop</code> into the standard input for <code>prog</code>.</p>
<p>The function</p>
<pre><code class="language-c">int putchar(int)
</code></pre>
<p>is used for output: <code>putchar(c)</code> puts the character <code>c</code> on the <em>standard
output</em>, which is by default the screen. <code>putchar</code> returns the character
written, or <code>EOF</code> if an error occurs. Again, output can usually be directed to
a file with <code>&gt;filename</code>: if <code>prog</code> uses <code>putchar</code>,</p>
<pre><code class="language-sh">prog &gt;outfile
</code></pre>
<p>will write the standard output to <code>outfile</code> instead. If pipes are supported,</p>
<pre><code class="language-c">prog | anotherprog
</code></pre>
<p>puts the standard output of <code>prog</code> into the standard input of <code>anotherprog</code>.</p>
<p>Output produced by <code>printf</code> also finds its way to the standard output. Calls to
<code>putchar</code> and <code>printf</code> may be interleaved—output appears in the order in
which the calls were made.</p>
<p>Each source file that refers to an input/output library function must contain
the line</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
</code></pre>
<p>before the first reference. When the name is bracketed by <code>&lt;</code> and <code>&gt;</code> a search
is made for the header in a standard set of places (for example, on UNIX
systems, typically in the directory <code>/usr/include</code>).</p>
<p>Many programs read only one input stream and write only one output stream; for
such programs, input and output with <code>getchar</code>, <code>putchar</code>, and <code>printf</code> may be
entirely adequate, and is certainly enough to get stated. This is particularly
true if redirection is used to connect the output of one program to the input
of the next. For example, consider the program <code>lower</code>, which converts its
input to lower case:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

main() /* lower: conver input to lower case */
{
    int c;

    while ((c = getchar()) != EOF)
        putchar(tolower(c));
    return 0;
}
</code></pre>
<p>The function <code>tolower</code> is defined in <code>&lt;ctype.h&gt;</code>; it converts an upper case
letter to lower case, and returns other characters untouched. As we mentioned
earlier, “functions” like <code>getchar</code> and <code>putchar</code> in <code>&lt;stdio.h&gt;</code> and <code>tolower</code>
in <code>&lt;ctype.h&gt;</code> are often macros, thus avoiding the overhead of a function call
per character. We will show how this is done in [Section @sec:fopen-getc].
Regardless of how the <code>&lt;ctype.h&gt;</code> functions are implemented on a given machine,
programs that use them are shielded from knowledge of the character set.</p>
<p><strong>Exercise 7-1.</strong> Write a program that converts upper case to lower case or
lower case to upper, depending on the name it is invoked with, as found in
<code>argv[0]</code>.</p>
<h2>Formatted Output—Printf</h2>
<p>The output function <code>printf</code> translates internal values to characters. We have
used <code>printf</code> informally in previous chapters. The descriptions here covers
most typical uses but is not complete; for the full story, see [Appendix
@sec:std-lib].</p>
<pre><code class="language-c">int printf(char *format, arg1, arg2, ...)
</code></pre>
<p><code>printf</code> converts, formats, and prints its arguments on the standard output
under control of the <code>format</code>. It returns the number of characters printed.</p>
<p>The format string contains two types of objects: ordinary characters, which are
copied to the output stream, and conversion specifications, each of which
causes  conversion and printing of the next successive argument to <code>printf</code>.
Each conversion specification beings with a <code>%</code> and ends with a conversion
character. Between the <code>%</code> and the conversion character there may be, in order:</p>
<ul>
<li>A minus sign, which specifies left adjustment of the converted argument.</li>
<li>A number that specifies the minimum field width. The converted argument will
be printed in a field at least this wide. If necessary it will be padded on
the left (or right, if left adjustment is called for) to make up the field
width.</li>
<li>A period, which separates the field width from the precision.</li>
<li>A number, the precision, that specifies the maximum number of characters to
be printed from a string, or the number of digits after the decimal point of
a floating-point value, or the minimum number of digits for an integer.</li>
<li>An <code>h</code> if the integer is to be printed as a <code>short</code>, or <code>l</code> (letter ell) if
as a <code>long</code>.</li>
</ul>
<p>Conversion characters are shown in [Table @tbl:printf-conversions]. If the
character after the <code>%</code> is not a conversion specification, the behavior is
undefined.</p>
<p>Table: Basic Printf Conversions {#tbl:printf-conversions}</p>
<hr />
<p>Character  Argument Type; Printed As</p>
<hr />
<p><code>d</code>, <code>i</code>    decimal number.</p>
<p><code>o</code>         <code>int</code>; unsigned octal number (without leading zero).</p>
<p><code>x</code>, <code>X</code>    <code>int</code>; unsigned hexadecimal number (without a leading <code>0x</code> or
<code>0X</code>), using <code>abcdef</code> or <code>ABCDEF</code> for <code>10</code>, …, <code>15</code>.</p>
<p><code>u</code>         <code>int</code>; unsigned decimal number.</p>
<p><code>c</code>         <code>int</code>; single character.</p>
<p><code>s</code>         <code>char *</code>; print characters from the string until a <code>'\0'</code> or the
number of characters given by the precision.</p>
<p><code>f</code>         <code>double</code>; <code>[-]m.dddddd</code>, where  the number of <code>d</code>’s is given by the
precision (default 6).</p>
<p><code>e</code>, <code>E</code>    <code>double</code>; <code>[-]m.dddddde±xx</code> or <code>[-]m.ddddddE±xx</code>, where the number
of <code>d</code>’s is given by the precision (default 6).</p>
<p><code>g</code>, <code>G</code>    <code>double</code>; use <code>%e</code> or <code>%E</code> if the exponent is less than <code>-4</code> or
greater than or equal to the precision; otherwise use <code>%f</code>.
Trailing zeros and a trailing decimal point are not printed.</p>
<p><code>p</code>         <code>void *</code>; pointer (implementation-dependent representation).</p>
<h2><code>%</code>         no argument is converted; print a <code>%</code>.</h2>
<p>A width or precision may be specified as <code>*</code>, in which case the value is
computed by converting the next argument (which must be an <code>int</code>). For example,
to print at most <code>max</code> characters from a string <code>s</code>,</p>
<pre><code class="language-c">printf(&quot;%.*s&quot;, max, s);
</code></pre>
<p>Most of the format conversions have been illustrated in earlier chapters. One
exception is precision as it relates to strings. The following table shows the
effect of a variety of specifications in printing “hello, world” (12
characters). We have put colons around each field so you can see its extent.</p>
<pre><code>:%s:         :hello, world:
:%10s:       :hello, world:
:%.10s:      :hello, wor:
:%-10s:      :hello, world:
:%.15s:      :hello, world:
:%-15s:      :hello, world   :
:%15.10s:    :     hello, wor:
:%-15.10s:   :hello, wor     :
</code></pre>
<p>A warning: <code>printf</code> uses its first argument to decide how many arguments follow
and what their types are. It will get confused, and you will get wrong answers,
if there are not enough arguments or if they are the wrong type. You should
also be away of the difference between these two calls:</p>
<pre><code class="language-c">printf(s);        /* FAILS if s contains % */
printf(&quot;%s&quot;, s);  /* SAFE */
</code></pre>
<p>The function <code>sprintf</code> does the same conversions as <code>printf</code> does, but stores
the output in a string:</p>
<pre><code class="language-c">int sprintf(char *string, char *format, arg1, arg2, ...)
</code></pre>
<p><code>sprintf</code> formats the arguments in <code>arg1</code>, <code>arg2</code>, etc., according to <code>format</code>
as before, but places the result in <code>string</code> instead of on the standard output;
<code>stirng</code> must be big enough to receive the result.</p>
<p><strong>Exercise 7-2.</strong> Write a program that will print arbitrary input in a sensible
way. As a minimum, it should print non-graphic characters in octal or
hexadecimal according to local custom, and break long text lines.</p>
<h2>Variable-length Argument List</h2>
<p>This section contains an implementation of a minimal version of <code>printf</code>, to
show how to write a function that processes a variable-length argument list in
a portable way. Since we are mainly interested in the argument processing,
<code>minprintf</code> will process the format string and arguments but will call the real
<code>printf</code> to to the format conversions.</p>
<p>The proper declaration for <code>printf</code> is</p>
<pre><code class="language-c">int printf(char *fmt, ...)
</code></pre>
<p>where the declaration <code>...</code> means that the number and types of these arguments
may vary. The declaration <code>...</code> can only appear at the end of an argument list.
Our <code>minprintf</code> is declared as</p>
<pre><code class="language-c">void minprintf(char *fmt, ...)
</code></pre>
<p>since we will not return the character count that <code>printf</code> does.</p>
<p>The tricky bit is how <code>minprintf</code> walks along the argument list when the list
doesn’t even have a name. The standard header <code>&lt;stdarg.h&gt;</code> contains a set of
macro definitions that define how to step through an argument list. The
implementation of this header will vary from machine to machine, but the
interface it presents is uniform.</p>
<p>The type <code>va_list</code> is used to declare a variable that will refer to each
argument in turn; in <code>minprintf</code>, this variable is called <code>ap</code>, for “argument
pointer.” The macro <code>va_start</code> initializes <code>ap</code> to point to the first unnamed
argument. It must be called once before <code>ap</code> is used. There must be at least
one named argument; the final named argument is used by <code>va_start</code> to get
started.</p>
<p>Each call of <code>va_arg</code> returns one argument and steps <code>ap</code> to the next; <code>va_arg</code>
uses the type name to determine what type to return and how big a step to
take.Finally, <code>va_end</code> does whatever cleanup is necessary. It must be called
before the function returns.</p>
<p>These properties form the basis of our simplified <code>printf</code>:</p>
<pre><code class="language-c">
#include &lt;stdarg.h&gt;

/* minprintf:  minimal printf with variable argument list */
void minprintf(char *fmt, ...)
{
    va_list ap;   /* points to each unnamed arg in turn */
    char *p, *sval;
    int ival;
    double dval;

    va_start(ap, fmt); /* make ap point to 1st unnamed arg */
    for (p = fmt; *p; p++) {
        if (*p != '%') {
            putchar(*p);
            continue;
        }
        switch (*++p) {
        case 'd':
            ival = va_arg(ap, int);
            printf(&quot;%d&quot;, ival);
            break;
        case 'f':
            dval = va_arg(ap, double);
            printf(&quot;%f&quot;, dval);
            break;
        case 's':
            for (sval = va_arg(ap, char *); *sval; sval++)
                putchar(*sval);
            break;
        default:
            putchar(*p);
            break;
        }
    }
}
</code></pre>
<p><strong>Exercise 7-3.</strong> Revise <code>minprintf</code> to handle more of the other facilities of
<code>printf</code>.</p>
<h2>Formatted Input—Scanf {#sec:scanf}</h2>
<p>The function <code>scanf</code> is the input analog of <code>printf</code>, providing many of the
same conversion facilities in the opposite direction.</p>
<pre><code class="language-c">int scanf(char *format, ...)
</code></pre>
<p><code>scanf</code> reads characters from the standard input, interprets them according to
the specification in <code>format</code>, and stores the results through the remaining
arguments. The format argument is described below; the other arguments, <em>each
of which must be a pointer</em>, indicate where the corresponding converted input
should be stored. As with <code>printf</code>, this section is a summary of the most
useful features, not an exhaustive list.</p>
<p><code>scanf</code> stops when it exhausts its format string, or when some input fails to
match the control specification. It returns as its value the number of
successfully matched and assigned input items. This can be used to decide how
many items were found. On the end of file, <code>EOF</code> is returned; note that this is
different from <code>0</code>, which means that the next input character does not match
the first specification in the format string. The next call to <code>scanf</code> resumes
searching immediately after the last character already converted.</p>
<p>There is also a function <code>sscanf</code> that reads from a string instead of the
standard input:</p>
<pre><code class="language-c">int sscanf(char *string, char *format, arg1, arg2, ...)
</code></pre>
<p>It scans the <code>string</code> according to the format in <code>format</code>, and stores the
resulting values through <em>arg1</em>, <em>arg2</em>, etc. These arguments must be pointers.</p>
<p>The format string usually contains conversion specifications, which are used to
control conversion of input. The format string may contain:</p>
<ul>
<li>Blanks or tabs, which are ignored</li>
<li>Ordinary characters (not <code>%</code>), which are expected to match the next non-white
space character of the input stream.</li>
<li>Conversion specifications, consisting of the character <code>%</code>, an optional
assignment suppression character <code>*</code>, an optional number specifying a maximum
field width, an optional <code>h</code>, <code>l</code>, or <code>L</code> indicating the width of the target,
and a conversion character.</li>
</ul>
<p>A conversion specification directs the conversion of the next input field.
Normally the result is placed in the variable pointed to by the corresponding
argument. If assignment suppression is indicated by the <code>*</code> character, however,
the input field is skipped; no assignment is made. An input field is defined as
a string of non-white space characters; it extends either to the next white
pace character or until the field width, if specified, is exhausted. This
implies that <code>scanf</code> will read across line boundaries to find its input, since
newlines are white space. (White space characters are blank, tab, newline,
carriage return, vertical tab, and formfeed.)</p>
<p>The conversion characters indicates the interpretation of the input field. The
corresponding argument must be a pointer, as required by the call-by-value
semantics of C. Conversion characters are shown in [Table
@tbl:scanf-conversions]</p>
<p>Table: Basic Scanf Conversions {#tbl:scanf-conversions}</p>
<hr />
<p>Character    Input Data; Argument Type</p>
<hr />
<p><code>d</code>            decimal integer; <code>int *</code></p>
<p><code>i</code>            integer; <code>int *</code>. The integer may be in octal (leading <code>0</code>) or
hexadecimal (leading <code>0x</code> or <code>0X</code>).</p>
<p><code>o</code>            octal integer (with or without leading zero); <code>int *</code>.</p>
<p><code>u</code>            unsigned decimal integer; <code>unsigned int *</code>.</p>
<p><code>x</code>            hexadecimal integer (with or without leading <code>0x</code> or <code>0X</code>);
<code>int *</code></p>
<p><code>c</code>            characters; <code>char *</code>. The next input characters (default 1) are
placed at the indicated spot. The normal skip over white space
is suppressed; to read the next non-white space character, use
<code>%1s</code>.</p>
<p><code>s</code>            character string (not quoted); <code>char *</code>, pointing to an array of
characters large enough for the string and a terminating <code>'\0'</code>
that will be added.</p>
<p><code>e</code>, <code>f</code>, <code>g</code>  floating-point number with optional sign, optional decimal point
and optional exponent; <code>float *</code>.</p>
<h2><code>%</code>            literal <code>%</code>; no assignment is made.</h2>
<p>The conversion characters <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, and <code>x</code> may be preceded by an <code>h</code>
to indicate that a pointer to <code>short</code> rather than <code>int</code> appears in the argument
list, or by <code>l</code> (letter ell) to indicate that a pointer to <code>long</code> appears in
the argument list. Similarly, the conversion characters <code>e</code>, <code>f</code>, and <code>g</code> may
be preceded by <code>l</code> to indicate that a pointer to <code>double</code> rather than <code>float</code>
is in the argument list.</p>
<p>As a first example, the rudimentary calculator of [Chapter @sec:functions] can
be written with <code>scanf</code> to do the input conversion:</p>
<pre><code class="language-c">#include   &lt;stdio.h&gt;

main() /* rudimentary claculator */
{
    double sum, v;

    sum = 0;
    while (scanf(&quot;%lf&quot;, &amp;v) == 1)
        printf(&quot;\t%.2f\n&quot;, sum += v);
    return 0;
}
</code></pre>
<p>Suppose we want to read input lines that contain dates of the form</p>
<pre><code>25 Dec 1988
</code></pre>
<p>The <code>scanf</code> statement is</p>
<pre><code class="language-c">int day, year;
char monthname[20];

scanf(&quot;%d %s %d&quot; &amp;day, monthname, &amp;year);
</code></pre>
<p>No <code>&amp;</code> is used with <code>monthname</code>, since an array name is a pointer.</p>
<p>Literal characters can appear in the <code>scanf</code> format string; they must match the
same characters in the input. So we could read dates of the form <code>mm/dd/yy</code> wit
this <code>scanf</code> statement:</p>
<pre><code class="language-c">int day, month, year;

scanf(&quot;%d/%d/%d&quot;, &amp;month, &amp;day, &amp;year);
</code></pre>
<p><code>scanf</code> ignores blanks and tabs in its format string. Furthermore, it skips
over white space (blanks, tabs, newlines, etc.) as it looks for input values.
To read input whose format is not fixed, it is often best to read a line at a
time, then pick it apart with <code>sscanf</code>. For example, suppose we want to read
lines that might contain a date in either of the forms above. Then we could
write</p>
<pre><code class="language-c">while (getline(line, sizeof(line)) &gt; 0) {
    if (sscanf(line, &quot;%d %s %d&quot;, &amp;day, monthname, &amp;year) == 3)
        printf(&quot;valid: %s\n&quot;, line);    /* 25 Dec 1988 form */
    else if (sscanf(line, &quot;%d/%d/%d&quot;, &amp;month, &amp;day, &amp;year) == 3)
        printf(&quot;valid: %s\n&quot;, line);    /* mm/dd/yy form */
    else
        printf(&quot;invalid: %s\n&quot;, line);  /* invalid form */
}
</code></pre>
<p>Calls to <code>scanf</code> can be mixed with calls to other input functions. The next
call to any input function will begin by reading the first character not read
by <code>scanf</code>.</p>
<p>A final warning: the arguments to <code>scanf</code> and <code>sscanf</code> <em>must</em> be pointers. By
far the most common error is writing</p>
<pre><code class="language-c">scanf(&quot;%d&quot;, n);
</code></pre>
<p>instead of</p>
<pre><code class="language-c">scanf(&quot;%d&quot;, &amp;n);
</code></pre>
<p>This error is not generally detected at compile time.</p>
<p><strong>Exercise 7-4.</strong> Write a private version of <code>scanf</code> analogous to <code>minprintf</code>
from the previous section.</p>
<p><strong>Exercise 7-5.</strong> Rewrite the postfix calculator of [Chapter @sec:functions] to
use <code>scanf</code> and/or <code>sscanf</code> to do the input and number conversion.</p>
<h2>File Access</h2>
<p>The examples so far have all read the standard input and written the standard
output, which are automatically defined for a program by the local operating
system.</p>
<p>The next step is to write a program that accesses a file that is <em>not</em> already
connected to the program. One program that illustrates the need for such
operations is <code>cat</code>, which concatenates a set of named files onto the standard
output. <code>cat</code> is used for printing files on the screen, and as a
general-purpose input collector for programs that do not have the capability of
accessing files by name. For example, the command</p>
<pre><code class="language-sh">cat x.c y.c
</code></pre>
<p>prints the contents of the files <code>x.c</code> and <code>y.c</code> (and nothing else) on the
standard output.</p>
<p>The question is how to arrange for the named files to be read—that is, how to
connect the external names that a user thinks of to the statements that read
the data.</p>
<p>The rules are simple. Before it can be read or written, a file has to be
<em>opened</em> by the library function <code>fopen</code>. <code>fopen</code> takes an external name like
<code>x.c</code> or <code>y.c</code>, does some housekeeping and negotiation with the operating
system (details of which needn’t concern us), and returns a pointer to be used
in subsequent reads or writes of the file.</p>
<p>The pointer, called the <em>file pointer</em>, points to a structure that contains
information about the file, such as the location of a buffer, the current
character position in the buffer, whether the file is being read or written,
and whether errors or end of file have occurred. Users don’t need to know the
details, because the definitions obtains from <code>&lt;stdio.h&gt;</code> include a structure
declaration called <code>FILE</code>. The only declaration needed for a file pointer is
exemplified by</p>
<pre><code class="language-c">FILE *fp;
FILE *fopen(char *name, char *mode);
</code></pre>
<p>This says that <code>fp</code> is a pointer to a <code>FILE</code>, and <code>fopen</code> returns a pointer to
a <code>FILE</code>. Notice that <code>FILE</code> is a type name, like <code>int</code>, not a structure tag;
it is defined with a <code>typedef</code>. (Details of how <code>fopen</code> can be implemented on
the UNIX system are given in [Section @sec:fopen-getc].)</p>
<p>The call to <code>fopen</code> in a program is</p>
<pre><code class="language-c">fp = fopen(name, mode);
</code></pre>
<p>The first argument of <code>fopen</code> is a character string  containing the name of the
file. The second argument is the <em>mode</em>, also a character string, which
indicates how one intents to use the file. Allowable modes include read
(<code>&quot;r&quot;</code>), write (<code>&quot;w&quot;</code>), and append (<code>&quot;a&quot;</code>). Some systems distinguish between
text and binary files; for the latter, a <code>&quot;b&quot;</code> must be appended to the mode
string.</p>
<p>If a file that does not exist is opened for writing or appending, it is created
if possible. Opening an existing file for writing causes the old contents to be
discarded, while opening preserves them. Trying to read a file that does not
exist is an error, and there may be other causes of error as well, like trying
to read a file when you don’t have permission. If there is any error, <code>fopen</code>
will return <code>NULL</code>. (The error can be identified more precisely; see the
discussion of error-handling functions at the end of [Section @sec:stdio].)</p>
<p>The next thing needed is a way to read or write the file once it is open. There
are several possibilities, of which <code>getc</code> and <code>putc</code> are the simplest. <code>getc</code>
returns the next character from a file; it needs the file pointer to tell it
which file.</p>
<pre><code class="language-c">int getc(FILE *fp)
</code></pre>
<p><code>getc</code> returns the next character from the stream referred to by <code>fp</code>; it
returns <code>EOF</code> for end of file or error.</p>
<p><code>putc</code> is an output function:</p>
<pre><code class="language-c">int putc(int c, FILE *fp)
</code></pre>
<p><code>putc</code> writes the character <code>c</code> to the file <code>fp</code> and returns the character
written, or <code>EOF</code> if an error occurs. Like <code>getchar</code> and <code>putchar</code>, <code>getc</code> and
<code>putc</code> may be macros instead of functions.</p>
<p>When a C program is started, the operating system environment is responsible
for opening three files and providing file pointer for them. These files are
the standard input, the standard output, and the standard error; the
corresponding file pointers are called <code>stdin</code>, <code>stdout</code>, and <code>stderr</code>, and are
declared in <code>&lt;stdio.h&gt;</code>. Normally <code>stdin</code> is connected to the keyboard and
<code>stdout</code> and <code>stderr</code> are connected to the screen, but <code>stdin</code> and <code>stdout</code> may
be redirected to files or pipes as described in [Section @sec:stdin-stdout].</p>
<p><code>getchar</code> and <code>putchar</code> can be defined in terms of <code>getc</code>, <code>putc</code>, <code>stdin</code>, and
<code>stdout</code> as follows:</p>
<pre><code class="language-c">#define getchar()   getc(stdin)
#define putchar(c)  putc((c), stdout)
</code></pre>
<p>For formatted input or output of files, the functions <code>fscanf</code> and <code>fprintf</code>
may be used. These are identical to <code>scanf</code> and <code>printf</code>, except that the first
argument is a file pointer that specifies the file to be read or written; the
format string is the second argument.</p>
<pre><code class="language-c">int fscanf(FILE *fp, char *format, ...)
int fprintf(FILE *fp, char *format, ...)
</code></pre>
<p>With these preliminaries out of the way, we are no in a position to write the
program <code>cat</code> to concatenate files. The design is one that has been found
convenient for many programs. If there are command-line arguments, they are
interpreted as filenames, and processed in order. If there is no arguments, the
standard input is processed.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

/* cat:  concatenate files, version 1 */
main(int argc, char *argv[])
{
    FILE *fp;
    void filecopy(FILE *, FILE *);

    if (argc == 1)  /* no args; copy standard input */
        filecopy(stdin, stdout);
    else
        while (--argc &gt; 0)
            if ((fp = fopen(*++argv, &quot;r&quot;)) == NULL) {
                printf(&quot;cat: can't open %s\n&quot;, *argv);
                return 1;
            } else {
                filecopy(fp, stdout);
                fclose(fp);
            }
    return 0;
}


/* filecopy:  copy file ifp to file ofp */
void filecopy(FILE *ifp, FILE *ofp)
{
    int c;

    while ((c = getc(ifp)) != EOF)
        putc(c, ofp);
}
</code></pre>
<p>The file pointers <code>stdin</code> and <code>stdout</code> are objects of type <code>FILE *</code>. They are
constants; however, <em>not</em> variables, so it is not possible to assign to them.</p>
<p>The function</p>
<pre><code class="language-c">int fclose(FILE *fp)
</code></pre>
<p>is the inverse of <code>fopen</code>; it breaks the connection between the file pointer
and the external name that was established by <code>fopen</code>, freeing the file pointer
for another file. Since most operating systems have some limit on the number of
files that a program may have open simultaneously, it’s a good idea to free
file pointers when they are no longer needed, as we did in <code>cat</code>. There is also
another reason for <code>fclose</code> on an output file—it flushes the buffer in which
<code>putc</code> is collecting output. <code>fclose</code> is called automatically for each open
file when a program terminates normally. (You can close <code>stdin</code> and <code>stdout</code> if
they are not needed. They can also be reassigned by the library function
<code>freopen</code>.)</p>
<h2>Error Handling—Stderr and Exit</h2>
<p>The treatment of errors in <code>cat</code> is not ideal. The trouble is that if one of
the files can’t be accessed for some reason, the diagnostic is printed at the
end of the concatenated output. This might be acceptable if the output is going
to a screen, but not if it’s going into a file or a into another program via a
pipeline.</p>
<p>To handle this situation better, a second output stream, called <code>stderr</code>, is
assigned to a program the same way that <code>stdin</code> and <code>stdout</code> are. Output
written on <code>stderr</code> normally appears on the screen even if the standard output
is redirected.</p>
<p>Let us revise <code>cat</code> to write its error messages on the standard error.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

/* car: concatenate files, version 2 */
main(int argc, char *argv[])
{
    FILE *fp;
    void filecopy(FILE *, FILE *);
    char *prog = argv[0];   /* program name for errors */

    if (argc == 1) /* no args; copy standard input */
        filecopy(stdin, stdout);
    else
        while (--argc &gt; 0)
            if ((fp = fopen(*++argv, &quot;r&quot;)) == NULL) {
                fprintf(stderr, &quot;%s: can't open %s\n&quot;,
                    prog, *argv);
                exit(1);
            } else {
                filecopy(fp, stdout);
                fclose(fp);
            }
    if (ferror(stdout)) {
        fprintf(stderr, &quot;%s: error writing stdout\n&quot;, prog);
        exit(2);
    }
    exit(0);
}
</code></pre>
<p>The program signals errors two ways. First, the diagnostic output produced by
<code>fprintf</code> goes onto <code>stderr</code>, so it finds its way to the screen instead of
disappearing down a pipeline or into an output file. We included the program
name, from <code>argv[0]</code>, in the message, so if this program is used with others,
the source of an error is identified.</p>
<p>Second, the program uses the standard library function <code>exit</code>, which terminates
program  execution when it is called. The argument of <code>exit</code> is available to
whatever process called this one, so the success or failure of the program can
be tested by another program that uses this one as a sub-process.
Conventionally, a return value of <code>0</code> signals that all is well; non-zero values
usually signal abnormal situations. <code>exit</code> calls <code>fclose</code> for each open output
file, to flush out any buffered output.</p>
<p>Within <code>main</code>, <code>return expr</code> is equivalent to <code>exit(expr)</code>. <code>exit</code> has the
advantage that it can be called from other functions, and that calls to it can
be found with a pattern-searching program like those in [Chapter
@sec:pointers].</p>
<p>The function <code>ferror</code> returns non-zero if an error occurred on the stream <code>fp</code>.</p>
<pre><code class="language-c">int ferror(FILE *fp)
</code></pre>
<p>Although output errors are rare, they do occur (for example, if a disk fills
up), so a production program should check this as well.</p>
<p>The function <code>feof(FILE *)</code> is analogous to <code>ferror</code>; it returns non-zero if
end of file has occurred on the specified file.</p>
<pre><code class="language-c">itn feof(FILE *fp)
</code></pre>
<p>We have generally not worried about exit status in out small illustrative
programs, but any serious program should take care to return sensible, useful
status values.</p>
<h2>Line Input and Output</h2>
<p>The standard library provides an input routine <code>fgets</code> that is similar to the
<code>getline</code> function that we have used in earlier chapters:</p>
<pre><code class="language-c">char *fgets(char *line, int maxline, FILE *fp)
</code></pre>
<p><code>fets</code> reads the next input line (including the newline) from file <code>fp</code> into
the character array <code>line</code>; at most <code>manline-1</code> characters will be read. The
resulting line is terminated with <code>'\0'</code>. Normally <code>fgets</code> returns <code>line</code>; on
end of file or error it returns <code>NULL</code>. (Our <code>getline</code> returns the line length,
which is a more useful value; zero means end of file.)</p>
<p>For output, the function <code>fputs</code> writes a string (which need not contain a
newline) to a file:</p>
<pre><code class="language-c">int fputs(char *line, FILE *fp)
</code></pre>
<p>It returns <code>EOF</code> if an error occurs, and zero otherwise.</p>
<p>The library functions <code>gets</code> and <code>puts</code> are similar to <code>fgets</code> and <code>fputs</code>, but
operate on <code>stdin</code> and <code>stdout</code>. Confusingly, <code>gets</code> deletes the terminal
<code>'\n'</code>, and <code>puts</code> adds it.</p>
<p>To show that there is nothing special about functions like <code>fgets</code> and <code>fputs</code>,
here they are, copied from the standard library on our system:</p>
<pre><code class="language-c">/* fgets:  get at most n chars from iop */
char *fgets(char *s, int n, FILE *iop)
{
    register int c;
    register char *cs;

    cs = s;
    while (--n &gt; 0 &amp;&amp; (c = getc(iop)) != EOF)
        if ((*cs++ = c) == '\n')
            break;
    *cs = '\0';
    return (c == EOF &amp;&amp; cs == s) ? NULL : s;
}


/* fputs:  put string s on file iop */
int fputs(char *s, FILE *iop)
{
    int c;

    while (c = *s++)
        putc(c, iop);
    return ferror(iop) ? EOF : 0;
}
</code></pre>
<p>The standard specifies that <code>ferror</code> returns non-zero for error <code>fputs</code> returns
<code>EOF</code> for error and a non-negative value otherwise.</p>
<p>It is easy to implement our <code>getline</code> from <code>fgets</code>:</p>
<pre><code class="language-c">/* getline:  read a line, return length */
int getline(char *line, int max)
{
    if (fgets(line, max, stdin) == NULL)
        return 0;
    else
        return strlen(line);
}
</code></pre>
<p><strong>Exercise 7-6.</strong> Write a program to compare two files, printing the first line
where they differ.</p>
<p><strong>Exercise 7-7.</strong> Modify the pattern finding program of [Chapter @sec:pointers]
to take its input from a set of named files, or if no files are named as
arguments, from the standard input. Should the file name be printed when a
matching line is found?</p>
<p><strong>Exercise 7-8.</strong> Write a program to print a set of files, starting each new
one on a new page, with a title and a running page count for each file.</p>
<h2>Miscellaneous Functions</h2>
<p>The standard library provides a variety of functions. This section is a brief
synopsis of the most useful. More details and many other functions can be found
in [Appendix @sec:std-lib].</p>
<h3>String Operations</h3>
<p>We have already mentioned the string functions <code>strlen</code>, <code>strcpy</code>, <code>strcat</code>,
and <code>strcmp</code>, found in <code>&lt;string.h&gt;</code>. In the following, <code>s</code> and <code>t</code> are <code>char *</code>’s, and <code>c</code> and <code>n</code> are <code>ints</code>.</p>
<pre><code>strcat(s,t)     concatenate t ot end of s
strncat(s,t,n)  concatenate n characters of t to the end of s
strcmp(s,t)     return negative, zero, or positive for
                   s &lt; t, s == t, or s &gt; t
strncmp(s,t,n)  same as strcmp but only in first n characters
strcpy(s,t)     copy t to s
strncpy(s,t,n)  copy at most n characters of t to s
strlen(s)       return length of s
strchr(s,c)     return poitner to first c in s, or NULL if not present
strrchr(s,c)    return pointer to last c in s, or NULL if not present
</code></pre>
<h3>Character Class Testing and Conversion</h3>
<p>Several functions from <code>&lt;ctype.h&gt;</code> perform character tests and conversions. In
the following, <code>c</code> is an <code>int</code> that can be represented as an <code>unsigned char</code>,
or <code>EOF</code>. The functions return <code>int</code>.</p>
<pre><code>isalpha(c)  non-zero if c is alphabetic, 0 if not
isupper(c)  non-zero if c is upper case, 0 if not
islower(c)  non-zero if c is lower case, 0 if not
isdigit(c)  non-zero if c is digit, 0 if not
isalnum(c)  non-zero if isalpha(c) or isdigit(c), 0 if not
isspace(c)  non-zero if c is blank, tab, newline, return,
               formfeed, vertical tab
toupper(c)  returns c converted to upper case
towloer(c)  returns c converted to lower case
</code></pre>
<h3>Ungetc</h3>
<p>The standard library provides a rather restricted version of the function
<code>ungetch</code> that we wrote in [Chapter @sec:functions]; it is called <code>ungetc</code>.</p>
<pre><code class="language-c">int ungetc(int c, FILE *fp)
</code></pre>
<p>pushes the character <code>c</code> back onto file <code>fp</code>, and returns either <code>c</code>, or <code>EOF</code>
for an error. Only one character of pushback is guaranteed per file. <code>ungetc</code>
may be used with any of the input functions like <code>scanf</code>, <code>getc</code>, or <code>getchar</code>.</p>
<h3>Command Execution</h3>
<p>The function <code>system(char *s)</code> executes the command contained in the character
string <code>s</code>, then resumes execution of the current program. The contents of <code>s</code>
depend strongly on the local operating system. As a trivial example, on UNIX
systems, the statement</p>
<pre><code class="language-c">system(&quot;date&quot;);
</code></pre>
<p>causes the program <code>date</code> to be run; it prints the date and time of day on the
standard output. <code>system</code> returns a system-dependent integer status from the
command executed. In the <code>UNIX</code> system, the status return is the value returned
by <code>exit</code>.</p>
<h3>Storage Management</h3>
<p>The functions <code>malloc</code> and <code>calloc</code> obtain blocks of memory dynamically.</p>
<pre><code class="language-c">void *malloc(size_t n)
</code></pre>
<p>returns a pointer to <code>n</code> bytes of uninitialized storage, or <code>NULL</code> if the
request cannot be satisfied.</p>
<pre><code class="language-c">void *calloc(size_t n, size_t size)
</code></pre>
<p>returns a pointer to enough space for an array of <code>n</code> objects of the specified
size, or <code>NULL</code> if the request cannot be satisfied. The storage is initialized
to zero.</p>
<p>The pointer returned by <code>malloc</code> or <code>calloc</code> has the proper alignment for the
object in question, but it must be cast into the appropriate type, as in</p>
<pre><code class="language-c">int *ip;

ip = (int *) calloc(n, sizeof(int));
</code></pre>
<p><code>free(p)</code> frees the space pointed to by <code>p</code>, where <code>p</code> was originally obtained
by a call to <code>malloc</code> or <code>calloc</code>. There is no restrictions on the order in
which space is freed, but it is a ghastly error to free something not obtained
by calling <code>calloc</code> or <code>malloc</code>.</p>
<p>It is also an error to use something after it has been freed, A typical but
incorrect piece of code is this loop that frees items from a list:</p>
<pre><code class="language-c">for (p = head; p != NULL; p = p-&gt;next)  /* WRONG */
    free(p);
</code></pre>
<p>The right way is to save whatever is needed before freeing:</p>
<pre><code class="language-c">for (p = head; p != NULL; p = q) {
    q = p-&gt;next;
    free(p);
}
</code></pre>
<p>[Section @sec:stor-alloc] shows the implementation of a storage allocator like
<code>malloc</code>, in which allocated blocks may be freed in any order.</p>
<h3>Mathematical Functions</h3>
<p>There are more than twenty mathematical functions declared in <code>&lt;math.h&gt;</code>; here
are some of the more frequently used. Each takes one or two <code>double</code> arguments
and returns a <code>double</code>.</p>
<pre><code>sin(x)      sine of x, x in radians
cos(x)      cosine of x, x in radians
atan2(y,x)  arctangent of y/x, in radians
exp(x)      exponential functions e^x
log(x)      natural (base e) logarithm of x (x&gt;0)
log10(x)    common (base 10) logarithm of x (x&gt;0)
pow(x,y)    x^y
sqrt(x)     square root of x (x&gt;=0)
fabs(x)     absolute value of x
</code></pre>
<h3>Random Number Generation</h3>
<p>The function <code>rand()</code> computes a sequence of pseudo-random integers in the
range zero to <code>RAND_MAX</code>, which is defined in <code>&lt;stdlib.h&gt;</code>. One way to produce
random floating-point numbers greater than or equal to zero but less than one
is</p>
<pre><code class="language-c">#define frand() ((double) rand() / (RAND_MAX+1.0))
</code></pre>
<p>(If your library already providea function for floating-point random numbers,
it is likely to have better statistical properties than this one.)</p>
<p>The function <code>srand(unsigned)</code> sets the seed for <code>rand</code>. The portable
implementation of <code>rand</code> and <code>srand</code> suggested by the standard appears in
[Section @sec:type-conversions].</p>
<p><strong>Exercise 7-9.</strong> Functions like <code>isupper</code> can be implemented to save space or
to save time. Explore both possibilities.</p>
<h1>The UNIX System Interface {#sec:UNIX}</h1>
<p>The UNIX operating system provides its services through a set of <em>system
calls</em>, which are in effect functions within the operating system that may be
called by user programs. This chapter describes how to use some of the most
important calls from C programs. If you use UNIX, this should be directly
helpful, for it is sometimes necessary to employ system calls for maximum
efficiency, or to access some facility that is not in the library. Even if you
use C on a different operating system, however, you should be able to glean
insight into C programming from studying these examples; although details vary,
similar code will be found on any system. Since the ANSI C library is in many
cases modeled on UNIX facilities, this code may help your understanding of the
library as well.</p>
<p>The chapter is divided into three major parts: input/output, file system, and
storage allocation. The first two parts assume a modest familiarity with the
external characteristics of UNIX systems.</p>
<p>[Chapter @sec:IO] was concerned with an input/output interface that is uniform
across operating systems. On any particular system the routines of the standard
library have to be written in terms of the facilities provided by the host
system. In the next few sections we will describe the UNIX system calls for
input and output, and show how parts of the standard library can be implemented
with them.</p>
<h2>File Descriptors</h2>
<p>In the UNIX operating system, all input and output is done by reading or
writing files, because all peripheral devices, even keyboard and screen, are
files in the file system. This means that a single homogeneous interface
handles all communication between a program and peripheral devices.</p>
<p>In the most general case, before you read or write a file, you must inform the
system of your intent to do so, a process called <em>opening</em> the file. If you are
going to write on a file it may also be necessary to create it or to discard
its previous contents. The system checks your right to do so (Does the file
exist? Do you have permission to access it?), and if all is well, returns to
the program a small non-negative integer called a <em>file descriptor</em>. Whenever
input or output is to be done in a file, the file descriptor is used instead of
the name to identify the file. (A file descriptor is analogous to the file
pointer used by the standard library, or to the file handle of MS-DOS.) All
information about an open file is maintained by the system; the user program
refers to the file only by the file descriptor.</p>
<p>Since input and output involving keyboard and screen is so common, special
arrangements exist to make this convenient. When the command interpreter (the
“shell”) runs a program, three files are open, with file descriptors <code>0</code>, <code>1</code>,
and <code>2</code>, called the standard input, the standard output, and the standard
error. If a program reads <code>0</code> and writes <code>1</code> and <code>2</code>, it can do input and
output without worrying about opening files.</p>
<p>The user of a program can redirect I/O to and from files with <code>&lt;</code> and <code>&gt;</code>:</p>
<pre><code class="language-sh">prog &lt;infile &gt;outfile
</code></pre>
<p>In this case, the shell changes the default assignments for file descriptors
<code>0</code> and <code>1</code> to the named files. Normally file descriptor <code>2</code> remains attached
to the screen, so error messages can go there. Similar observations hold for
input or output associated with a pipe. In all cases, the file assignments are
changed by the shell, not by the program. The program does not know where its
input comes from nor where its output goes, so long as it uses file <code>0</code> for
input and <code>1</code> and <code>2</code> for output.</p>
<h2>Low Level I/O—Read and Write</h2>
<p>Input and output uses the <code>read</code> and <code>write</code> system calls, which are accessed
from C programs through two functions called <code>read</code> and <code>write</code>. For both, the
first argument is a file descriptor. The second argument is a character array
in your program where the data is to go to or come from. The third argument is
the number of bytes to be transferred.</p>
<pre><code class="language-c">int n_read = read(int fd, char *buf, int n);
int n_written = write(int fd, char *buf, int n);
</code></pre>
<p>Each call returns a count of the number of bytes transferred. On reading, the
number of bytes returned may be less than the number requested. A return value
of zero bytes implies end of file, and <code>-1</code> indicates an error of some sort.
For writing, the return value is the number of bytes written; an error has
occurred if this isn’t equal to the number requested.</p>
<p>Any number of bytes can be read or written in one call. The most common values
are <code>1</code>, which means one character at a time (“unbuffered”), and a number like
<code>1024</code> or <code>4096</code> that corresponds to a physical block size on a peripheral
device. Larger sizes will be more efficient because fewer system calls will be
made.</p>
<p>Putting these facts together, we can write a simple program to copy its input
to its output, the equivalent of the file copying program written for [Chapter
@sec:introduction]. This program will copy anything to anything, since the
input and output can be redirected to any file or device.</p>
<pre><code class="language-c">#include &lt;syscalls.h&gt;

main()  /* copy input to output */
{
    char buf[BUFSIZ];
    int n;

    while ((n = read(0, buf, BUFSIZ)) &gt; 0)
        write(1, buf, n);
    return 0;
}
</code></pre>
<p>We have collected function prototypes for the system calls into a file called
<code>syscalls.h</code> so we can include it in the programs of this chapter. This name is
not standard, however.</p>
<p>The parameter <code>BUFSIZ</code> is also defined in <code>syscalls.h</code>; its value is a good
size for the local system. If the file size is not a multiple of <code>BUFSIZ</code>, some
<code>read</code> will return a smaller number of bytes to be written by <code>write</code>; the next
call to <code>read</code> after that will return zero.</p>
<p>It is instructive to see how <code>read</code> and <code>write</code> can be used to construct
higher-level routines like <code>getchar</code>, <code>putchar</code>, etc. For example, here is a
version of <code>getchar</code> that does unbuffered input, by reading the standard input
one character at a time.</p>
<pre><code class="language-c">#include &quot;syscalls.h&quot;

/* getchar:  unbuffered single character input */
int getchar(void)
{
    char c;

    return (read(0, &amp;c, 1) == 1) ? (unsigned char) c : EOF;
}
</code></pre>
<p><code>c</code> must be a <code>char</code>, because <code>read</code> needs a character pointer. Casting <code>c</code> to
<code>unsigned char</code> in the return statement eliminates any problem of sign
extension.</p>
<p>The second version of <code>getchar</code> does input in big chunks, and hands out the
characters one at a time.</p>
<pre><code class="language-c">#include &quot;syscalls.h&quot;

/* getchar:  simple buffered version */
int getchar(void)
{
    static char buf[BUFSIZ];
    static char *bufp = buf;
    static int n = 0;

    if (n == 0) {   /* buffer is empty */
        n = read(0, buf, sizeof buf);
        bufp = buf;
    }
    return (--n &gt;= 0) ? (unsigned char) *bufp++ : EOF;
}
</code></pre>
<p>If these versions of <code>getchar</code> were to be compiled with <code>&lt;stdio.h&gt;</code> included,
it would be necessary to <code>#undef</code> the name <code>getchar</code> in case it is implemented
as a macro.</p>
<h2>Open, Creat, Close, Unlink</h2>
<p>Other than the default standard input, output and error, you must explicitly
open files in order to read or write them. There are two system calls for this,
<code>open</code> and <code>creat</code><em>[sic]</em>.</p>
<p><code>open</code> is rather like the <code>fopen</code> discussed in [Chapter @sec:IO], except that
instead of returning a file pointer, it returns a file descriptor, which is
just an <code>int</code>. <code>open</code> returns <code>-1</code> if any error occurs.</p>
<pre><code class="language-c">#include &lt;fcntl.h&gt;

int fd;
int open(char *name, int flags, int perms);

fd = open(name, flags, perms);
</code></pre>
<p>As with <code>fopen</code>, the <code>name</code> argument is a character string containing the
filename. The second argument, <code>flags</code>, is an <code>int</code> that specifies hot the file
is to be opened; the mail values are</p>
<pre><code>O_RDONLY    open for reading only
O_WRONLY    open for writing only
O_RDWR      open for both reading and writing
</code></pre>
<p>These constants are defined in <code>&lt;fcntl.h&gt;</code> on System V UNIX systems, and in
<code>&lt;sys/file.h&gt;</code> on Berkeley (BSD) versions.</p>
<p>To open an existing file for reading,</p>
<pre><code class="language-c">fd = open(name, O_RDONLY, 0);
</code></pre>
<p>The <code>perms</code> argument is always zero for the uses of open that we will discuss.</p>
<p>It is an error to try to <code>open</code> a file that does not exist. The system call
<code>creat</code> is provided to create new files, or to re-write old ones.</p>
<pre><code class="language-c">int creat(char *name, int perms);

fd = creat(name, perms);
</code></pre>
<p>returns a file descriptor if it was able to create the file, and <code>-1</code> if not.
If the file already exists, <code>creat</code> will truncate it to zero length, thereby
discarding its previous contents; it is not an error to <code>creat</code> a file that
already exists.</p>
<p>If the file does not already exist, <code>creat</code> creates it with the permissions
specified by the <code>perms</code> argument. In the UNIX file system, there are nine bits
of permission information associated with a file that control read, write and
execute access for the owner of the file, for the owner’s group, and for all
others. Thus a three-digit octal number is convenient for specifying the
permissions. For example <code>0755</code> specified read, write and execute permission
for the owner, and read and execute permission for the group and everyone else.</p>
<p>To illustrate, here is a simplified version of the UNIX program <code>cp</code>, which
copies one file to another. Our version copies only one file, it does not
permit the second argument is be a directory, and it invents permissions
instead of copying them.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &quot;syscalls.h&quot;
#define PERMS 0666   /* RW for owner, group, others */

void error(char *, ...);

/* cp:  copy f1 to f2 */
main(int argc, char *argv[])
{
    int f1, f2, nl
    char buf[BUFSIZ];

    if (argc != 3)
        error(&quot;Usage: cp from to&quot;);
    if ((f1 = open(argv[1], O_RDONLY, 0)) == -1)
        error(&quot;cp: can't open %s&quot;, argv[1]);
    if ((f2 = creat(argv[2], PERMS)) == -1)
        error(&quot;cp: can't create %s, mode %03o&quot;,
            argv[2], PERMS);
    while ((n = read(f1, buf, BUFSIZE)) &gt; 0)
        if (write(f2, buf, n) != n)
            error(&quot;cp: write error on file %s&quot;, argv[2]);
    return 0;
}
</code></pre>
<p>This program create the output file with fixed permissions of <code>0666</code>. With the
<code>stat</code> system call, described in [Section @sec:ls-dir], we can determine the
mode of an existing file and thus give the same mode to copy.</p>
<p>Notice that the function <code>error</code> is called with variable argument lists much
like <code>printf</code>. The implementation of <code>error</code> illustrates how to use another
number of the <code>printf</code> family. The standard library function <code>vprintf</code> is like
<code>printf</code> except that the variable argument list is replaced by a single
argument that has been initialized by calling the <code>va_start</code> macro. Similarly,
<code>vfprintf</code> and <code>vsprintf</code> match <code>fprintf</code> and <code>sprintf</code>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

/* error:  print an error message and die */
void error(char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);
    fprintf(stderr, &quot;error: &quot;);
    vfprintf(stderr, fmt, args);
    fprintf(stderr, &quot;\n&quot;);
    va_end(args);
    exit(1);
}
</code></pre>
<p>There is a limit (often about 20) on the number of files that a program can
have open simultaneously. Accordingly, any program that intents to process many
files must be prepared to re-use file descriptors. The function <code>close(int fd)</code>
breaks the connection between a file descriptor and an open file, and frees the
file descriptor for use with some other file; it corresponds to <code>fclose</code> in the
standard library except that there is no buffer to flush. Termination of a
program via <code>exit</code> or <code>return</code> from the main program closes all open files.</p>
<p>The function <code>unlink(char *name)</code> removes the file <code>name</code> from the file system.
It corresponds to the standard library function <code>remove</code>.</p>
<p><strong>Exercise 8-1.</strong> Rewrite the program <code>cat</code> from [Chapter @sec:IO] using
<code>read</code>, <code>write</code>, <code>open</code> and <code>close</code> instead of their standard library
equivalents. Perform experiments to determine the relative speeds of the two
versions.</p>
<h2>Random Access—Lseek</h2>
<p>Input and output are normally sequential: each <code>read</code> or <code>write</code> takes place at
a position in the file right after the previous one. When necessary, however, a
file can be read or written in any arbitrary order. The system call <code>lseek</code>
provides a way to move around in a file without reading or writing any data:</p>
<pre><code class="language-c">long lseek(int fd, long offset, int origin);
</code></pre>
<p>sets the current position in the file whose descriptor is <code>fd</code> to <code>offset</code>,
which is taken relative to the location specified by <code>origin</code>. Subsequent
reading or writing will begin at that position. <code>origin</code> can be <code>0</code>, <code>1</code>, or
<code>2</code> to specify that <code>offset</code> is to be measured from the beginning, from the
current position, or from the end of the file respectively. For example, to
append to a file (the redirection <code>&gt;&gt;</code> in the UNIX shell, or <code>&quot;a&quot;</code> for
<code>fopen</code>), seek to the end before writing:</p>
<pre><code class="language-c">lseek(fd, 0L, 2);
</code></pre>
<p>To get back to the beginning (“rewind”),</p>
<pre><code class="language-c">lseek(fd, 0L, 0);
</code></pre>
<p>Notice the <code>0L</code> argument; it could also be written as <code>(long) 0</code> or just as <code>0</code>
if <code>lseek</code> is properly declared.</p>
<p>With <code>lseek</code>, it is possible to treat files more or less like large arrays, at
the price of slower access. For example, the following function reads any
number of bytes from any arbitrary place in a file. It returns the number read,
or <code>-1</code> on error.</p>
<pre><code class="language-c">#include &quot;syscalls.h&quot;

/* get: read n bytes from position pos */
int get(int fd, long pos, char *buf, int n)
{
    if (lseek(fd, pos, 0) &gt;= 0)  /* get to pos */
        return read(fd, buf, n);
    else
        return -1;
}
</code></pre>
<p>The return value from <code>lseek</code> is a <code>long</code> that gives the new position in the
file, or <code>-1</code> if an error occurs. The standard library function <code>fseek</code> is
similar to <code>lseek</code> except that the first argument is a <code>FILE *</code> and return is
non-zero if an error occurred.</p>
<h2>Example—An Implementation of Fopen and Getc {#sec:fopen-getc}</h2>
<p>Let us illustrate how some of these pieces fit together by showing an
implementation of the standard library routines <code>fopen</code> and <code>getc</code>.</p>
<p>Recall that files in the standard library are described by file pointers rather
than file descriptors. A file pointer is a pointer to a structure that contains
several pieces of information about the file: a pointer to a buffer, so the
file can be read in large chunks; a count of the number of characters left in
the buffer; a pointer to the next character position in the buffer; the file
descriptor; and flags describing read/write mode, error status, etc.</p>
<p>The data structure that describes a file is contained in <code>&lt;stdio.h&gt;</code>, which
must be included (by <code>#include</code>) in any source file that uses routines from the
standard input/output library. It is also included by functions in that
library. In the following excerpt from a typical <code>&lt;stdio.h&gt;</code>, names that are
intended for use only by functions of the library begin with an underscore so
they are less likely to collide with names in a user’s program. This convention
is used by all standard library routines.</p>
<pre><code class="language-c">#define NULL      0
#define EOF       (-1)
#define BUFSIZE   1024
#define OPEN_MAX  20  /*max #files open at once */

typedef struct _iobuf {
    int  cnt;         /* characters left */
    char *ptr;        /* next character position */
    char *base;       /* location of buffer */
    int flag;         /* mode of file access */
    int fd;           /* file descriptor */
} FILE;
extern FILE _iob[OPEN_MAX];

#define stdin   (&amp;_iob[0])
#define stdout  (&amp;_iob[1])
#define stderr  (&amp;_iob[2])

enum _flags {
    _READ   = 01,     /* file open for reading */
    _WRITE  = 02,     /* file open for writing */
    _UNBUF  = 04,     /* file is unbuffered */
    _EOF    = 010,    /* EOF has occurred on this file */
    _ERR    = 020     /* error occurred on this file */
};

int _fillbuf(FILE *);
int _flushbuf(int, FILE *);

#define feof(p)     (((p)-&gt;flag &amp; _EOF) != 0)
#define ferror(p)   (((p)-&gt;flag &amp; _ERR) != 0)
#define fileno(p)   ((p)-&gt;fd)

#define getc(p)   (--(p)-&gt;cnt &gt;= 0 \
               ? (unsigned char) *(p)-&gt;ptr++ : _fillbuf(p))
#define putc(x,p) (--(p)-&gt;cnt &gt;= 0 \
               ? *(p)-&gt;ptr++ = (x) : _flushbuf((x),p))

#define getchar()   getc(stdin)
#define putchar(x)  putc((c), stdout)
</code></pre>
<p>The <code>getc</code> macro normally decrements the count, advances the pointer, and
returns the character. (Recall that a long <code>#define</code> is continued with a
backslash.) If the count goes negative, however, <code>getc</code> calls the function
<code>_fillbuf</code> to replenish the buffer, re-initialize the structure contents, and
return a character. The characters are returned <code>unsigned</code>, which ensures that
all characters will be positive.</p>
<p>Although we will not discuss any details, we have included the definition of
<code>putc</code> to show that it operates in much the same way as <code>getc</code>, calling a
function <code>_flushbuf</code> when its buffer is full. We have also included macros for
accessing the error and end-of-file status and the file descriptor.</p>
<p>The function <code>fopen</code> can now be written. Most of <code>fopen</code> is concerned with
getting the file opened and position at the right place, and setting the flag
bits to indicate the proper state. <code>fopen</code> does not allocate any buffer space;
this is done by <code>_fillbuf</code> when the file is first read.</p>
<pre><code class="language-c">#include &lt;fcntl.h&gt;
#include &quot;syscalls.h&quot;
#define PERMS 0666   /* RW for owner, group, others */

/* fopen:  open file, return file ptr */
FILE *fopen(char *name, char *mode)
{
    int fd;
    FILE *fp;

    if (*mode != 'r' &amp;&amp; *mode != 'w' &amp;&amp; *mode != 'a')
        return NULL;
    for (fp = _iob; fp &lt; _iob + OPEN_MAX; fp++)
        if ((fp-&gt;flag &amp; (_READ | _WRITE)) == 0)
            break;        /* found free slot */
    if (fp &gt;= _iob + OPEN_MAX)    /* no free slots */
        return NULL;

    if (*mode == 'w')
        fd = creat(name, PERMS);
    else if (*mode == 'a') {
        if ((fd = open(name, O_WRONLY, 0)) == -1)
            fd = creat(name, PERMS);
        lseek(fd, 0L, 2);
    } else
        fd = open(name, O_RDONLY, 0);
    if (fd == -1)         /* couldn't access name */
        return NULL;
    fp-&gt;fd = fd;
    fp-&gt;cnt = 0;
    fp-&gt;base = NULL;
    fp-&gt;flag = (*mode == 'r') ? _READ : _WRITE;
    return fp;
}
</code></pre>
<p>This version of <code>fopen</code> does not handle all of the access mode possibilities of
the standard, though adding them would not take much code. In particular, out
<code>fopen</code> does not recognize the <code>&quot;b&quot;</code> that signals binary access, since that is
meaningless on UNIX systems, nor the <code>&quot;+&quot;</code> that permits both reading and
writing.</p>
<p>The first call to <code>getc</code> for a particular file finds a count of zero, which
forces a call of <code>_fillbuf</code>. If <code>_fillbuf</code> finds that the file is not open for
reading, it returns <code>EOF</code> immediately. Otherwise, it tries to allocate a buffer
(if reading is to be buffered).</p>
<p>Once the buffer is established, <code>_fillbuf</code> calls <code>read</code> to fill it, sets the
count and pointers, and returns the character at the beginning of the buffer.
Subsequent calls to <code>_fillbuf</code> will find a buffer allocated.</p>
<pre><code class="language-c">#include &quot;syscalls.h&quot;

/* _fillbuf:  allocate and fill input buffer */
int _fillbuf(FILE *fp)
{
    int bufsize;

    if ((fp-&gt;flag&amp;(_READ|_EOF|_ERR)) != _READ)
        return EOF;
    bufsize = (fp-&gt;flag &amp; _UNBUF) ? 1 : BUFSIZ;
    if (fp-&gt;base == NULL)     /* no buffer yet */
        if ((fp-&gt;base = (char *) malloc(bufsize)) == NULL)
            return EOF;       /* can't get buffer */
    fp-&gt;ptr = fp-&gt;base;
    fp-&gt;cnt = read(fp-&gt;fd, fp-&gt;ptr, bufsize);
    if (--fp-&gt;cnt &lt; 0) {
        if (fp-&gt;cnt == -1)
            fp-&gt;flag |= _EOF;
        else
            fp-&gt;flag |= _ERR;
        fp-&gt;cnt = 0;
        return EOF;
    }
    return (unsigned char) *fp-&gt;ptr++;
}
</code></pre>
<p>The only remaining loose end is how everything gets started. The array <code>_iob</code>
must be defined and initialized for <code>stdin</code>, <code>stdout</code> and <code>stderr</code>:</p>
<pre><code class="language-c">FILE _IOB[OPEN_MAX] = {    /* stdin, stdout, stderr: */
    { 0, (char *) 0, (char *) 0, _READ, 0 },
    { 0, (char *) 0, (char *) 0, _WRITE, 1 },
    { 0, (char *) 0, (char *) 0, _WRITE | _UNBUF, 2 }
};
</code></pre>
<p>The initialization of the <code>flag</code> part of the structure shows that <code>stdin</code> is to
be read, <code>stdout</code> is to be written, and <code>stderr</code> is to be unbuffered.</p>
<p><strong>Exercise 8-2.</strong> Rewrite <code>fopen</code> and <code>_fillbuf</code> with fields instead of
explicit bit operations. Compare code size and execution speed.</p>
<p><strong>Exercise 8-3.</strong> Design and write <code>_flushbuf</code>, <code>fflush</code>, and <code>fclose</code>.</p>
<p><strong>Exercise 8-4.</strong> The standard library function</p>
<pre><code class="language-c">int fseek(FILE *fp, long offset, int origin)
</code></pre>
<p>is identical to <code>lseek</code> except that <code>fp</code> is a file pointer instead of a file
descriptor and the return value is an <code>int</code> status, not a position. Write
<code>fseek</code>. Make sure that your <code>fseek</code> coordinates properly with the buffering
done for the other functions of the library.</p>
<h2>Example—Listing Directories {#sec:ls-dir}</h2>
<p>A different kind of file system interaction is sometimes called
for—determining information <em>about</em> a file, not what it contains. A
directory-listing program such as the UNIX command <code>ls</code> is an example—it
prints the names of files in a directory, and optionally, other information,
such as sizes, permissions, and so on. The MS-DOS <code>dir</code> command is analogous.</p>
<p>Since a UNIX directory is just a file, <code>ls</code> need only read it to retrieve the
filenames. But it is necessary to use a system call to access other information
about a file, such as its size. On other systems, A system call may be needed
even to access filenames; this is the case on MS-DOS, for instance. What we
want is provide access to the information in a relatively system-independent
way, even though the implementation may be highly system-dependent.</p>
<p>We will illustrate some of this by writing a program called <code>fsize</code>. <code>fsize</code> is
a special form of <code>ls</code> that prints the sizes of all files named in its command
line argument list. If one of the files is a directory, <code>fsize</code> applies itself
recursively to that directory. If there are no arguments at all, it processes
the current directory.</p>
<p>Let us begin with a short review of UNIX file system structure. A <em>directory</em>
is a file that contains a list of filenames and some indication of where they
are located. The “location” is an index into another table called the “inode
list.” The <em>inode</em> for a file is where all information about a file except its
name is kept. A directory entry generally consists of only two items, the
filename and an inode number.</p>
<p>Regrettably, the format and precise contents of a directory are not the same on
all versions of the system. So we will divide the task into two pieces to try
to isolate the non-portable parts. The outer level defines a structure called a
<code>Dirent</code> and three routines <code>opendir</code>, <code>readdir</code>, and <code>closedir</code> to provide
system-independent access to the name and inode number in a directory entry. We
will write <code>fsize</code> with this interface. Then we will show how to implement
these on systems that use the same directory structures as Version 7 and System
V UNIX; variants are left as exercises.</p>
<p>The <code>Dirent</code> structure contains the inode number and the name. The maximum
length of a filename component is <code>NAME_MAX</code>, which is a system-dependent
value. <code>opendir</code> returns a pointer to a structure called <code>DIR</code>, analogous to
<code>FILE</code>, which is used by <code>readdir</code> and <code>closedir</code>. This information is
collected into a file called <code>dirent.h</code>.</p>
<pre><code class="language-c">#define NAME_MAX  14  /* longest filename component; */
                              /* system-dependent */

typedef struct {      /* portable directory entry: */
    long ino;                 /* inode number */
    char name[NAME_MAX+1];    /* name + '\0' terminator */
} Dirent;

typedef struct {      /* minimal DIR: no buffering, etc. */
    int fd;             /* file descriptor for directory */
    Dirent d;           /* the directory entry */
} DIR;

DIR *opendir(char *dirname);
Dirent *readdir(DIR *dfd);
void closedir(DIR *dfd);
</code></pre>
<p>The system call <code>stat</code> takes a filename and returns all of the information in
the inode for that file, or <code>-1</code> if there is an error. That is,</p>
<pre><code class="language-c">char *name;
struct stat stbuf;
int stat(char *, struct stat *);

stat(name, &amp;stbuf);
</code></pre>
<p>fills the structure <code>stbuf</code> with the inode information for the file <code>name</code>. The
structure describing the value returned by <code>stat</code> is in <code>&lt;sys/stat.h&gt;</code>, and
typically looks like this:</p>
<pre><code class="language-c">struct stat   /* inode information returned by stat */
{
    dev_t     st_dev;   /* device of inode */
    ino_t     st_ino;   /* inode number */
    short     st_mode;  /* mode bits */
    short     st_nlink; /* number of links to file */
    short     st_uid;   /* owner's user id */
    short     st_gid;   /* owner's group id */
    dev_t     st_rdev;  /* for special files */
    off_t     st_size;  /* file size in characters */
    time_t    st_atime; /* time last accessed */
    time_t    st_mtime; /* time last modified */
    time_t    st_ctime; /* time inode last changed */
};
</code></pre>
<p>Most of these values are explained by the comment fields. The types like
<code>dev_t</code> and <code>ino_t</code> are defined in <code>&lt;sys/types.h&gt;</code>, which much be included too.</p>
<p>The <code>st_mode</code> entry contains a set of flags describing the file. The flag
definitions are also included in <code>&lt;sys/stat.h&gt;</code>; we need only the part that
deals with file types:</p>
<pre><code class="language-c">#define   S_IFMT 0160000    /* type of file: */
#define   S_IFDIR  0040000  /* directory */
#define   S_IFCHR  0020000  /* character special */
#define   S_IFBLK  0060000  /* block special */
#define   S_IFREG  0100000  /* regular */

/* ... */
</code></pre>
<p>Now we are ready to write the program <code>fsize</code>. If the mode obtained from <code>stat</code>
indicates that a file is not a directory, then the size is at hand and can be
printed directly. If the file is a directory, however, then we have to process
that directory one file at a time; it may in turn contain sub-directories, so
the process is recursive.</p>
<p>The main routine deals with command-line arguments; it hands each argument to
the function <code>fsize</code>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &quot;syscalls.h&quot;
#include &lt;fcntl.h&gt;      /* flags for read and write */
#include &lt;sys/types.h&gt;  /* typedefs */
#include &lt;sys/stat.h&gt;   /* structure returned by stat */
#include &quot;dirent.h&quot;

void fsize(char *);

/* print file sizes */
main(int argc, char **argv)
{
    if (argc == 1)      /* default: current directory */
        fsize(&quot;.&quot;);
    else
        whiel (--argc &gt; 0)
            fsize(*++argv);
    return 0;
}
</code></pre>
<p>The function <code>fsize</code> prints the size of the file. If the file is a directory,
however, <code>fsize</code> first calls <code>dirwalk</code> to handle all the files in it. Not how
the flag names <code>S_IFMT</code> and <code>S_IFDIR</code> from <code>&lt;sys/stat.h&gt;</code> are used to decide if
the file is a directory. Parenthesization matters, because the precedence of
<code>&amp;</code> is lower than that of <code>==</code>.</p>
<pre><code class="language-c">int stat(char *, struct stat *);
void dirwalk(char *, void (*fcn)(char *));

/* fsize:  print size of file &quot;name&quot; */
void fsize(char *name)
{
    struct stat stbuf;

    if (stat(name, &amp;stbuf) == -1) {
        fprintf(stderr, &quot;fsize: can't access %s\n&quot;, name);
        return;
    }
    if ((stbuf.st_move &amp; S_IFMT) == S_IFDIR)
        dirwalk(name, fsize);
    printf(&quot;&amp;8ld %s\n&quot;, stbuf.st_size, name);
}
</code></pre>
<p>The function <code>dirwalk</code> is a general routine that applies a function to each
file in a directory. It opens the directory, loops through the files in it,
calling the function on each, then closes the directory and returns. Since
<code>fsize</code> calls <code>dirwalk</code> on each directory, the two functions call each other
recursively.</p>
<pre><code class="language-c">#define MAX_PATH 1024

/* dirwalk:  apply fcn to all files in dir */
void dirwalk(char *dir, void (*fcn)(char *))
{
    char name[MAX_PATH];
    Dirent *dp;
    DIR *dfd;

    if ((dfd = opendir(dir)) == NULL) {
        fprintf(stderr, &quot;dirwalk: can't open %s\n&quot;, dir);
        return;
    }
    while ((dp = readdir(dfd) != NULL) {
        if (strcmp(dp-&gt;name, &quot;.&quot;) == 0
         || strcmp(dp-&gt;name, &quot;..&quot;) == 0)
            continue;   /* skip self and parent */
        if (strlen(dir)+strlen(dp-&gt;name)+2 &gt; sizeof(name))
            fprintf(stderr, &quot;dirwalk: name %s/%s too long\n&quot;,
                dir, dp-&gt;name);
        else {
            sprintf(name, &quot;%s/%s&quot;, dir, dp-&gt;name);
            (*fcn)(name);
        }
    }
    closedir(dfd);
}
</code></pre>
<p>Each call to <code>readdir</code> returns a pointer to information for the next file, or
<code>NULL</code> when there are no files left. Each directory always contains entries for
itself, called <code>&quot;.&quot;</code>, and its parent, <code>&quot;..&quot;</code>; these must be skipped, or the
program will loop forever.</p>
<p>Down to this level, the code is independent of how directories are formatted.
The next step is to present minimal versions of <code>opendir</code>, <code>readdir</code>, and
<code>closedir</code> for a specific system. The following routines are for Version 7 and
System V UNIX systems; they use the directory information in the header
<code>&lt;sys/dirs.h&gt;</code>m which looks like this:</p>
<pre><code class="language-c">#ifndef DIRSIZ
#define DIRSIZ  14
#endif
struct direct   /* directory entry */
{
    ino_t d_ino;          /* inode number */
    char  d_name[DIRSIZ]; /* long name does not have '\0' */
};
</code></pre>
<p>Some versions of the system permit much longer names and have more complicated
directory structure.</p>
<p>The type <code>ino_t</code> is a <code>typedef</code> that describes the index into the indoe list.
It happens to be <code>unsigned short</code> on the system we use regularly, but this is
not the sort of information to embed in a program; it might be different on a
different system, so the <code>typedef</code> is better. A complete set of “system” types
is found in <code>&lt;sys/types.h&gt;</code>.</p>
<p><code>opendir</code> opens the directory, verifies that the file is a directory (this time
by the system call <code>fstat</code>, which is like <code>stat</code> except that it applied to a
file descriptor), allocates a directory structure, and records the information:</p>
<pre><code class="language-c">int fstat(int fd, struct stat *);

/* opendir:  open a directory for readdir calls */
DIR *opendir(char *dirname)
{
    int fd;
    struct stat stbuf;
    DIR *dp;

    if ((fd = open(dirname, O_RDONLY, 0)) == -1
     || fstat(fd, &amp;stbuf) == -1
     || (stbuf.st_mode &amp; S_IFMT) != S_IFDIR
     || (dp = (DIR *) malloc(sizeof(DIR))) == NULL)
        return NULL;
    dp-&gt;fd = fd;
    return dp;
}
</code></pre>
<p><code>closedir</code> closes the directory file and frees the space:</p>
<pre><code class="language-c">/* closedir:  close directory opened by opendir */
void closedir(DIR *dp)
{
    if (dp) {
        close(dp-&gt;fd);
        free(dp);
    }
}
</code></pre>
<p>Finally, <code>readdir</code> uses <code>read</code> to read each directory entry. If a directory
slot is not currently in use (because a file has been removed), the inode
number is zero, and this position is skipped. Otherwise, the inode number and
name are placed in a <code>static</code> structure and a pointer to that is returned to
the user. Each call overwrites the information from the previous one.</p>
<pre><code class="language-c">#include &lt;sys/dir.h&gt;    /* local direcotry structure */

/* readdir:  read directory entries in sequence */
Dirent *readdir(DIR *dp)
{
    struct direct dirbuf; /* local directory structure */
    static Dirent d;      /* return: portable structure */

    while (read(dp-&gt;fd, (char *) &amp;dirbuf, sizeof(dirbuf))
                    == sizeof(dirbuf)) {
        if (dirbuf.d_ino == 0)    /* slot not in use */
            continue;
        d.ino = dirbuf.d_ino;
        strncpy(d.name, dirbuf.d_name, DIRSIZ);
        d.name[DIRSIZ] = '\0';  /* ensure termination */
        return &amp;d;
    }
    return NULL;
}
</code></pre>
<p>Although the <code>fsize</code> program is rather specialized, it does illustrate a couple
of important ideas. First, many programs are not “system programs”; they merely
use information that is maintained by the operating system. For such programs,
it is crucial that the representation of the information appear only in
standard headers, and that programs include those files instead of embedding
the declarations in themselves. The second observation is that with care it is
possible to create an interface to system-dependent objects that is itself
relatively system-independent. The functions of the standard library are good
examples.</p>
<p><strong>Exercise 8-5.</strong> Modify the <code>fsize</code> program to print the other information
contained in the inode entry.</p>
<h2>Example—A Storage Allocator {#sec:stor-alloc}</h2>
<p>In [Chapter @sec:pointers], we presented a very limited stack-oriented storage
allocator. The version that we will now write is unrestricted. Calls to
<code>malloc</code> and <code>free</code> may occur in any order; <code>malloc</code> calls upon the operating
system to obtain more memory as necessary. These routines illustrate some of
the considerations involved in writing machine-dependent code in a relatively
machine-independent way, and also shows a real-life application of structures,
unions and <code>typedef</code>.</p>
<p>Rather than allocating from a compiled-in fixed-size array, <code>malloc</code> will
request space from the operating system as needed. Since other activities in
the program may also request space without calling this allocator, the space
that <code>malloc</code> manages may not be contiguous. Thus its free storage is kept as a
list of free blocks. Each block contains a size, a pointer to the next block,
and the space itself. The blocks are kept in order of increasing storage
address, and the last block (highest address) points to the first.</p>
<pre><code>free list
        \   +---------------------------------------------+
         \  |+--+ +-------------+ +--------------+ +-+ +-+|
          v v|  v |             v |              v | v | v|
-------------|----|---------------|----------------|---|--|-----
 :: | in  |  *|   *| in  | in  |  *| :::: | in  |  *|  *| *| ::
 :: | use |   |    | use | use |   | :::: | use |   |   |  | ::
----------------------------------------------------------------

                    ----------
                    |        |  free, owned by malloc
                    ----------

                    ----------
                    | in use |  in use, owned by malloc
                    ----------

                    ----------
                    | :::::: |  not owned by malloc
                    ----------
</code></pre>
<p>When a request is made, the free list is scanned until a big-enough block is
found. This algorithm is called “first fit,” by contrast with “best fir,”
which looks for the smallest block that will satisfy the request. If the block
is exactly the size requested it is unlinked from the list and returned to the
user. If the block is too big, it is split, and the proper amount is returned
to the user while the residue remains on the free list. If no big-enough block
is found, another large chunk is obtained from the operating system and linked
into the free list.</p>
<p>Freeing also causes a search of the free list, to find the proper place to
insert the block being freed. If the block being freed is adjacent to a free
block on either side, it is coalesced with it into a single bigger block, so
storage does not become too fragmented. Determining adjacency is easy because
the free list is maintained in order of increasing address.</p>
<p>One problem, which we alluded to in [Chapter @sec:pointers], is to ensure that
the storage returned by <code>malloc</code> is aligned properly for the objects that will
be stored in it. Although machines vary, for each machine there is a most
restrictive type: if the most restrictive type can be stored at a particular
address, all other types may be also. On some machines, the most restrictive
type is a <code>double</code>; on others, <code>int</code> or <code>long</code> suffices.</p>
<p>A free block contains a pointer to the next block in the chain, a record of
the size of the block, and the free space itself; the control information at
the beginning is called the “header.” To simplify alignment, all blocks are
multiples of the header size, and the header is aligned properly. This is
achieved by a union that contains the desired header structure and an instance
of the most restrictive alignment type, which we have arbitrarily made a
<code>long</code>:</p>
<pre><code class="language-c">typedef long Align;  /* for alignment to long boundary */

union header {       /* block header: */
    struct {
        union header *ptr; /* next block if on free list */
        unsigned size;     /* size of this block */
    } s;
    Align x;         /* force alignment of blocks */
};

typedef union header Header;
</code></pre>
<p>The <code>Align</code> field is never used; it just forces each header to be aligned on a
worst-case boundary.</p>
<p>In <code>malloc</code>, the request size in characters is rounded up to the proper number
of header-sized units; the block that will be allocated contains one more
unit, for the header itself, and this is the value recorded in the <code>size</code>
field of the header. The pointer returned by <code>malloc</code> points at the free
space, not at the header itself. The user can do anything with the space
request, but if anything is written outside of the allocated space the list is
likely to be scrambled.</p>
<pre><code>                  +----&gt; points to next free block
                  |
               ---|--------------------------------
               |  * | size |                      |
               |    |      |                      |
               ------------------------------------
                             ^
                             |
                             +---- adress returned to user
</code></pre>
<p>The size field is necessary because the blocks controlled by <code>malloc</code> need not
be contiguous—it is not possible to compute sizes by pointer arithmetic.</p>
<p>The variable <code>base</code> is used to get started. If <code>freep</code> is <code>NULL</code>, as it is at
the first call of <code>malloc</code>, then a degenerate free list is created; it
contains one block of size zero, and points to itself. In any case, the free
list is then searched. The search for a free block of adequate size begins at
the pointer (<code>freep</code>) where the last block was found; this strategy helps keep
the list homogeneous. If a too-big block is found, the tail end is returned to
the user; in this way the header of the original needs only to have its size
adjusted. In all cases, the pointer returned to the user points to the free
space within the block, which begins one unit beyond the header.</p>
<pre><code class="language-c">static Header base;       /* empty list to get started */
static Header *freep = NULL;     /* start of free list */

/* malloc: general-purpose storage allocator */
void *malloc(unsigned nbytes)
{
    Header *p, *prevp;
    Header *morecore(unsigned);
    unsigned nunits;

    nunits = (nbytes+sizeof(Header)-1)/sizeof(Header) + 1;
    if ((prevp = freep) == NULL) {  /* no free list yet */
        base.s.ptr = freep = prevp = &amp;base;
        base.s.size = 0;
    }
    for (p = prevp-&gt;s.ptr; ; prevp = p, p = p-&gt;s.ptr) {
        if (p-&gt;s.size &gt;= nunits) {    /* big enough */
            if (p-&gt;s.size == nunits)     /* exactly */
                prevp-&gt;s.ptr = p-&gt;s.ptr;
            else {             /* allocate tail end */
                p-&gt;s.size -= nunits;
                p += p-&gt;size;
                p-&gt;s.size = nunits;
            }
            freep = prevp;
            return (void *)(p+1);
        }
        if (p == freep)  /* wrapped around free list */
            if ((p = morecore(nunits)) == NULL)
                return NULL;   /* none left */
    }
}
</code></pre>
<p>The function <code>morecore</code> obtains storage from the operating system. The details
of how it does this vary from system to system. Since asking the system for
memory is a comparatively expensive operation, we don’t want to do that on
every call to <code>malloc</code>, so <code>morecore</code> requests at least <code>NALLOC</code> units; this
larger block will be chopped up as needed. After setting the size field,
<code>morecore</code> inserts the additional memory into the arena by calling <code>free</code>.</p>
<p>The UNIX system call <code>sbrk(n)</code> returns a pointer to <code>n</code> more bytes of storage.
<code>sbrk</code> returns <code>-1</code> if there was no space, even though <code>NULL</code> would have been
a better design. The <code>-1</code> must be cast to <code>char *</code> so it can be compared with
the return value. Again, casts make the function relatively immune to the
details of pointer representation on different machines. There is still one
assumption, however, that pointers to different blocks returned by <code>sbrk</code> can
be meaningfully compared. This is not guaranteed by the standard, which
permits pointer comparisons only within an array. Thus this version of
<code>malloc</code> is portable only among machines for which general pointer comparison
is meaningful.</p>
<pre><code class="language-c">#define NALLOC  1024    /* minimum #units to request */

/* morecore:  ask system for more memory */
static Header *morecore(unsigned nu)
{
    char *cp, *sbrk(int);
    Header *up;

    if (nu &lt; NALLOC)
        nu = NALLOC;
    cp = sbrk(nu * sizeof(Header));
    if (cp == (char *) -1)  /* no space at all */
        return NULL;
    up = (Header *) cp;
    up-&gt;s.size = nu;
    free((void *)(up+1));
    return freep;
}
</code></pre>
<p><code>free</code> itself is the last thing. It scans the free list, starting at <code>freep</code>,
looking for the place to insert the free block. This is either between two
existing blocks or at one end of the list. In any case, if the block being
freed is adjacent to either neighbor, the adjacent blocks are combined. The
only troubles are keeping the pointers pointing to the right things and the
sizes correct.</p>
<pre><code class="language-c">/* free:  put block ap in free list */
void free(void *ap)
{
    Header *bp, *p;

    bp = (Header *)ap - 1;    /* point to block header */
    for (p = freep; !(bp &gt; p &amp;&amp; bp &lt; p-&gt;s.ptr); p = p-&gt;s.ptr)
        if (p &gt;= p-&gt;s.ptr &amp;&amp; (bp &gt; p || bp &lt; p-&gt;s.ptr))
            break;  /* freed block at start or end of arena */

    if (bp + bp-&gt;s.size == p-&gt;s.ptr) { /* join to upper nbr */
        bp-&gt;s.size += p-&gt;s.ptr-&gt;s.size;
        bp-&gt;s.ptr = p-&gt;s.ptr-&gt;s.ptr;
    } else
        bp-&gt;s.ptr = p-&gt;s.ptr;
    if (p + p-&gt;size == bp) {           /* join to lower nbr */
        p-&gt;s.size += bp-&gt;s.size;
        p-&gt;s.ptr = bp-&gt;s.ptr;
    } else
        p-&gt;s.ptr = bp;
    freep = p;
}
</code></pre>
<p>Although storage allocation is intrinsically machine-dependent, the code above
illustrates how the machine dependencies can be controlled and confined to a
very small part of the program. The use of <code>typedef</code> and <code>union</code> handles
alignment (given that <code>sbrk</code> supplies an appropriate pointer). Casts arrange
that pointer conversions are made explicit, and even cope with a
badly-designed system interface. Even though the details here are related to
storage allocation, the general approach is applicable to other situations as
well.</p>
<p><strong>Exercise 8-6.</strong> The standard library function <code>calloc(n,size)</code> returns a
pointer to <code>n</code> objects of size <code>size</code>, with the storage initialized to zero.
Write <code>calloc</code>, by calling <code>malloc</code> or by modifying it.</p>
<p><strong>Exercise 8-7.</strong> <code>malloc</code> accepts a size request without checking its
plausibility; <code>free</code> believes that the block it is asked to free contains a
valid size field. Improve these routines so they take more pains with error
checking.</p>
<p><strong>Exercise 8-8.</strong> Write a function <code>bfree(p,n)</code> that will free an arbitrary
block <code>p</code> of <code>n</code> characters into the free list maintained by <code>malloc</code> and
<code>free</code>. By using <code>bfree</code>, a user can add a static or external array to the
free list at any time.</p>
<p>\appendix</p>
<h1>Reference Manual {#sec:ref-man}</h1>
<h2>Introduction</h2>
<p>This manual describes the C language specified by the draft submitted to ANSI
on 31 October, 1988, for approval as “American National Standard for
Information Systems—Programming Language C, X3.159-1989.” The manual is an
interpretation of the proposed standard, not the Standard itself, although care
has been taken to make it a reliable guide to the language.</p>
<p>For the most part, this documentation follows the broad outline of the
Standard, which in turn follows that of the first edition of this book,
although the organization differs in detail. Except for renaming a few
productions, and not formalizing the definitions of the lexical tokens or the
preprocessor, the grammar given here for the language proper is equivalent to
that of the Standard.</p>
<p>::: commentary
Throughout this manual, commentary material is indented and written in smaller
type, as this is. Most often these comments highlight ways in which ANSI
Standard C differs from the language defined by the first edition of this book,
or from refinements subsequently introduced in various compilers.
:::</p>
<h2>Lexical Conventions</h2>
<p>A program consists of one or more <em>translation units</em> stored in files. It is
translated in several phases, which are described in [§@sec:preproc]. The
first phases do low-level lexical transformations, carry out directives
introduced by lines beginning with the <code>#</code> character, and perform macro
definition and expansion. When the preprocessing of [§@sec:preproc] is
complete, the program has been reduced to a sequence of tokens.</p>
<h3>Tokens</h3>
<p>There are six classes of tokens: identifiers, keyword, constants, string
literals, operators, and other separators. Blanks, horizontal and vertical
tabs, newline, formfeed, and comments are described below (collectively,
“white space”) are ignored except as they separate tokens. Some white space is
required to separate otherwise adjacent identifiers, keywords, and constants.</p>
<p>If the input stream has been separated into tokens up to a given character,
the next token is the longest string of characters that could constitute a
token.</p>
<h3>Comments</h3>
<p>The characters <code>/*</code> introduce a comment, which terminates with the characters
<code>*/</code>. Comments do not nest, and they do not occur within string or character
literals.</p>
<h3>Identifiers</h3>
<p>An identifier is a sequence of letters and digits. The first character must be
a letter; the underscore <code>_</code> counts as a letter. Upper and lower case letters
are different. Identifiers may have any length, and for internal identifiers,
at least the first 31 characters are significant; some implementations may
,ale ,pre characters significant. Internal identifiers include preprocessor
macro names and all other names that do not have external linkage
([§@sec:linkage]). Identifiers with external linkage are more restricted:
implementations may make as few as the first six characters as significant,
and may ignore case distinctions.</p>
<h3>Keywords</h3>
<p>The following identifiers are reserved for use as keywords, and may not be
used otherwise:</p>
<pre><code>quto       double   int        struct
break      else     long       switch
case       enum     register   typedef
char       extern   return     union
const      float    short      unsigned
continue   for      signed     void
default    goto     sizeof     volatile
do         if       static     while
</code></pre>
<p>Some implementations also reserve the words <code>fortran</code> and <code>asm</code>.</p>
<p>::: commentary
The keywords <code>const</code>, <code>signed</code>, and volatile are new with the ANSI standard;
<code>num</code> and <code>void</code> are new since the first edition, but in common use; <code>entry</code>,
formerly reserved but never used, is no longer reserved.
:::</p>
<h3>Constants</h3>
<p>There are several kinds of constatns. Each has a daya type; [§@sec:basictypes]
discusses the basic types.</p>
<pre><code>constant:
    integer-constant
    character-constant
    floating-constant
    enumeration-constant
</code></pre>
<h4>Integer Constants</h4>
<p>An integer constant consisting of a sequence of digits is taken to be octal if
it begins with <code>0</code> (digit zero), decimal otherwise. Octal constants do not
contain the digits <code>8</code> or <code>9</code>. A sequence of digits preceded by <code>0x</code> or <code>0X</code>
(digit zero) is taken to be a hexadecimal integer. The hexadecimal digits
include <code>a</code> or <code>A</code> through <code>f</code> or <code>F</code> with values <code>10</code> through <code>15</code>.</p>
<p>An integer constant may be suffixed by the letter <code>u</code> or <code>U</code>, to specify that
it is unsigned. It may also be suffixed by the letter <code>l</code> or <code>L</code> to specify
that it is long.</p>
<p>The type of an integer constant depends on its form, value and suffix. (See
[§@sec:meaning-of-ident] for a discussion of types.) If it is unsuffixed and
decimal, it has the first of these types in which its value can be
represented: <code>int</code>, <code>long int</code>, <code>unsigned long int</code>. If it is unsuffixed octal
or hexadecimal, it has the first possible of these types: <code>int</code>, <code>unsigned int</code>, <code>long int</code>, <code>unsigned long int</code>. If it is suffixed by <code>u</code> or <code>U</code>, then
<code>unsigned int</code>, <code>unsigned long int</code>. If it is suffixed by <code>1</code> or <code>L</code>, then
<code>long int</code>, <code>unsigned long int</code>.</p>
<p>::: commentary
The elaboration of the types of integer constants goes considerably beyond the
first edition, which merely caused large integer constants to be <code>long</code>. The
<code>U</code> suffixes are new.
:::</p>
<h4>Character Constants</h4>
<p>A character constant is a sequence of one or more characters enclosed in
single quotes, as in <code>'x'</code>. The value of a character constant with only one
character is the numeric value of the character in the machine’s character set
at execution time. The value of a multi-character constant is
implementation-defined.</p>
<p>Character constants do not contain the <code>'</code> character or newlines; in order to
represent them, and certain other characters, the following escape sequences
may be used.</p>
<pre><code>newline           NL (LF)   \n      backslash       \     \\
horizontal tab    HT        \t      question mark   ?     \?
vertical tab      VT        \v      single quote    '     \'
backspace         BS        \b      double quote    &quot;     \&quot;
carriage return   CR        \r      octal number    ooo   \ooo
formfeed          FF        \f      hex number      hh    \xhh
audible alert     BEL       \a
</code></pre>
<p>The escape <code>\ooo</code> consists of the backslash followed by 1, 2, or 3 octal
digits, which are taken to specify the value of the desired character. A
common example of this construction is <code>\0</code> (not followed by a digit), which
specified the character <code>NUL</code>. The escape <code>\xhh</code> consists of the backslash,
followed by <code>x</code>, followed by hexadecimal digits, which are taken to specify
the value of the desired character. There is no limit on the number of digits,
bu the behavior is undefined if the resulting character value exceeds that of
the largest character. For either octal or hexadecimal escape characters, if
the implementation treats the <code>char</code> type as signed, the value is
sign-extended as if cast to <code>char</code> type. If the character following the <code>\</code> is
not one of those specified, the behavior is undefined.</p>
<p>In some implementations, there is an extended set of character that cannot be
represented in the <code>char</code> type. A constant in this extended set is written
with a preceding <code>L</code>, for example <code>L'x'</code>, and is called a wide character
constant. Such a constant has type <code>wchar_t</code>, an integral type defined in the
standard header <code>&lt;stddef.h&gt;</code>. As with ordinary character constants, octal or
hexadecimal escapes may be used; the effect is undefined if the specified
value exceeds that representable with <code>wchar_t</code>.</p>
<p>::: commentary
Some of these escape sequences are new, in particular the hexadecimal
character representation. Extended characters are also new. The character sets
commonly used in the Americas and western Europe can be encoded to fit in the
<code>char</code> type; the main intent in adding <code>wchar_t</code> was to accommodate Asian
languages.
:::</p>
<h4>Floating Constants</h4>
<p>A floating constant consists of an integer part, a decimal point, a fraction
part, an <code>e</code> or <code>E</code>, an optionally signed integer exponent and an optional
type suffix one of <code>f</code>, <code>F</code>, <code>l</code>, or <code>L</code>. The integer and fraction parts both
consist of a sequence of digits. Either the integer part or the fraction part
(not both) may be missing; either the decimal point or the <code>e</code> and the
exponent (not both) may be missing. The type is determined by the suffix; <code>F</code>
or <code>f</code> makes it <code>float</code>, <code>L</code> or <code>l</code> makes it <code>long double</code>; otherwise it is
<code>double</code>.</p>
<p>::: commentary
Suffixes on floating constants are new.
:::</p>
<h4>Enumeration Constants</h4>
<p>Identifiers declared as enumerators (see [§@sec:enumerations]) are constants
of type <code>int</code>.</p>
<h3>String literals</h3>
<p>A string literal, also called a string constant, is a sequence of characters
surrounded by double quotes, as in <code>&quot;...&quot;</code>. A string has type “array of
characters” and storage class <code>static</code> (see [§@sec:meaning-of-ident] below)
and is initialized with the given characters. Whether identical string
literals are distinct is implementation-defined, and the behavior of a program
that attempts to alter a string literal is undefined.</p>
<p>Adjacent string literals are concatenated into a single string. After any
concatenation, a null byte <code>\0</code> is appended to the string so that programs
that scan the string can find its end. String literals do not contain newline
or double-quote characters; in order to represent them ,the same escape
sequences as for character constants are available.</p>
<p>As with character constants, string literals in an extended character set are
written with a preceding <code>L</code>, as in <code>L&quot;...&quot;</code>. Wide-character string literals
have type “array of <code>wchar_t</code>.” Concatenation of ordinary and wide string
literals is undefined.</p>
<p>::: commentary
The specification that string literals need not be distinct, and the
prohibition against modifying them, are new in the ANSI standard, as is the
concatenation of adjacent string literals. Wide-character string literals are
new.
:::</p>
<h2>Syntax Notation</h2>
<h2>Meaning of Identifiers {#sec:meaning-of-ident}</h2>
<h3>Storage Class</h3>
<h3>Basic Types {#sec:basictypes}</h3>
<h3>Derived Types</h3>
<h3>Type Qualifiers</h3>
<h2>Objects and Lvalues</h2>
<h2>Conversions {#sec:conversions}</h2>
<h3>Integral Promotion</h3>
<h3>Integral Conversions</h3>
<h3>Integer and Floating</h3>
<h3>Floating Types</h3>
<h3>Arithmetic Conversions</h3>
<h3>Pointers and Integers</h3>
<h3>Void</h3>
<h3>Pointers to Void</h3>
<h2>Expressions</h2>
<h3>Pointer Generation</h3>
<h3>Primary Expressions</h3>
<h3>Postfix Expressions</h3>
<h4>Array References</h4>
<h4>Function Calls</h4>
<h4>Structure References</h4>
<h4>Postfix Incrementation</h4>
<h3>Unary Operators</h3>
<h4>Prefix Incrementation Operators</h4>
<h4>Address Operator</h4>
<h4>Indirection Operator</h4>
<h4>Unary Plus Operator</h4>
<h4>Unary Minus Operator</h4>
<h4>One’s Complement Operator</h4>
<h4>Logical Negation Operator</h4>
<h4>Sizeof Operator</h4>
<h3>Casts</h3>
<h3>Multiplicative Operators</h3>
<h3>Additive Operators</h3>
<h3>Shift Operators</h3>
<h3>Relational Operators</h3>
<h3>Equality Operators</h3>
<h3>Bitwise AND Operator</h3>
<h3>Bitwise Exclusive OR Operator</h3>
<h3>Bitwise Inclusive OR Operator</h3>
<h3>Logical AND Operator</h3>
<h3>Logical OR Operator</h3>
<h3>Conditional Operator</h3>
<h3>Assignment Expressions</h3>
<h3>Comma Operator</h3>
<h3>Constant Expressions</h3>
<h2>Declarations</h2>
<h3>Storage Class specifiers</h3>
<h3>Type Specifiers</h3>
<h3>Structure and Union Declarations</h3>
<h3>Enumerations {#sec:enumerations}</h3>
<h3>Declarators {#sec:declarators}</h3>
<h3>Meaning of Declarators</h3>
<h4>Pointer Declarators</h4>
<h4>Array Declarators</h4>
<h4>Function Declarators</h4>
<h3>Initialization</h3>
<h3>Type Names</h3>
<h3>Typedef</h3>
<h3>Type Equivalence</h3>
<h2>Statements</h2>
<h3>Labeled Statements</h3>
<h3>Expression Statement</h3>
<h3>Compound Statement</h3>
<h3>Selection Statements</h3>
<h3>Iteration Statements</h3>
<h3>Jump Statements</h3>
<h2>External Declarations</h2>
<h3>Function Definitions</h3>
<h3>External Declarations</h3>
<h2>Scope and Linkage</h2>
<h3>Lexical Scope</h3>
<h3>Linkage {#sec:linkage}</h3>
<h2>Preprocessing {#sec:preproc}</h2>
<h3>Trigraph Sequences</h3>
<h3>Line Splicing</h3>
<h3>Macro Definition and Expansion</h3>
<h3>File Inclusion</h3>
<h3>Conditional Compilation</h3>
<h3>Line Control</h3>
<h3>Error Generation</h3>
<h3>Pragmas</h3>
<h3>Null Directive</h3>
<h3>Predefined Names</h3>
<h2>Grammar</h2>
<h1>Standard Library {#sec:std-lib}</h1>
<h2>Input and Output: <code>&lt;stdio.h&gt;</code> {#sec:stdio}</h2>
<h3>File Operations</h3>
<h3>Formatted Output</h3>
<h3>Formatted Input</h3>
<h3>Character Input and Output Functions</h3>
<h3>Direct Input and Output Functions</h3>
<h3>File Positioning Functions</h3>
<h3>Error Functions</h3>
<h2>Character Class Tests: <code>&lt;ctype.h&gt;</code></h2>
<h2>String Functions: <code>&lt;string.h&gt;</code></h2>
<h2>Mathematical Functions: <code>&lt;math.h&gt;</code> {#sec:math}</h2>
<h2>Utility Functions: <code>&lt;stdlib.h&gt;</code> {#sec:stdlib}</h2>
<h2>Diagnostics: <code>&lt;assert.h&gt;</code></h2>
<h2>Variable Argument Lists: <code>&lt;stdarg.h&gt;</code></h2>
<h2>Non-local Jumps: <code>&lt;setjmp.h&gt;</code></h2>
<h2>Signals: `&lt;signal.h&gt;</h2>
<h2>Date and Time Functions: <code>&lt;time.h&gt;</code></h2>
<h2>Implementation-defined Limits: <code>&lt;limits.h&gt;</code> and <code>&lt;float.h&gt;</code></h2>
<h1>Summary of Changes {#sec:changes}</h1>
</body></html>